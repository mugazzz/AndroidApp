"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addWebSocketHandler = addWebSocketHandler;
exports.removeWebSocketHandler = removeWebSocketHandler;
exports.removeAllWebSocketHandlers = removeAllWebSocketHandlers;
exports.getWebSocketHandlers = getWebSocketHandlers;
exports.DEFAULT_WS_PATHNAME_PREFIX = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _url = _interopRequireDefault(require("url"));

const DEFAULT_WS_PATHNAME_PREFIX = '/ws';
exports.DEFAULT_WS_PATHNAME_PREFIX = DEFAULT_WS_PATHNAME_PREFIX;

function addWebSocketHandler(_x, _x2) {
  return _addWebSocketHandler.apply(this, arguments);
}

function _addWebSocketHandler() {
  _addWebSocketHandler = (0, _asyncToGenerator2.default)(function* (handlerPathname, handlerServer) {
    let isUpgradeListenerAssigned = true;

    if (_lodash.default.isUndefined(this.webSocketsMapping)) {
      this.webSocketsMapping = {};
      isUpgradeListenerAssigned = false;
    }

    this.webSocketsMapping[handlerPathname] = handlerServer;

    if (isUpgradeListenerAssigned) {
      return;
    }

    this.on('upgrade', (request, socket, head) => {
      const currentPathname = _url.default.parse(request.url).pathname;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _lodash.default.toPairs(this.webSocketsMapping)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const _step$value = (0, _slicedToArray2.default)(_step.value, 2),
                pathname = _step$value[0],
                wsServer = _step$value[1];

          if (currentPathname === pathname) {
            wsServer.handleUpgrade(request, socket, head, ws => {
              wsServer.emit('connection', ws, request);
            });
            return;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      socket.destroy();
    });
  });
  return _addWebSocketHandler.apply(this, arguments);
}

function getWebSocketHandlers() {
  return _getWebSocketHandlers.apply(this, arguments);
}

function _getWebSocketHandlers() {
  _getWebSocketHandlers = (0, _asyncToGenerator2.default)(function* (keysFilter = null) {
    if (_lodash.default.isEmpty(this.webSocketsMapping)) {
      return {};
    }

    let result = {};
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _lodash.default.toPairs(this.webSocketsMapping)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        const _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
              pathname = _step2$value[0],
              wsServer = _step2$value[1];

        if (!_lodash.default.isString(keysFilter) || pathname.includes(keysFilter)) {
          result[pathname] = wsServer;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return result;
  });
  return _getWebSocketHandlers.apply(this, arguments);
}

function removeWebSocketHandler(_x3) {
  return _removeWebSocketHandler.apply(this, arguments);
}

function _removeWebSocketHandler() {
  _removeWebSocketHandler = (0, _asyncToGenerator2.default)(function* (handlerPathname) {
    if (!this.webSocketsMapping || !this.webSocketsMapping[handlerPathname]) {
      return false;
    }

    try {
      this.webSocketsMapping[handlerPathname].close();
      return true;
    } catch (ign) {} finally {
      delete this.webSocketsMapping[handlerPathname];
    }

    return false;
  });
  return _removeWebSocketHandler.apply(this, arguments);
}

function removeAllWebSocketHandlers() {
  return _removeAllWebSocketHandlers.apply(this, arguments);
}

function _removeAllWebSocketHandlers() {
  _removeAllWebSocketHandlers = (0, _asyncToGenerator2.default)(function* () {
    if (_lodash.default.isEmpty(this.webSocketsMapping)) {
      return false;
    }

    let result = false;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _lodash.default.keys(this.webSocketsMapping)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        const pathname = _step3.value;
        result = result || (yield this.removeWebSocketHandler(pathname));
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return result;
  });
  return _removeAllWebSocketHandlers.apply(this, arguments);
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9leHByZXNzL3dlYnNvY2tldC5qcyJdLCJuYW1lcyI6WyJERUZBVUxUX1dTX1BBVEhOQU1FX1BSRUZJWCIsImFkZFdlYlNvY2tldEhhbmRsZXIiLCJoYW5kbGVyUGF0aG5hbWUiLCJoYW5kbGVyU2VydmVyIiwiaXNVcGdyYWRlTGlzdGVuZXJBc3NpZ25lZCIsIl8iLCJpc1VuZGVmaW5lZCIsIndlYlNvY2tldHNNYXBwaW5nIiwib24iLCJyZXF1ZXN0Iiwic29ja2V0IiwiaGVhZCIsImN1cnJlbnRQYXRobmFtZSIsInVybCIsInBhcnNlIiwicGF0aG5hbWUiLCJ0b1BhaXJzIiwid3NTZXJ2ZXIiLCJoYW5kbGVVcGdyYWRlIiwid3MiLCJlbWl0IiwiZGVzdHJveSIsImdldFdlYlNvY2tldEhhbmRsZXJzIiwia2V5c0ZpbHRlciIsImlzRW1wdHkiLCJyZXN1bHQiLCJpc1N0cmluZyIsImluY2x1ZGVzIiwicmVtb3ZlV2ViU29ja2V0SGFuZGxlciIsImNsb3NlIiwiaWduIiwicmVtb3ZlQWxsV2ViU29ja2V0SGFuZGxlcnMiLCJrZXlzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBLE1BQU1BLDBCQUEwQixHQUFHLEtBQW5DOzs7U0FnQmVDLG1COzs7Ozt5REFBZixXQUFvQ0MsZUFBcEMsRUFBcURDLGFBQXJELEVBQW9FO0FBQ2xFLFFBQUlDLHlCQUF5QixHQUFHLElBQWhDOztBQUNBLFFBQUlDLGdCQUFFQyxXQUFGLENBQWMsS0FBS0MsaUJBQW5CLENBQUosRUFBMkM7QUFDekMsV0FBS0EsaUJBQUwsR0FBeUIsRUFBekI7QUFDQUgsTUFBQUEseUJBQXlCLEdBQUcsS0FBNUI7QUFDRDs7QUFDRCxTQUFLRyxpQkFBTCxDQUF1QkwsZUFBdkIsSUFBMENDLGFBQTFDOztBQUNBLFFBQUlDLHlCQUFKLEVBQStCO0FBQzdCO0FBQ0Q7O0FBR0QsU0FBS0ksRUFBTCxDQUFRLFNBQVIsRUFBbUIsQ0FBQ0MsT0FBRCxFQUFVQyxN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ZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5cbmNvbnN0IERFRkFVTFRfV1NfUEFUSE5BTUVfUFJFRklYID0gJy93cyc7XG5cblxuLyoqXG4gKiBBZGRzIHdlYnNvY2tldCBoYW5kbGVyIHRvIGV4cHJlc3Mgc2VydmVyIGluc3RhbmNlLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW4gRXhwcmVzc1xuICogc2VydmVyIGluc3RhbmNlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZlciAtIEFuIGluc3RhbmNlIG9mIGV4cHJlc3MgSFRUUCBzZXJ2ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlclBhdGhuYW1lIC0gV2ViIHNvY2tldCBlbmRwb2ludCBwYXRoIHN0YXJ0aW5nIHdpdGhcbiAqIGEgc2luZ2xlIHNsYXNoIGNoYXJhY3Rlci4gSXQgaXMgcmVjb21tZW5kZWQgdG8gYWx3YXlzIGFkZFxuICogREVGQVVMVF9XU19QQVRITkFNRV9QUkVGSVggdG8gYWxsIHdlYiBzb2NrZXQgcGF0aG5hbWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJTZXJ2ZXIgLSBXZWJTb2NrZXQgc2VydmVyIGluc3RhbmNlLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvODg1IGZvciBtb3JlIGRldGFpbHNcbiAqIG9uIGhvdyB0byBjb25maWd1cmUgdGhlIGhhbmRsZXIgcHJvcGVybHkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFkZFdlYlNvY2tldEhhbmRsZXIgKGhhbmRsZXJQYXRobmFtZSwgaGFuZGxlclNlcnZlcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgbGV0IGlzVXBncmFkZUxpc3RlbmVyQXNzaWduZWQgPSB0cnVlO1xuICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLndlYlNvY2tldHNNYXBwaW5nKSkge1xuICAgIHRoaXMud2ViU29ja2V0c01hcHBpbmcgPSB7fTtcbiAgICBpc1VwZ3JhZGVMaXN0ZW5lckFzc2lnbmVkID0gZmFsc2U7XG4gIH1cbiAgdGhpcy53ZWJTb2NrZXRzTWFwcGluZ1toYW5kbGVyUGF0aG5hbWVdID0gaGFuZGxlclNlcnZlcjtcbiAgaWYgKGlzVXBncmFkZUxpc3RlbmVyQXNzaWduZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzg4NVxuICB0aGlzLm9uKCd1cGdyYWRlJywgKHJlcXVlc3QsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRQYXRobmFtZSA9IHVybC5wYXJzZShyZXF1ZXN0LnVybCkucGF0aG5hbWU7XG4gICAgZm9yIChjb25zdCBbcGF0aG5hbWUsIHdzU2VydmVyXSBvZiBfLnRvUGFpcnModGhpcy53ZWJTb2NrZXRzTWFwcGluZykpIHtcbiAgICAgIGlmIChjdXJyZW50UGF0aG5hbWUgPT09IHBhdGhuYW1lKSB7XG4gICAgICAgIHdzU2VydmVyLmhhbmRsZVVwZ3JhZGUocmVxdWVzdCwgc29ja2V0LCBoZWFkLCAod3MpID0+IHtcbiAgICAgICAgICB3c1NlcnZlci5lbWl0KCdjb25uZWN0aW9uJywgd3MsIHJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdlYiBzb2NrZXQgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIHNlcnZlclxuICogaW5zdGFuY2UuXG4gKiBJdCBpcyBleHBlY3RlZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbiBFeHByZXNzXG4gKiBzZXJ2ZXIgaW5zdGFuY2UgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IGtleXNGaWx0ZXIgW251bGxdLSBPbmx5IGluY2x1ZGUgcGF0aG5hbWVzIHdpdGggZ2l2ZW5cbiAqIGBrZXlzRmlsdGVyYCB2YWx1ZSBpZiBzZXQuIEFsbCBwYWlycyB3aWxsIGJlIGluY2x1ZGVkIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwYXRobmFtZXMgdG8gd2Vic29ja2V0IHNlcnZlciBpc250YW5jZXMgbWFwcGluZ1xuICogbWF0Y2hpbmcgdGhlIHNlYXJjaCBjcml0ZXJpYSBvciBhbiBlbXB0eSBvYmplY3Qgb3RoZXJ3aXNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRXZWJTb2NrZXRIYW5kbGVycyAoa2V5c0ZpbHRlciA9IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gIGlmIChfLmlzRW1wdHkodGhpcy53ZWJTb2NrZXRzTWFwcGluZykpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBsZXQgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW3BhdGhuYW1lLCB3c1NlcnZlcl0gb2YgXy50b1BhaXJzKHRoaXMud2ViU29ja2V0c01hcHBpbmcpKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGtleXNGaWx0ZXIpIHx8IHBhdGhuYW1lLmluY2x1ZGVzKGtleXNGaWx0ZXIpKSB7XG4gICAgICByZXN1bHRbcGF0aG5hbWVdID0gd3NTZXJ2ZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBleGlzdGluZyB3ZWJzb2NrZXQgaGFuZGxlciBmcm9tIGV4cHJlc3Mgc2VydmVyIGluc3RhbmNlLlxuICogVGhlIGNhbGwgaXMgaWdub3JlZCBpZiB0aGUgZ2l2ZW4gYGhhbmRsZXJQYXRobmFtZWAgaGFuZGxlclxuICogaXMgbm90IHByZXNlbnQgaW4gdGhlIGhhbmRsZXJzIGxpc3QuXG4gKiBJdCBpcyBleHBlY3RlZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbiBFeHByZXNzXG4gKiBzZXJ2ZXIgaW5zdGFuY2UgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlclBhdGhuYW1lIC0gV2Vic29ja2V0IGVuZHBvaW50IHBhdGguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgaGFuZGxlclBhdGhuYW1lIHdhcyBmb3VuZCBhbmQgZGVsZXRlZFxuICovXG5hc3luYyBmdW5jdGlvbiByZW1vdmVXZWJTb2NrZXRIYW5kbGVyIChoYW5kbGVyUGF0aG5hbWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gIGlmICghdGhpcy53ZWJTb2NrZXRzTWFwcGluZyB8fCAhdGhpcy53ZWJTb2NrZXRzTWFwcGluZ1toYW5kbGVyUGF0aG5hbWVdKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLndlYlNvY2tldHNNYXBwaW5nW2hhbmRsZXJQYXRobmFtZV0uY2xvc2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoaWduKSB7XG4gICAgLy8gaWdub3JlXG4gIH0gZmluYWxseSB7XG4gICAgZGVsZXRlIHRoaXMud2ViU29ja2V0c01hcHBpbmdbaGFuZGxlclBhdGhuYW1lXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZXhpc3Rpbmcgd2Vic29ja2V0IGhhbmRsZXIgZnJvbSBleHByZXNzIHNlcnZlciBpbnN0YW5jZS5cbiAqIEl0IGlzIGV4cGVjdGVkIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGluIEV4cHJlc3NcbiAqIHNlcnZlciBpbnN0YW5jZSBjb250ZXh0LlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGF0IGxlYXN0IG9uZSBoYW5kbGVyIGhhcyBiZWVuIGRlbGV0ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlQWxsV2ViU29ja2V0SGFuZGxlcnMgKCkge1xuICBpZiAoXy5pc0VtcHR5KHRoaXMud2ViU29ja2V0c01hcHBpbmcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHBhdGhuYW1lIG9mIF8ua2V5cyh0aGlzLndlYlNvY2tldHNNYXBwaW5nKSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBhd2FpdCB0aGlzLnJlbW92ZVdlYlNvY2tldEhhbmRsZXIocGF0aG5hbWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7XG4gIGFkZFdlYlNvY2tldEhhbmRsZXIsIHJlbW92ZVdlYlNvY2tldEhhbmRsZXIsIHJlbW92ZUFsbFdlYlNvY2tldEhhbmRsZXJzLFxuICBnZXRXZWJTb2NrZXRIYW5kbGVycywgREVGQVVMVF9XU19QQVRITkFNRV9QUkVGSVgsXG59O1xuIl0sImZpbGUiOiJsaWIvZXhwcmVzcy93ZWJzb2NrZXQuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
