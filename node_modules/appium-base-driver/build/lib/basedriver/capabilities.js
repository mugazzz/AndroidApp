"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCaps = parseCaps;
exports.processCapabilities = processCapabilities;
exports.validateCaps = validateCaps;
exports.mergeCaps = mergeCaps;
exports.findNonPrefixedCaps = findNonPrefixedCaps;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _lodash = _interopRequireDefault(require("lodash"));

var _desiredCaps = require("./desired-caps");

var _appiumSupport = require("appium-support");

var _logger = _interopRequireDefault(require("./logger"));

var _errors = require("../protocol/errors");

function mergeCaps(primary = {}, secondary = {}) {
  let result = Object.assign({}, primary);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _lodash.default.toPairs(secondary)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      let _step$value = (0, _slicedToArray2.default)(_step.value, 2),
          name = _step$value[0],
          value = _step$value[1];

      if (!_lodash.default.isUndefined(primary[name])) {
        throw new _errors.errors.InvalidArgumentError(`property '${name}' should not exist on both primary (${JSON.stringify(primary)}) and secondary (${JSON.stringify(secondary)}) object`);
      }

      result[name] = value;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

function validateCaps(caps, constraints = {}, opts = {}) {
  let skipPresenceConstraint = opts.skipPresenceConstraint;

  if (!_lodash.default.isPlainObject(caps)) {
    throw new _errors.errors.InvalidArgumentError(`must be a JSON object`);
  }

  constraints = _lodash.default.cloneDeep(constraints);

  if (skipPresenceConstraint) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _lodash.default.keys(constraints)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        let key = _step2.value;
        delete constraints[key].presence;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  let validationErrors = _desiredCaps.validator.validate(_lodash.default.pickBy(caps, _appiumSupport.util.hasValue), constraints, {
    fullMessages: false
  });

  if (validationErrors) {
    let message = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _lodash.default.toPairs(validationErrors)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        let _step3$value = (0, _slicedToArray2.default)(_step3.value, 2),
            attribute = _step3$value[0],
            reasons = _step3$value[1];

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = reasons[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            let reason = _step4.value;
            message.push(`'${attribute}' ${reason}`);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    throw new _errors.errors.InvalidArgumentError(message.join('; '));
  }

  return caps;
}

const STANDARD_CAPS = ['browserName', 'browserVersion', 'platformName', 'acceptInsecureCerts', 'pageLoadStrategy', 'proxy', 'setWindowRect', 'timeouts', 'unhandledPromptBehavior'];

function isStandardCap(cap) {
  return !!_lodash.default.find(STANDARD_CAPS, standardCap => standardCap.toLowerCase() === `${cap}`.toLowerCase());
}

function stripAppiumPrefixes(caps) {
  const prefix = 'appium:';

  const prefixedCaps = _lodash.default.filter(_lodash.default.keys(caps), cap => `${cap}`.startsWith(prefix));

  const badPrefixedCaps = [];
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = prefixedCaps[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      let prefixedCap = _step5.value;
      const strippedCapName = prefixedCap.substr(prefix.length);

      if (isStandardCap(strippedCapName)) {
        badPrefixedCaps.push(strippedCapName);
      }

      caps[strippedCapName] = caps[prefixedCap];
      delete caps[prefixedCap];
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  if (badPrefixedCaps.length > 0) {
    throw new _errors.errors.InvalidArgumentError(`The capabilities ${JSON.stringify(badPrefixedCaps)} are standard capabilities and should not have the "appium:" prefix`);
  }
}

function findNonPrefixedCaps({
  alwaysMatch = {},
  firstMatch = []
}) {
  return _lodash.default.chain([alwaysMatch, ...firstMatch]).reduce((unprefixedCaps, caps) => [...unprefixedCaps, ...(0, _lodash.default)(caps).keys().filter(cap => !cap.includes(':') && !isStandardCap(cap))], []).uniq().value();
}

function parseCaps(caps, constraints = {}, shouldValidateCaps = true) {
  if (!_lodash.default.isPlainObject(caps)) {
    throw new _errors.errors.InvalidArgumentError('The capabilities argument was not valid for the following reason(s): "capabilities" must be a JSON object.');
  }

  let _caps$alwaysMatch = caps.alwaysMatch,
      requiredCaps = _caps$alwaysMatch === void 0 ? {} : _caps$alwaysMatch,
      _caps$firstMatch = caps.firstMatch,
      allFirstMatchCaps = _caps$firstMatch === void 0 ? [{}] : _caps$firstMatch;

  if (!_lodash.default.isArray(allFirstMatchCaps)) {
    throw new _errors.errors.InvalidArgumentError('The capabilities.firstMatch argument was not valid for the following reason(s): "capabilities.firstMatch" must be a JSON array or undefined');
  }

  if (allFirstMatchCaps.length === 0) {
    allFirstMatchCaps.push({});
  }

  let nonPrefixedCaps = findNonPrefixedCaps(caps);

  if (!_lodash.default.isEmpty(nonPrefixedCaps)) {
    _logger.default.warn(`The capabilities ${JSON.stringify(nonPrefixedCaps)} are not standard capabilities and should have an extension prefix`);
  }

  stripAppiumPrefixes(requiredCaps);
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = allFirstMatchCaps[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      let firstMatchCaps = _step6.value;
      stripAppiumPrefixes(firstMatchCaps);
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
        _iterator6.return();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  if (shouldValidateCaps) {
    requiredCaps = validateCaps(requiredCaps, constraints, {
      skipPresenceConstraint: true
    });
  }

  let filteredConstraints = (0, _objectSpread2.default)({}, constraints);

  let requiredCapsKeys = _lodash.default.keys(requiredCaps);

  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = _lodash.default.keys(filteredConstraints)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      let key = _step7.value;

      if (requiredCapsKeys.includes(key)) {
        delete filteredConstraints[key];
      }
    }
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
        _iterator7.return();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  let validationErrors = [];
  let validatedFirstMatchCaps = allFirstMatchCaps.map(firstMatchCaps => {
    try {
      return shouldValidateCaps ? validateCaps(firstMatchCaps, filteredConstraints) : firstMatchCaps;
    } catch (e) {
      validationErrors.push(e.message);
      return null;
    }
  }).filter(caps => !_lodash.default.isNull(caps));
  let matchedCaps = null;
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = validatedFirstMatchCaps[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      let firstMatchCaps = _step8.value;

      try {
        matchedCaps = mergeCaps(requiredCaps, firstMatchCaps);

        if (matchedCaps) {
          break;
        }
      } catch (err) {
        _logger.default.warn(err.message);
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
        _iterator8.return();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  return {
    requiredCaps,
    allFirstMatchCaps,
    validatedFirstMatchCaps,
    matchedCaps,
    validationErrors
  };
}

function processCapabilities(caps, constraints = {}, shouldValidateCaps = true) {
  const _parseCaps = parseCaps(caps, constraints, shouldValidateCaps),
        matchedCaps = _parseCaps.matchedCaps,
        validationErrors = _parseCaps.validationErrors;

  if (!_appiumSupport.util.hasValue(matchedCaps)) {
    if (_lodash.default.isArray(caps.firstMatch) && caps.firstMatch.length > 1) {
      throw new _errors.errors.InvalidArgumentError(`Could not find matching capabilities from ${JSON.stringify(caps)}:\n ${validationErrors.join('\n')}`);
    } else {
      throw new _errors.errors.InvalidArgumentError(validationErrors[0]);
    }
  }

  return matchedCaps;
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2NhcGFiaWxpdGllcy5qcyJdLCJuYW1lcyI6WyJtZXJnZUNhcHMiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwicmVzdWx0IiwiT2JqZWN0IiwiYXNzaWduIiwiXyIsInRvUGFpcnMiLCJuYW1lIiwidmFsdWUiLCJpc1VuZGVmaW5lZCIsImVycm9ycyIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInZhbGlkYXRlQ2FwcyIsImNhcHMiLCJjb25zdHJhaW50cyIsIm9wdHMiLCJza2lwUHJlc2VuY2VDb25zdHJhaW50IiwiaXNQbGFpbk9iamVjdCIsImNsb25lRGVlcCIsImtleXMiLCJrZXkiLCJwcmVzZW5jZSIsInZhbGlkYXRpb25FcnJvcnMiLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0ZSIsInBpY2tCeSIsInV0aWwiLCJoYXNWYWx1ZSIsImZ1bGxNZXNzYWdlcyIsIm1lc3NhZ2UiLCJhdHRyaWJ1dGUiLCJyZWFzb25zIiwicmVhc29uIiwicHVzaCIsImpvaW4iLCJTVEFOREFSRF9DQVBTIiwiaXNTdGFuZGFyZENhcCIsImNhcCIsImZpbmQiLCJzdGFuZGFyZENhcCIsInRvTG93ZXJDYXNlIiwic3RyaXBBcHBpdW1QcmVmaXhlcyIsInByZWZpeCIsInByZWZpeGVkQ2FwcyIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCJiYWRQcmVmaXhlZENhcHMiLCJwcmVmaXhlZENhcCIsInN0cmlwcGVkQ2FwTmFtZSIsInN1YnN0ciIsImxlbmd0aCIsImZpbmROb25QcmVmaXhlZENhcHMiLCJhbHdheXNNYXRjaCIsImZpcnN0TWF0Y2giLCJjaGFpbiIsInJlZHVjZSIsInVucHJlZml4ZWRDYXBzIiwiaW5jbHVkZXMiLCJ1bmlxIiwicGFyc2VDYXBzIiwic2hvdWxkVmFsaWRhdGVDYXBzIiwicmVxdWlyZWRDYXBzIiwiYWxsRmlyc3RNYXRjaENhcHMiLCJpc0FycmF5Iiwibm9uUHJlZml4ZWRDYXBzIiwiaXNFbXB0eSIsImxvZyIsIndhcm4iLCJmaXJzdE1hdGNoQ2FwcyIsImZpbHRlcmVkQ29uc3RyYWludHMiLCJyZXF1aXJlZENhcHNLZXlzIiwidmFsaWRhdGVkRmlyc3RNYXRjaENhcHMiLCJtYXAiLCJlIiwiaXNOdWxsIiwibWF0Y2hlZENhcHMiLCJlcnIiLCJwcm9jZXNzQ2FwYWJpbGl0aWVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUlBLFNBQVNBLFNBQVQsQ0FBb0JDLE9BQU8sR0FBRyxFQUE5QixFQUFrQ0MsU0FBUyxHQUFHLEVBQTlDLEVBQWtEO0FBQ2hELE1BQUlDLE1BQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQkosT0FBbEIsQ0FBYjtBQURnRDtBQUFBO0FBQUE7O0FBQUE7QUFHaEQseUJBQTBCSyxnQkFBRUMsT0FBRixDQUFVTCxTQUFWLENBQTFCLDhIQUFnRDtBQUFBO0FBQUEsVUFBdENNLElBQXNDO0FBQUEsVUFBaENDLEtBQWdDOztBQUU5QyxVQUFJLENBQUNILGdCQUFFSSxXQUFGLENBQWNULE9BQU8sQ0FBQ08sSUFBRCxDQUFyQixDQUFMLEVBQW1DO0FBQ2pDLGNBQU0sSUFBSUcsZUFBT0Msb0JBQVgsQ0FBaUMsYUFBWUosSUFBSyx1Q0FBc0NLLElBQUksQ0FBQ0MsU0FBTCxDQUFlYixPQUFmLENBQXdCLG9CQUFtQlksSUFBSSxDQUFDQyxTQUFMLENBQWVaLFNBQWYsQ0FBMEIsVUFBN0osQ0FBTjtBQUNEOztBQUNEQyxNQUFBQSxNQUFNLENBQUNLLElBQUQsQ0FBTixHQUFlQyxLQUFmO0FBQ0Q7QUFUK0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFXaEQsU0FBT04sTUFBUDtBQUNEOztBQUdELFNBQVNZLFlBQVQsQ0FBdUJDLElBQXZCLEVBQTZCQyxXQUFXLEdBQUcsRUFBM0MsRUFBK0NDLElBQUksR0FBRyxFQUF0RCxFQUEw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QWVFLElBQWYsQ0FBcUIsT0FBTVMsZ0JBQWdCLENBQUNZLElBQWpCLENBQXNCLElBQXRCLENBQTRCLEVBQXBJLENBQU47QUFDRCxLQUhELE1BR087QUFFTCxZQUFNLElBQUkxQixlQUFPQyxvQkFBWCxDQUFnQ2EsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoRCxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPcUQsV0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHZhbGlkYXRvciB9IGZyb20gJy4vZGVzaXJlZC1jYXBzJztcbmltcG9ydCB7IHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IGVycm9ycyB9IGZyb20gJy4uL3Byb3RvY29sL2Vycm9ycyc7XG5cbi8vIFRha2VzIHByaW1hcnkgY2FwcyBvYmplY3QgYW5kIG1lcmdlcyBpdCBpbnRvIGEgc2Vjb25kYXJ5IGNhcHMgb2JqZWN0LlxuLy8gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNkZm4tbWVyZ2luZy1jYXBhYmlsaXRpZXMpXG5mdW5jdGlvbiBtZXJnZUNhcHMgKHByaW1hcnkgPSB7fSwgc2Vjb25kYXJ5ID0ge30pIHtcbiAgbGV0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHByaW1hcnkpO1xuXG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgXy50b1BhaXJzKHNlY29uZGFyeSkpIHtcbiAgICAvLyBPdmVyd3JpdGluZyBpcyBub3QgYWxsb3dlZC4gUHJpbWFyeSBhbmQgc2Vjb25kYXJ5IG11c3QgaGF2ZSBkaWZmZXJlbnQgcHJvcGVydGllcyAodzNjIHJ1bGUgNC40KVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmltYXJ5W25hbWVdKSkge1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRFcnJvcihgcHJvcGVydHkgJyR7bmFtZX0nIHNob3VsZCBub3QgZXhpc3Qgb24gYm90aCBwcmltYXJ5ICgke0pTT04uc3RyaW5naWZ5KHByaW1hcnkpfSkgYW5kIHNlY29uZGFyeSAoJHtKU09OLnN0cmluZ2lmeShzZWNvbmRhcnkpfSkgb2JqZWN0YCk7XG4gICAgfVxuICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gVmFsaWRhdGVzIGNhcHMgYWdhaW5zdCBhIHNldCBvZiBjb25zdHJhaW50c1xuZnVuY3Rpb24gdmFsaWRhdGVDYXBzIChjYXBzLCBjb25zdHJhaW50cyA9IHt9LCBvcHRzID0ge30pIHtcblxuICBsZXQge3NraXBQcmVzZW5jZUNvbnN0cmFpbnR9ID0gb3B0cztcblxuICBpZiAoIV8uaXNQbGFpbk9iamVjdChjYXBzKSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IoYG11c3QgYmUgYSBKU09OIG9iamVjdGApO1xuICB9XG5cbiAgY29uc3RyYWludHMgPSBfLmNsb25lRGVlcChjb25zdHJhaW50cyk7IC8vIERlZmVuc2l2ZSBjb3B5XG5cbiAgaWYgKHNraXBQcmVzZW5jZUNvbnN0cmFpbnQpIHtcbiAgICAvLyBSZW1vdmUgdGhlICdwcmVzZW5jZScgY29uc3RyYWludCBpZiB3ZSdyZSBub3QgY2hlY2tpbmcgZm9yIGl0XG4gICAgZm9yIChsZXQga2V5IG9mIF8ua2V5cyhjb25zdHJhaW50cykpIHtcbiAgICAgIGRlbGV0ZSBjb25zdHJhaW50c1trZXldLnByZXNlbmNlO1xuICAgIH1cbiAgfVxuXG4gIGxldCB2YWxpZGF0aW9uRXJyb3JzID0gdmFsaWRhdG9yLnZhbGlkYXRlKF8ucGlja0J5KGNhcHMsIHV0aWwuaGFzVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdWxsTWVzc2FnZXM6IGZhbHNlfSk7XG5cbiAgaWYgKHZhbGlkYXRpb25FcnJvcnMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFtdO1xuICAgIGZvciAobGV0IFthdHRyaWJ1dGUsIHJlYXNvbnNdIG9mIF8udG9QYWlycyh2YWxpZGF0aW9uRXJyb3JzKSkge1xuICAgICAgZm9yIChsZXQgcmVhc29uIG9mIHJlYXNvbnMpIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGAnJHthdHRyaWJ1dGV9JyAke3JlYXNvbn1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRFcnJvcihtZXNzYWdlLmpvaW4oJzsgJykpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGNhcHNcbiAgcmV0dXJuIGNhcHM7XG59XG5cbi8vIFN0YW5kYXJkLCBub24tcHJlZml4ZWQgY2FwYWJpbGl0aWVzIChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlci8jZGZuLXRhYmxlLW9mLXN0YW5kYXJkLWNhcGFiaWxpdGllcylcbmNvbnN0IFNUQU5EQVJEX0NBUFMgPSBbXG4gICdicm93c2VyTmFtZScsXG4gICdicm93c2VyVmVyc2lvbicsXG4gICdwbGF0Zm9ybU5hbWUnLFxuICAnYWNjZXB0SW5zZWN1cmVDZXJ0cycsXG4gICdwYWdlTG9hZFN0cmF0ZWd5JyxcbiAgJ3Byb3h5JyxcbiAgJ3NldFdpbmRvd1JlY3QnLFxuICAndGltZW91dHMnLFxuICAndW5oYW5kbGVkUHJvbXB0QmVoYXZpb3InXG5dO1xuXG5mdW5jdGlvbiBpc1N0YW5kYXJkQ2FwIChjYXApIHtcbiAgcmV0dXJuICEhXy5maW5kKFNUQU5EQVJEX0NBUFMsIChzdGFuZGFyZENhcCkgPT4gc3RhbmRhcmRDYXAudG9Mb3dlckNhc2UoKSA9PT0gYCR7Y2FwfWAudG9Mb3dlckNhc2UoKSk7XG59XG5cbi8vIElmIHRoZSAnYXBwaXVtOicgcHJlZml4IHdhcyBwcm92aWRlZCBhbmQgaXQncyBhIHZhbGlkIGNhcGFiaWxpdHksIHN0cmlwIG91dCB0aGUgcHJlZml4IChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlci8jZGZuLWV4dGVuc2lvbi1jYXBhYmlsaXRpZXMpXG4vLyAoTk9URTogTWV0aG9kIGlzIGRlc3RydWN0aXZlIGFuZCBtdXRhdGVzIGNvbnRlbnRzIG9mIGNhcHMpXG5mdW5jdGlvbiBzdHJpcEFwcGl1bVByZWZpeGVzIChjYXBzKSB7XG4gIGNvbnN0IHByZWZpeCA9ICdhcHBpdW06JztcbiAgY29uc3QgcHJlZml4ZWRDYXBzID0gXy5maWx0ZXIoXy5rZXlzKGNhcHMpLCBjYXAgPT4gYCR7Y2FwfWAuc3RhcnRzV2l0aChwcmVmaXgpKTtcbiAgY29uc3QgYmFkUHJlZml4ZWRDYXBzID0gW107XG5cbiAgLy8gU3RyaXAgb3V0IHRoZSAnYXBwaXVtOicgcHJlZml4XG4gIGZvciAobGV0IHByZWZpeGVkQ2FwIG9mIHByZWZpeGVkQ2Fwcykge1xuICAgIGNvbnN0IHN0cmlwcGVkQ2FwTmFtZSA9IHByZWZpeGVkQ2FwLnN1YnN0cihwcmVmaXgubGVuZ3RoKTtcblxuICAgIC8vIElmIGl0J3Mgc3RhbmRhcmQgY2FwYWJpbGl0eSB0aGF0IHdhcyBwcmVmaXhlZCwgYWRkIGl0IHRvIGFuIGFycmF5IG9mIGluY29ycmVjdGx5IHByZWZpeGVkIGNhcGFiaWxpdGllc1xuICAgIGlmIChpc1N0YW5kYXJkQ2FwKHN0cmlwcGVkQ2FwTmFtZSkpIHtcbiAgICAgIGJhZFByZWZpeGVkQ2Fwcy5wdXNoKHN0cmlwcGVkQ2FwTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgb3V0IHRoZSBwcmVmaXhcbiAgICBjYXBzW3N0cmlwcGVkQ2FwTmFtZV0gPSBjYXBzW3ByZWZpeGVkQ2FwXTtcbiAgICBkZWxldGUgY2Fwc1twcmVmaXhlZENhcF07XG4gIH1cblxuICAvLyBJZiB3ZSBmb3VuZCBzdGFuZGFyZCBjYXBzIHRoYXQgd2VyZSBpbmNvcnJlY3RseSBwcmVmaXhlZCwgdGhyb3cgYW4gZXhjZXB0aW9uIChlLmcuOiBkb24ndCBhY2NlcHQgJ2FwcGl1bTpwbGF0Zm9ybU5hbWUnLCBvbmx5IGFjY2VwdCBqdXN0ICdwbGF0Zm9ybU5hbWUnKVxuICBpZiAoYmFkUHJlZml4ZWRDYXBzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudEVycm9yKGBUaGUgY2FwYWJpbGl0aWVzICR7SlNPTi5zdHJpbmdpZnkoYmFkUHJlZml4ZWRDYXBzKX0gYXJlIHN0YW5kYXJkIGNhcGFiaWxpdGllcyBhbmQgc2hvdWxkIG5vdCBoYXZlIHRoZSBcImFwcGl1bTpcIiBwcmVmaXhgKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBhbGwgdGhlIHVucHJlZml4ZWQgY2FwcyB0aGF0IGFyZSBiZWluZyB1c2VkIGluICdhbHdheXNNYXRjaCcgYW5kIGFsbCBvZiB0aGUgJ2ZpcnN0TWF0Y2gnIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGNhcHMgQSBjYXBhYmlsaXRpZXMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZpbmROb25QcmVmaXhlZENhcHMgKHthbHdheXNNYXRjaCA9IHt9LCBmaXJzdE1hdGNoID0gW119KSB7XG4gIHJldHVybiBfLmNoYWluKFthbHdheXNNYXRjaCwgLi4uZmlyc3RNYXRjaF0pXG4gICAgLnJlZHVjZSgodW5wcmVmaXhlZENhcHMsIGNhcHMpID0+IFtcbiAgICAgIC4uLnVucHJlZml4ZWRDYXBzLFxuICAgICAgLi4uXyhjYXBzKS5rZXlzKCkuZmlsdGVyKChjYXApID0+ICFjYXAuaW5jbHVkZXMoJzonKSAmJiAhaXNTdGFuZGFyZENhcChjYXApKSxcbiAgICBdLCBbXSlcbiAgICAudW5pcSgpXG4gICAgLnZhbHVlKCk7XG59XG5cbi8vIFBhcnNlIGNhcGFiaWxpdGllcyAoYmFzZWQgb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlci8jcHJvY2Vzc2luZy1jYXBhYmlsaXRpZXMpXG5mdW5jdGlvbiBwYXJzZUNhcHMgKGNhcHMsIGNvbnN0cmFpbnRzID0ge30sIHNob3VsZFZhbGlkYXRlQ2FwcyA9IHRydWUpIHtcbiAgLy8gSWYgY2FwYWJpbGl0aWVzIHJlcXVlc3QgaXMgbm90IGFuIG9iamVjdCwgcmV0dXJuIGVycm9yICgjMS4xKVxuICBpZiAoIV8uaXNQbGFpbk9iamVjdChjYXBzKSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1RoZSBjYXBhYmlsaXRpZXMgYXJndW1lbnQgd2FzIG5vdCB2YWxpZCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb24ocyk6IFwiY2FwYWJpbGl0aWVzXCIgbXVzdCBiZSBhIEpTT04gb2JqZWN0LicpO1xuICB9XG5cbiAgLy8gTGV0ICdyZXF1aXJlZENhcHMnIGJlIHByb3BlcnR5IG5hbWVkICdhbHdheXNNYXRjaCcgZnJvbSBjYXBhYmlsaXRpZXMgcmVxdWVzdCAoIzIpIGFuZCAnYWxsRmlyc3RNYXRjaENhcHMnIGJlIHByb3BlcnR5IG5hbWVkICdmaXJzdE1hdGNoIGZyb20gY2FwYWJpbGl0aWVzIHJlcXVlc3QgKCMzKVxuICBsZXQge1xuICAgIGFsd2F5c01hdGNoOiByZXF1aXJlZENhcHMgPSB7fSwgLy8gSWYgJ3JlcXVpcmVkQ2FwcycgaXMgdW5kZWZpbmVkLCBzZXQgaXQgdG8gYW4gZW1wdHkgSlNPTiBvYmplY3QgKCMyLjEpXG4gICAgZmlyc3RNYXRjaDogYWxsRmlyc3RNYXRjaENhcHMgPSBbe31dLCAvLyBJZiAnZmlyc3RNYXRjaCcgaXMgdW5kZWZpbmVkIHNldCBpdCB0byBhIHNpbmdsZXRvbiBsaXN0IHdpdGggb25lIGVtcHR5IG9iamVjdCAoIzMuMSlcbiAgfSA9IGNhcHM7XG5cbiAgLy8gUmVqZWN0ICdmaXJzdE1hdGNoJyBhcmd1bWVudCBpZiBpdCdzIG5vdCBhbiBhcnJheSAoIzMuMilcbiAgaWYgKCFfLmlzQXJyYXkoYWxsRmlyc3RNYXRjaENhcHMpKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRFcnJvcignVGhlIGNhcGFiaWxpdGllcy5maXJzdE1hdGNoIGFyZ3VtZW50IHdhcyBub3QgdmFsaWQgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uKHMpOiBcImNhcGFiaWxpdGllcy5maXJzdE1hdGNoXCIgbXVzdCBiZSBhIEpTT04gYXJyYXkgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICAvLyBJZiBhbiBlbXB0eSBhcnJheSBhcyBwcm92aWRlZCwgd2UnbGwgYmUgZm9yZ2l2aW5nIGFuZCBtYWtlIGl0IGFuIGFycmF5IG9mIG9uZSBlbXB0eSBvYmplY3RcbiAgaWYgKGFsbEZpcnN0TWF0Y2hDYXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbEZpcnN0TWF0Y2hDYXBzLnB1c2goe30pO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG5vbi1wcmVmaXhlZCwgbm9uLXN0YW5kYXJkIGNhcGFiaWxpdGllcyBhbmQgbG9nIHdhcm5pbmdzIGlmIHRoZXkgYXJlIGZvdW5kXG4gIGxldCBub25QcmVmaXhlZENhcHMgPSBmaW5kTm9uUHJlZml4ZWRDYXBzKGNhcHMpO1xuICBpZiAoIV8uaXNFbXB0eShub25QcmVmaXhlZENhcHMpKSB7XG4gICAgbG9nLndhcm4oYFRoZSBjYXBhYmlsaXRpZXMgJHtKU09OLnN0cmluZ2lmeShub25QcmVmaXhlZENhcHMpfSBhcmUgbm90IHN0YW5kYXJkIGNhcGFiaWxpdGllcyBhbmQgc2hvdWxkIGhhdmUgYW4gZXh0ZW5zaW9uIHByZWZpeGApO1xuICB9XG5cbiAgLy8gU3RyaXAgb3V0IHRoZSAnYXBwaXVtOicgcHJlZml4IGZyb20gYWxsXG4gIHN0cmlwQXBwaXVtUHJlZml4ZXMocmVxdWlyZWRDYXBzKTtcbiAgZm9yIChsZXQgZmlyc3RNYXRjaENhcHMgb2YgYWxsRmlyc3RNYXRjaENhcHMpIHtcbiAgICBzdHJpcEFwcGl1bVByZWZpeGVzKGZpcnN0TWF0Y2hDYXBzKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHRoZSByZXF1aXJlZENhcHMuIEJ1dCBkb24ndCB2YWxpZGF0ZSAncHJlc2VuY2UnIGJlY2F1c2UgaWYgdGhhdCBjb25zdHJhaW50IGZhaWxzIG9uICdhbHdheXNNYXRjaCcgaXQgY291bGQgc3RpbGwgcGFzcyBvbiBvbmUgb2YgdGhlICdmaXJzdE1hdGNoJyBrZXlzXG4gIGlmIChzaG91bGRWYWxpZGF0ZUNhcHMpIHtcbiAgICByZXF1aXJlZENhcHMgPSB2YWxpZGF0ZUNhcHMocmVxdWlyZWRDYXBzLCBjb25zdHJhaW50cywge3NraXBQcmVzZW5jZUNvbnN0cmFpbnQ6IHRydWV9KTtcbiAgfVxuXG5cbiAgLy8gUmVtb3ZlIHRoZSAncHJlc2VuY2UnIGNvbnN0cmFpbnQgZm9yIGFueSBrZXlzIHRoYXQgYXJlIGFscmVhZHkgcHJlc2VudCBpbiAncmVxdWlyZWRDYXBzJ1xuICAvLyBzaW5jZSB3ZSBrbm93IHRoYXQgdGhpcyBjb25zdHJhaW50IGhhcyBhbHJlYWR5IHBhc3NlZFxuICBsZXQgZmlsdGVyZWRDb25zdHJhaW50cyA9IHsuLi5jb25zdHJhaW50c307XG4gIGxldCByZXF1aXJlZENhcHNLZXlzID0gXy5rZXlzKHJlcXVpcmVkQ2Fwcyk7XG4gIGZvciAobGV0IGtleSBvZiBfLmtleXMoZmlsdGVyZWRDb25zdHJhaW50cykpIHtcbiAgICBpZiAocmVxdWlyZWRDYXBzS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBkZWxldGUgZmlsdGVyZWRDb25zdHJhaW50c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGFsbCBvZiB0aGUgZmlyc3QgbWF0Y2ggY2FwYWJpbGl0aWVzIGFuZCByZXR1cm4gYW4gYXJyYXkgd2l0aCBvbmx5IHRoZSB2YWxpZCBjYXBzIChzZWUgc3BlYyAjNSlcbiAgbGV0IHZhbGlkYXRpb25FcnJvcnMgPSBbXTtcbiAgbGV0IHZhbGlkYXRlZEZpcnN0TWF0Y2hDYXBzID0gYWxsRmlyc3RNYXRjaENhcHMubWFwKChmaXJzdE1hdGNoQ2FwcykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGF0ZSBmaXJzdE1hdGNoIGNhcHNcbiAgICAgIHJldHVybiBzaG91bGRWYWxpZGF0ZUNhcHMgPyB2YWxpZGF0ZUNhcHMoZmlyc3RNYXRjaENhcHMsIGZpbHRlcmVkQ29uc3RyYWludHMpIDogZmlyc3RNYXRjaENhcHM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGUubWVzc2FnZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0pLmZpbHRlcigoY2FwcykgPT4gIV8uaXNOdWxsKGNhcHMpKTtcblxuICAvLyBUcnkgdG8gbWVyZ2UgcmVxdWlyZWRDYXBzIHdpdGggZmlyc3QgbWF0Y2ggY2FwYWJpbGl0aWVzLCBicmVhayBvbmNlIGl0IGZpbmRzIGl0cyBmaXJzdCBtYXRjaCAoc2VlIHNwZWMgIzYpXG4gIGxldCBtYXRjaGVkQ2FwcyA9IG51bGw7XG4gIGZvciAobGV0IGZpcnN0TWF0Y2hDYXBzIG9mIHZhbGlkYXRlZEZpcnN0TWF0Y2hDYXBzKSB7XG4gICAgdHJ5IHtcbiAgICAgIG1hdGNoZWRDYXBzID0gbWVyZ2VDYXBzKHJlcXVpcmVkQ2FwcywgZmlyc3RNYXRjaENhcHMpO1xuICAgICAgaWYgKG1hdGNoZWRDYXBzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgdmFyaWFibGVzIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gIHJldHVybiB7cmVxdWlyZWRDYXBzLCBhbGxGaXJzdE1hdGNoQ2FwcywgdmFsaWRhdGVkRmlyc3RNYXRjaENhcHMsIG1hdGNoZWRDYXBzLCB2YWxpZGF0aW9uRXJyb3JzfTtcbn1cblxuLy8gQ2FsbHMgcGFyc2VDYXBzIGFuZCBqdXN0IHJldHVybnMgdGhlIG1hdGNoZWRDYXBzIHZhcmlhYmxlXG5mdW5jdGlvbiBwcm9jZXNzQ2FwYWJpbGl0aWVzIChjYXBzLCBjb25zdHJhaW50cyA9IHt9LCBzaG91bGRWYWxpZGF0ZUNhcHMgPSB0cnVlKSB7XG4gIGNvbnN0IHttYXRjaGVkQ2FwcywgdmFsaWRhdGlvbkVycm9yc30gPSBwYXJzZUNhcHMoY2FwcywgY29uc3RyYWludHMsIHNob3VsZFZhbGlkYXRlQ2Fwcyk7XG5cbiAgLy8gSWYgd2UgZm91bmQgYW4gZXJyb3IgdGhyb3cgYW4gZXhjZXB0aW9uXG4gIGlmICghdXRpbC5oYXNWYWx1ZShtYXRjaGVkQ2FwcykpIHtcbiAgICBpZiAoXy5pc0FycmF5KGNhcHMuZmlyc3RNYXRjaCkgJiYgY2Fwcy5maXJzdE1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBtb3JlIHRoYW4gb25lICdmaXJzdE1hdGNoJyBjYXAsIGluZGljYXRlIHRoYXQgd2UgY291bGRuJ3QgZmluZCBhIG1hdGNoaW5nIGNhcGFiaWxpdGllcyBzZXQgYW5kIHNob3cgYWxsIHRoZSBlcnJvcnNcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IoYENvdWxkIG5vdCBmaW5kIG1hdGNoaW5nIGNhcGFiaWxpdGllcyBmcm9tICR7SlNPTi5zdHJpbmdpZnkoY2Fwcyl9OlxcbiAke3ZhbGlkYXRpb25FcnJvcnMuam9pbignXFxuJyl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCBzaG93IHRoZSBzaW5ndWxhciBlcnJvciBtZXNzYWdlXG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudEVycm9yKHZhbGlkYXRpb25FcnJvcnNbMF0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVkQ2Fwcztcbn1cblxuXG5leHBvcnQgeyBwYXJzZUNhcHMsIHByb2Nlc3NDYXBhYmlsaXRpZXMsIHZhbGlkYXRlQ2FwcywgbWVyZ2VDYXBzLCBmaW5kTm9uUHJlZml4ZWRDYXBzIH07XG4iXSwiZmlsZSI6ImxpYi9iYXNlZHJpdmVyL2NhcGFiaWxpdGllcy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
