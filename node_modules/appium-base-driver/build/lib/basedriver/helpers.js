"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureApp = configureApp;
exports.isPackageOrBundle = isPackageOrBundle;
exports.getCoordDefault = getCoordDefault;
exports.getSwipeTouchDuration = getSwipeTouchDuration;
exports.renameKey = renameKey;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _logger = _interopRequireDefault(require("./logger"));

var _fs2 = _interopRequireDefault(require("fs"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _request = _interopRequireDefault(require("request"));

var _requestPromise = _interopRequireDefault(require("request-promise"));

var _lruCache = _interopRequireDefault(require("lru-cache"));

var _asyncLock = _interopRequireDefault(require("async-lock"));

var _sanitizeFilename = _interopRequireDefault(require("sanitize-filename"));

const ZIP_EXTS = ['.zip', '.ipa'];
const ZIP_MIME_TYPES = ['application/zip', 'application/x-zip-compressed', 'multipart/x-zip'];
const APPLICATIONS_CACHE = new _lruCache.default({
  max: 100
});
const APPLICATIONS_CACHE_GUARD = new _asyncLock.default();

function retrieveHeaders(_x) {
  return _retrieveHeaders.apply(this, arguments);
}

function _retrieveHeaders() {
  _retrieveHeaders = (0, _asyncToGenerator2.default)(function* (link) {
    try {
      const response = yield (0, _requestPromise.default)({
        url: link,
        method: 'HEAD',
        resolveWithFullResponse: true,
        timeout: 5000
      });
      return response.headers;
    } catch (e) {
      _logger.default.debug(`Cannot send HEAD request to '${link}'. Original error: ${e.message}`);
    }

    return {};
  });
  return _retrieveHeaders.apply(this, arguments);
}

function getCachedApplicationPath(link, currentModified) {
  if (!APPLICATIONS_CACHE.has(link) || !currentModified) {
    return null;
  }

  const _APPLICATIONS_CACHE$g = APPLICATIONS_CACHE.get(link),
        lastModified = _APPLICATIONS_CACHE$g.lastModified,
        fullPath = _APPLICATIONS_CACHE$g.fullPath;

  if (lastModified && currentModified.getTime() <= lastModified.getTime()) {
    _logger.default.debug(`Reusing already downloaded application at '${fullPath}'`);

    return fullPath;
  }

  _logger.default.debug(`'Last-Modified' timestamp of '${link}' has been updated. ` + `An updated copy of the application is going to be downloaded.`);

  return null;
}

function verifyAppExtension(app, supportedAppExtensions) {
  if (supportedAppExtensions.includes(_path.default.extname(app))) {
    return app;
  }

  throw new Error(`New app path '${app}' did not have extension(s) '${supportedAppExtensions}'`);
}

function configureApp(_x2, _x3) {
  return _configureApp.apply(this, arguments);
}

function _configureApp() {
  _configureApp = (0, _asyncToGenerator2.default)(function* (app, supportedAppExtensions) {
    if (!_lodash.default.isString(app)) {
      return;
    }

    if (!_lodash.default.isArray(supportedAppExtensions)) {
      supportedAppExtensions = [supportedAppExtensions];
    }

    let newApp = app;
    let shouldUnzipApp = false;
    let archiveHash = null;
    let currentModified = null;

    const _url$parse = _url.default.parse(newApp),
          protocol = _url$parse.protocol;

    const isUrl = ['http:', 'https:'].includes(protocol);
    return yield APPLICATIONS_CACHE_GUARD.acquire(app, (0, _asyncToGenerator2.default)(function* () {
      if (isUrl) {
        _logger.default.info(`Using downloadable app '${newApp}'`);

        const headers = yield retrieveHeaders(newApp);

        if (headers['last-modified']) {
          _logger.default.debug(`Last-Modified: ${headers['last-modified']}`);

          currentModified = new Date(headers['last-modified']);
        }

        const cachedPath = getCachedApplicationPath(app, currentModified);

        if (cachedPath) {
          if (yield _appiumSupport.fs.exists(cachedPath)) {
            _logger.default.info(`Reusing the previously downloaded application at '${cachedPath}'`);

            return verifyAppExtension(cachedPath, supportedAppExtensions);
          }

          _logger.default.info(`The application at '${cachedPath}' does not exist anymore. Deleting it from the cache`);

          APPLICATIONS_CACHE.del(app);
        }

        let fileName = `appium-app${_lodash.default.first(supportedAppExtensions)}`;
        const downloadZipName = 'appium-app.zip';

        if (headers['content-type']) {
          _logger.default.debug(`Content-Type: ${headers['content-type']}`);

          if (ZIP_MIME_TYPES.includes(headers['content-type'])) {
            fileName = downloadZipName;
            shouldUnzipApp = true;
          }
        } else if (ZIP_EXTS.includes(_path.default.extname(newApp))) {
          fileName = downloadZipName;
          shouldUnzipApp = true;
        }

        if (headers['content-disposition'] && /^attachment/i.test(headers['content-disposition'])) {
          const match = /filename="([^"]+)/i.exec(headers['content-disposition']);

          if (match) {
            _logger.default.debug(`Parsed file name '${match[1]}' from 'Content-Disposition' header`);

            fileName = (0, _sanitizeFilename.default)(match[1], {
              replacement: '-'
            });
            shouldUnzipApp = shouldUnzipApp || ZIP_EXTS.includes(_path.default.extname(fileName));
          }
        }

        const targetPath = yield _appiumSupport.tempDir.path({
          prefix: fileName,
          suffix: ''
        });
        newApp = yield downloadApp(newApp, targetPath);
      } else if (yield _appiumSupport.fs.exists(newApp)) {
        _logger.default.info(`Using local app '${newApp}'`);

        shouldUnzipApp = ZIP_EXTS.includes(_path.default.extname(newApp));
      } else {
        let errorMessage = `The application at '${newApp}' does not exist or is not accessible`;

        if (_lodash.default.isString(protocol) && protocol.length > 2) {
          errorMessage = `The protocol '${protocol}' used in '${newApp}' is not supported. ` + `Only http: and https: protocols are supported`;
        }

        throw new Error(errorMessage);
      }

      if (shouldUnzipApp) {
        const archivePath = newApp;
        archiveHash = yield _appiumSupport.fs.hash(archivePath);

        if (APPLICATIONS_CACHE.has(app) && archiveHash === APPLICATIONS_CACHE.get(app).hash) {
          const _APPLICATIONS_CACHE$g2 = APPLICATIONS_CACHE.get(app),
                fullPath = _APPLICATIONS_CACHE$g2.fullPath;

          if (yield _appiumSupport.fs.exists(fullPath)) {
            if (archivePath !== app) {
              yield _appiumSupport.fs.rimraf(archivePath);
            }

            _logger.default.info(`Will reuse previously cached application at '${fullPath}'`);

            return verifyAppExtension(fullPath, supportedAppExtensions);
          }

          _logger.default.info(`The application at '${fullPath}' does not exist anymore. Deleting it from the cache`);

          APPLICATIONS_CACHE.del(app);
        }

        const tmpRoot = yield _appiumSupport.tempDir.openDir();

        try {
          newApp = yield unzipApp(archivePath, tmpRoot, supportedAppExtensions);
        } finally {
          if (newApp !== archivePath && archivePath !== app) {
            yield _appiumSupport.fs.rimraf(archivePath);
          }
        }

        _logger.default.info(`Unzipped local app to '${newApp}'`);
      } else if (!_path.default.isAbsolute(newApp)) {
        newApp = _path.default.resolve(process.cwd(), newApp);

        _logger.default.warn(`The current application path '${app}' is relative, ` + `which might cause further issues. The path has been rewritten to '${newApp}' ` + `in order to avoid them`);
      }

      verifyAppExtension(newApp, supportedAppExtensions);

      if (app !== newApp && (archiveHash || currentModified)) {
        APPLICATIONS_CACHE.set(app, {
          hash: archiveHash,
          lastModified: currentModified,
          fullPath: newApp
        });
      }

      return newApp;
    }));
  });
  return _configureApp.apply(this, arguments);
}

function downloadApp(_x4, _x5) {
  return _downloadApp.apply(this, arguments);
}

function _downloadApp() {
  _downloadApp = (0, _asyncToGenerator2.default)(function* (app, targetPath) {
    let appUrl;

    try {
      appUrl = _url.default.parse(app);
    } catch (err) {
      throw new Error(`Invalid App URL (${app})`);
    }

    try {
      const started = process.hrtime();
      yield new _bluebird.default((resolve, reject) => {
        (0, _request.default)(appUrl.href).on('error', reject).on('response', res => {
          if (res.statusCode >= 400) {
            return reject(`Error downloading file: ${res.statusCode}`);
          }
        }).pipe(_fs2.default.createWriteStream(targetPath)).on('close', resolve);
      });

      const _process$hrtime = process.hrtime(started),
            _process$hrtime2 = (0, _slicedToArray2.default)(_process$hrtime, 2),
            seconds = _process$hrtime2[0],
            ns = _process$hrtime2[1];

      const secondsElapsed = seconds + ns / 1E09;

      const _ref2 = yield _appiumSupport.fs.stat(targetPath),
            size = _ref2.size;

      _logger.default.debug(`'${appUrl.href}' (${_appiumSupport.util.toReadableSizeString(size)}) ` + `has been downloaded to '${targetPath}' in ${secondsElapsed.toFixed(3)}s`);

      if (secondsElapsed >= 2) {
        const bytesPerSec = Math.floor(size / secondsElapsed);

        _logger.default.debug(`Approximate download speed: ${_appiumSupport.util.toReadableSizeString(bytesPerSec)}/s`);
      }

      return targetPath;
    } catch (err) {
      throw new Error(`Problem downloading app from url ${appUrl.href}: ${err.message}`);
    }
  });
  return _downloadApp.apply(this, arguments);
}

function walkDir(_x6) {
  return _walkDir.apply(this, arguments);
}

function _walkDir() {
  _walkDir = (0, _asyncToGenerator2.default)(function* (dir) {
    const result = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (yield _appiumSupport.fs.readdir(dir))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const name = _step.value;

        const currentPath = _path.default.join(dir, name);

        result.push(currentPath);

        if ((yield _appiumSupport.fs.stat(currentPath)).isDirectory()) {
          result.push(...(yield walkDir(currentPath)));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return result;
  });
  return _walkDir.apply(this, arguments);
}

function unzipApp(_x7, _x8, _x9) {
  return _unzipApp.apply(this, arguments);
}

function _unzipApp() {
  _unzipApp = (0, _asyncToGenerator2.default)(function* (zipPath, dstRoot, supportedAppExtensions) {
    yield _appiumSupport.zip.assertValidZip(zipPath);

    if (!_lodash.default.isArray(supportedAppExtensions)) {
      supportedAppExtensions = [supportedAppExtensions];
    }

    const tmpRoot = yield _appiumSupport.tempDir.openDir();

    try {
      _logger.default.debug(`Unzipping '${zipPath}'`);

      yield _appiumSupport.zip.extractAllTo(zipPath, tmpRoot);
      const allExtractedItems = yield walkDir(tmpRoot);

      _logger.default.debug(`Extracted ${allExtractedItems.length} item(s) from '${zipPath}'`);

      const isSupportedAppItem = relativePath => supportedAppExtensions.includes(_path.default.extname(relativePath)) || _lodash.default.some(supportedAppExtensions, x => relativePath.includes(`${x}${_path.default.sep}`));

      const itemsToKeep = allExtractedItems.map(itemPath => _path.default.relative(tmpRoot, itemPath)).filter(relativePath => isSupportedAppItem(relativePath)).map(relativePath => _path.default.resolve(tmpRoot, relativePath));

      const itemsToRemove = _lodash.default.difference(allExtractedItems, itemsToKeep).filter(itemToRemovePath => !_lodash.default.some(itemsToKeep, itemToKeepPath => itemToKeepPath.startsWith(itemToRemovePath)));

      yield _bluebird.default.all(itemsToRemove, function () {
        var _ref3 = (0, _asyncToGenerator2.default)(function* (itemPath) {
          if (yield _appiumSupport.fs.exists(itemPath)) {
            yield _appiumSupport.fs.rimraf(itemPath);
          }
        });

        return function (_x10) {
          return _ref3.apply(this, arguments);
        };
      }());
      const allBundleItems = (yield walkDir(tmpRoot)).map(itemPath => _path.default.relative(tmpRoot, itemPath)).filter(relativePath => isSupportedAppItem(relativePath)).sort((a, b) => a.split(_path.default.sep).length - b.split(_path.default.sep).length);

      if (_lodash.default.isEmpty(allBundleItems)) {
        throw new Error(`App zip unzipped OK, but we could not find ${supportedAppExtensions} bundle(s) ` + `in it. Make sure your archive contains ${supportedAppExtensions} package(s) ` + `and nothing else`);
      }

      const matchedBundle = _lodash.default.first(allBundleItems);

      _logger.default.debug(`Matched ${allBundleItems.length} item(s) in the extracted archive. ` + `Assuming '${matchedBundle}' is the correct bundle`);

      yield _appiumSupport.fs.mv(_path.default.resolve(tmpRoot, matchedBundle), _path.default.resolve(dstRoot, matchedBundle), {
        mkdirp: true
      });
      return _path.default.resolve(dstRoot, matchedBundle);
    } finally {
      yield _appiumSupport.fs.rimraf(tmpRoot);
    }
  });
  return _unzipApp.apply(this, arguments);
}

function isPackageOrBundle(app) {
  return /^([a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)+$/.test(app);
}

function getCoordDefault(val) {
  return _appiumSupport.util.hasValue(val) ? val : 0.5;
}

function getSwipeTouchDuration(waitGesture) {
  let duration = 0.8;

  if (typeof waitGesture.options.ms !== 'undefined' && waitGesture.options.ms) {
    duration = waitGesture.options.ms / 1000;

    if (duration === 0) {
      duration = 0.1;
    }
  }

  return duration;
}

function renameKey(input, inKey, outKey) {
  if (_lodash.default.isArray(input)) {
    return input.map(item => renameKey(item, inKey, outKey));
  } else if (_lodash.default.isPlainObject(input)) {
    return _lodash.default.reduce(input, (resultObj, value, key) => (0, _objectSpread2.default)({}, resultObj, {
      [key === inKey ? outKey : key]: renameKey(value, inKey, outKey)
    }), {});
  }

  return input;
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2hlbHBlcnMuanMiXSwibmFtZXMiOlsiWklQX0VYVFMiLCJaSVBfTUlNRV9UWVBFUyIsIkFQUExJQ0FUSU9OU19DQUNIRSIsIkxSVSIsIm1heCIsIkFQUExJQ0FUSU9OU19DQUNIRV9HVUFSRCIsIkFzeW5jTG9jayIsInJldHJpZXZlSGVhZGVycyIsImxpbmsiLCJyZXNwb25zZSIsInVybCIsIm1ldGhvZCIsInJlc29sdmVXaXRoRnVsbFJlc3BvbnNlIiwidGltZW91dCIsImhlYWRlcnMiLCJlIiwibG9nZ2VyIiwiZGVidWciLCJtZXNzYWdlIiwiZ2V0Q2FjaGVkQXBwbGljYXRpb25QYXRoIiwiY3VycmVudE1vZGlmaWVkIiwiaGFzIiwiZ2V0IiwibGFzdE1vZGlmaWVkIiwiZnVsbFBhdGgiLCJnZXRUaW1lIiwidmVyaWZ5QXBwRXh0ZW5zaW9uIiwiYXBwIiwic3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyIsImluY2x1ZGVzIiwicGF0aCIsImV4dG5hbWUiLCJFcnJvciIsImNvbmZpZ3VyZUFwcCIsIl8iLCJpc1N0cmluZyIsImlzQXJyYXkiLCJuZXdBcHAiLCJzaG91bGRVbnppcEFwcCIsImFyY2hpdmVIYXNoIiwicGFyc2UiLCJwcm90b2NvbCIsImlzVXJsIiwiYWNxdWlyZSIsImluZm8iLCJEYXRlIiwiY2FjaGVkUGF0aCIsImZzIiwiZXhpc3RzIiwiZGVsIiwiZmlsZU5hbWUiLCJmaXJzdCIsImRvd25sb2FkWmlwTmFtZSIsInRlc3QiLCJtYXRjaCIsImV4ZWMiLCJyZXBsYWNlbWVudCIsInRhcmdldFBhdGgiLCJ0ZW1wRGlyIiwicHJlZml4Iiwic3VmZml4IiwiZG93bmxvYWRBcHAiLCJlcnJvck1lc3NhZ2UiLCJsZW5ndGgiLCJhcmNoaXZlUGF0aCIsImhhc2giLCJyaW1yYWYiLCJ0bXBSb290Iiwib3BlbkRpciIsInVuemlwQXBwIiwiaXNBYnNvbHV0ZSIsInJlc29sdmUiLCJwcm9jZXNzIiwiY3dkIiwid2FybiIsInNldCIsImFwcFVybCIsImVyciIsInN0YXJ0ZWQiLCJocnRpbWUiLCJCIiwicmVqZWN0IiwiaHJlZiIsIm9uIiwicmVzIiwic3RhdHVzQ29kZSIsInBpcGUiLCJfZnMiLCJjcmVhdGVXcml0ZVN0cmVhbSIsInNlY29uZHMiLCJucyIsInNlY29uZHNFbGFwc2VkIiwic3RhdCIsInNpemUiLCJ1dGlsIiwidG9SZWFkYWJsZVNpemVTdHJpbmciLCJ0b0ZpeGVkIiwiYnl0ZXNQZXJTZWMiLCJNYXRoIiwiZmxvb3IiLCJ3YWxrRGlyIiwiZGlyIiwicmVzdWx0IiwicmVhZGRpciIsIm5hbWUiLCJjdXJyZW50UGF0aCIsImpvaW4iLCJwdXNoIiwiaXNEaXJlY3RvcnkiLCJ6aXBQYXRoIiwiZHN0Um9vdCIsInppcCIsImFzc2VydFZhbGlkWmlwIiwiZXh0cmFjdEFsbFRvIiwiYWxsRXh0cmFjdGVkSXRlbXMiLCJpc1N1cHBvcnRlZEFwcEl0ZW0iLCJyZWxhdGl2ZVBhdGgiLCJzb21lIiwieCIsInNlcCIsIml0ZW1zVG9LZWVwIiwibWFwIiwiaXRlbVBhdGgiLCJyZWxhdGl2ZSIsImZpbHRlciIsIml0ZW1zVG9SZW1vdmUiLCJkaWZmZXJlbmNlIiwiaXRlbVRvUmVtb3ZlUGF0aCIsIml0ZW1Ub0tlZXBQYXRoIiwic3RhcnRzV2l0aCIsImFsbCIsImFsbEJ1bmRsZUl0ZW1zIiwic29ydCIsImEiLCJiIiwic3BsaXQiLCJpc0VtcHR5IiwibWF0Y2hlZEJ1bmRsZSIsIm12IiwibWtkaXJwIiwiaXNQYWNrYWdlT3JCdW5kbGUiLCJnZXRDb29yZERlZmF1bHQiLCJ2YWwiLCJoYXNWYWx1ZSIsImdldFN3aXBlVG91Y2hEdXJhdGlvbiIsIndhaXRHZXN0dXJlIiwiZHVyYXRpb24iLCJvcHRpb25zIiwibXMiLCJyZW5hbWVLZXkiLCJpbnB1dCIsImluS2V5Iiwib3V0S2V5IiwiaXRlbSIsImlzUGxhaW5PYmplY3QiLCJyZWR1Y2UiLCJyZXN1bHRPYmoiLCJ2YWx1ZSIsImtleSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLFFBQVEsR0FBRyxDQUFDLE1BQUQsRUFBUyxNQUFULENBQWpCO0FBQ0EsTUFBTUMsY0FBYyxHQUFHLENBQ3JCLGlCQURxQixFQUVyQiw4QkFGcUIsRUFHckIsaUJBSHFCLENBQXZCO0FBS0EsTUFBTUMsa0JBQWtCLEdBQUcsSUFBSUMsaUJBQUosQ0FBUTtBQUNqQ0MsRUFBQUEsR0FBRyxFQUFFO0FBRDRCLENBQVIsQ0FBM0I7QUFHQSxNQUFNQyx3QkFBd0IsR0FBRyxJQUFJQyxrQkFBSixFQUFqQzs7U0FFZUMsZTs7Ozs7cURBQWYsV0FBZ0NDLElBQWhDLEVBQXNDO0FBQ3BDLFFBQUk7QUFDRixZQUFNQyxRQUFRLFNBQVMsNkJBQWE7QUFDbENDLFFBQUFBLEdBQUcsRUFBRUYsSUFENkI7QUFFbENHLFFBQUFBLE1BQU0sRUFBRSxNQUYwQjtBQUdsQ0MsUUFBQUEsdUJBQXVCLEVBQUUsSUFIUztBQUlsQ0MsUUFBQUEsT0FBTyxFQUFFO0FBSnlCLE9BQWIsQ0FBdkI7QUFNQSxhQUFPSixRQUFRLENBQUNLLE9BQWhCO0FBQ0QsS0FSRCxDQVFFLE9BQU9DLENBQVAsRUFBVTtBQUNWQyxzQkFBT0MsS0FBUCxDQUFjLGdDQUErQlQsSUFBSyxzQkFBcUJPLENBQUMsQ0FBQ0csT0FBUSxFQUFqRjtBQUNEOztBQUNELFdBQU8sRUFBUDtBQUNELEc7Ozs7QUFFRCxTQUFTQyx3QkFBVCxDQUFtQ1gsSUFBbkMsRUFBeUNZLGVBQXpDLEVBQTBEO0FBQ3hELE1BQUksQ0FBQ2xCLGtCQUFrQixDQUFDbUIsR0FBbkIsQ0FBdUJiLElBQXZCLENBQUQsSUFBaUMsQ0FBQ1ksZUFBdEMsRUFBdUQ7QUFDckQsV0FBTyxJQUFQO0FBQ0Q7O0FBSHVELGdDQUt2QmxCLGtCQUFrQixDQUFDb0IsR0FBbkIsQ0FBdUJkLElBQXZCLENBTHVCO0FBQUEsUUFLakRlLFlBTGlELHlCQUtqREEsWUFMaUQ7QUFBQSxRQUtuQ0MsUUFMbUMseUJBS25DQSxRQUxtQzs7QUFNeEQsTUFBSUQsWUFBWSxJQUFJSCxlQUFlLENBQUNLLE9BQWhCLE1BQTZCRixZQUFZLENBQUNFLE9BQWIsRUFBakQsRUFBeUU7QUFDdkVULG9CQUFPQyxLQUFQLENBQWMsOENBQTZDTyxRQUFTLEdBQXBFOztBQUNBLFdBQU9BLFFBQVA7QUFDRDs7QUFDRFIsa0JBQU9DLEtBQVAsQ0FBYyxpQ0FBZ0NULElBQUssc0JBQXRDLEdBQ1YsK0RBREg7O0FBRUEsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBU2tCLGtCQUFULENBQTZCQyxHQUE3QixFQUFrQ0Msc0JBQWxDLEVBQTBEO0FBQ3hELE1BQUlBLHNCQUFzQixDQUFDQyxRQUF2QixDQUFnQ0MsY0FBS0MsT0FBTCxDQUFhSixHQUFiLENBQWhDLENBQUosRUFBd0Q7QUFDdEQsV0FBT0EsR0FBUDtBQUNEOztBQUNELFFBQU0sSUFBSUssS0FBSixDQUFXLGlCQUFnQkwsR0FBSSxnQ0FBK0JDLHNCQUF1QixHQUFyRixDQUFOO0FBQ0Q7O1NBRWNLLFk7Ozs7O2tEQUFmLFdBQTZCTixHQUE3QixFQUFrQ0Msc0JBQWxDLEVBQTBEO0FBQ3hELFFBQUksQ0FBQ00sZ0JBQUVDLFFBQUYsQ0FBV1IsR0FBWCxDQUFMLEVBQXNCO0FBRXBCO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDTyxnQkFBRUUsT0FBRixDQUFVUixzQkFBVixDQUFMLEVBQXdDO0FBQ3RDQSxNQUFBQSxzQkFBc0IsR0FBRyxDQUFDQSxzQkFBRCxDQUF6QjtBQUNEOztBQUVELFFBQUlTLE1BQU0sR0FBR1YsR0FBYjtBQUNBLFFBQUlXLGNBQWMsR0FBRyxLQUFyQjtBQUNBLFFBQUlDLFdBQVcsR0FBRyxJQUFsQjtBQUNBLFFBQUluQixlQUFlLEdBQUcsSUFBdEI7O0FBWndELHVCQWFyQ1YsYUFBSThCLEtBQUosQ0FBVUgsTUFBVixDQWJxQztBQUFBLFVBYWpESSxRQWJpRCxjQWFqREEsUUFiaUQ7O0FBY3hELFVBQU1DLEtBQUssR0FBRyxDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CYixRQUFwQixDQUE2QlksUUFBN0IsQ0FBZDtBQUVBLGlCQUFhcEMsd0JBQXdCLENBQUNzQyxPQUF6QixDQUFpQ2hCLEdBQWpDLGtDQUFzQyxhQUFZO0FBQzdELFVBQUllLEtBQUosRUFBVztBQUVUMUIsd0JBQU80QixJQUFQLENBQWEsMkJBQTBCUCxNQUFPLEdBQTlDOztBQUNBLGNBQU12QixPQUFPLFNBQVNQLGVBQWUsQ0FBQzhCLE1BQUQsQ0FBckM7O0FBQ0EsWUFBSXZCLE9BQU8sQ0FBQyxlQUFELENBQVgsRUFBOEI7QUFDNUJFLDBCQUFPQyxLQUFQLENBQWMsa0JBQWlCSCxPQUFPLENBQUMsZUFBRCxDQUFrQixFQUF4RDs7QUFDQU0sVUFBQUEsZUFBZSxHQUFHLElBQUl5QixJQUFKLENBQVMvQixPQUFPLENBQUMsZUFBRCxDQUFoQixDQUFsQjtBQUNEOztBQUNELGNBQU1nQyxVQUFVLEdBQUczQix3QkFBd0IsQ0FBQ1EsR0FBRCxFQUFNUCxlQUFOLENBQTNDOztBQUNBLFlBQUkwQixVQUFKLEVBQWdCO0FBQ2Qsb0JBQVVDLGtCQUFHQyxNQUFILENBQVVGLFVBQVYsQ0FBVixFQUFpQztBQUMvQjlCLDRCQUFPNEIsSUFBUCxDQUFhLHFEQUFvREUsVUFBVyxHQUE1RTs7QUFDQSxtQkFBT3BCLGtCQUFrQixDQUFDb0IsVUFBRCxFQUFhbEIsc0JBQWIsQ0FBekI7QUFDRDs7QUFDRFosMEJBQU80QixJQUFQLENBQWEsdUJBQXNCRSxVQUFXLHNEQUE5Qzs7QUFDQTVDLFVBQUFBLGtCQUFrQixDQUFDK0MsR0FBbkIsQ0FBdUJ0QixHQUF2QjtBQUNEOztBQUNELFlBQUl1QixRQUFRLEdBQUksYUFBWWhCLGdCQUFFaUIsS0FBRixDQUFRdkIsc0JBQVIsQ0FBZ0MsRUFBNUQ7QUFJQSxjQUFNd0IsZUFBZSxHQUFHLGdCQUF4Qjs7QUFDQSxZQUFJdEMsT0FBTyxDQUFDLGNBQUQsQ0FBWCxFQUE2QjtBQUMzQkUsMEJBQU9DLEtBQVAsQ0FBYyxpQkFBZ0JILE9BQU8sQ0FBQyxjQUFELENBQWlCLEVBQXREOztBQUVBLGNBQUliLGNBQWMsQ0FBQzRCLFFBQWYsQ0FBd0JmLE9BQU8sQ0FBQyxjQUFELENBQS9CLENBQUosRUFBc0Q7QUFDcERvQyxZQUFBQSxRQUFRLEdBQUdFLGVBQVg7QUFDQWQsWUFBQUEsY0FBYyxHQUFHLElBQWpCO0FBQ0Q7QUFDRixTQVBELE1BT08sSUFBSXRDLFFBQVEsQ0FBQzZCLFFBQVQsQ0FBa0JDLGNBQUtDLE9BQUwsQ0FBYU0sTUFBYixDQUFsQixDQUFKLEVBQTZDO0FBQ2xEYSxVQUFBQSxRQUFRLEdBQUdFLGVBQVg7QUFDQWQsVUFBQUEsY0FBYyxHQUFHLElBQWpCO0FBQ0Q7O0FBQ0QsWUFBSXhCLE9BQU8sQ0FBQyxxQkFBRCxDQUFQLElBQWtDLGVBQWV1QyxJQUFmLENBQW9CdkMsT0FBTyxDQUFDLHFCQUFELENBQTNCLENBQXRDLEVBQTJGO0FBQ3pGLGdCQUFNd0MsS0FBSyxHQUFHLHFCQUFxQkMsSUFBckIsQ0FBMEJ6QyxPQUFPLENBQUMscUJBQUQsQ0FBakMsQ0FBZDs7QUFDQSxjQUFJd0MsS0FBSixFQUFXO0FBQ1R0Qyw0QkFBT0MsS0FBUCxDQUFjLHFCQUFvQnFDLEtBQUssQ0FBQyxDQUFELENBQUkscUNBQTNDOztBQUNBSixZQUFBQSxRQUFRLEdBQUcsK0JBQVNJLEtBQUssQ0FBQyxDQUFELENBQWQsRUFBbUI7QUFBQ0UsY0FBQUEsV0FBVyxFQUFFO0FBQWQsYUFBbkIsQ0FBWDtBQUNBbEIsWUFBQUEsY0FBYyxHQUFHQSxjQUFjLElBQUl0QyxRQUFRLENBQUM2QixRQUFULENBQWtCQyxjQUFLQyxPQUFMLENBQWFtQixRQUFiLENBQWxCLENBQW5DO0FBQ0Q7QUFDRjs7QUFDRCxjQUFNTyxVQUFVLFNBQVNDLHVCQUFRNUIsSUFBUixDQUFhO0FBQ3BDNkIsVUFBQUEsTUFBTSxFQUFFVCxRQUQ0QjtBQUVwQ1UsVUFBQUEsTUFBTSxFQUFFO0FBRjRCLFNBQWIsQ0FBekI7QUFJQXZCLFFBQUFBLE1BQU0sU0FBU3dCLFdBQVcsQ0FBQ3hCLE1BQUQsRUFBU29CLFVBQVQsQ0FBMUI7QUFDRCxPQTlDRCxNQThDTyxVQUFVVixrQkFBR0MsTUFBSCxDQUFVWCxNQUFWLENBQVYsRUFBNkI7QUFFbENyQix3QkFBTzRCLElBQVAsQ0FBYSxvQkFBbUJQLE1BQU8sR0FBdkM7O0FBQ0FDLFFBQUFBLGNBQWMsR0FBR3RDLFFBQVEsQ0FBQzZCLFFBQVQsQ0FBa0JDLGNBQUtDLE9BQUwsQ0FBYU0sTUFBYixDQUFsQixDQUFqQjtBQUNELE9BSk0sTUFJQTtBQUNMLFlBQUl5QixZQUFZLEdBQUksdUJBQXNCekIsTUFBTyx1Q0FBakQ7O0FBRUEsWUFBSUgsZ0JBQUVDLFFBQUYsQ0FBV00sUUFBWCxLQUF3QkEsUUFBUSxDQUFDc0IsTUFBVCxHQUFrQixDQUE5QyxFQUFpRDtBQUMvQ0QsVUFBQUEsWUFBWSxHQUFJLGlCQUFnQnJCLFFBQVMsY0FBYUosTUFBTyxzQkFBOUMsR0FDWiwrQ0FESDtBQUVEOztBQUNELGNBQU0sSUFBSUwsS0FBSixDQUFVOEIsWUFBVixDQUFOO0FBQ0Q7O0FBRUQsVUFBSXhCLGNBQUosRUFBb0I7QUFDbEIsY0FBTTBCLFdBQVcsR0FBRzNCLE1BQXBCO0FBQ0FFLFFBQUFBLFdBQVcsU0FBU1Esa0JBQUdrQixJQUFILENBQVFELFdBQVIsQ0FBcEI7O0FBQ0EsWUFBSTlELGtCQUFrQixDQUFDbUIsR0FBbkIsQ0FBdUJNLEdBQXZCLEtBQStCWSxXQUFXLEtBQUtyQyxrQkFBa0IsQ0FBQ29CLEdBQW5CLENBQXVCSyxHQUF2QixFQUE0QnNDLElBQS9FLEVBQXFGO0FBQUEseUNBQ2hFL0Qsa0JBQWtCLENBQUNvQixHQUFuQixDQUF1QkssR0FBdkIsQ0FEZ0U7QUFBQSxnQkFDNUVILFFBRDRFLDBCQUM1RUEsUUFENEU7O0FBRW5GLG9CQUFVdUIsa0JBQUdDLE1BQUgsQ0FBVXhCLFFBQVYsQ0FBVixFQUErQjtBQUM3QixnQkFBSXdDLFdBQVcsS0FBS3JDLEdBQXBCLEVBQXlCO0FBQ3ZCLG9CQUFNb0Isa0JBQUdtQixNQUFILENBQVVGLFdBQVYsQ0FBTjtBQUNEOztBQUNEaEQsNEJBQU80QixJQUFQLENBQWEsZ0RBQStDcEIsUUFBUyxHQUFyRTs7QUFDQSxtQkFBT0Usa0JBQWtCLENBQUNGLFFBQUQsRUFBV0ksc0JBQVgsQ0FBekI7QUFDRDs7QUFDRFosMEJBQU80QixJQUFQLENBQWEsdUJBQXNCcEIsUUFBUyxzREFBNUM7O0FBQ0F0QixVQUFBQSxrQkFBa0IsQ0FBQytDLEdBQW5CLENBQXVCdEIsR0FBdkI7QUFDRDs7QUFDRCxjQUFNd0MsT0FBTyxTQUFTVCx1QkFBUVUsT0FBUixFQUF0Qjs7QUFDQSxZQUFJO0FBQ0YvQixVQUFBQSxNQUFNLFNBQVNnQyxRQUFRLENBQUNMLFdBQUQsRUFBY0csT0FBZCxFQUF1QnZDLHNCQUF2QixDQUF2QjtBQUNELFNBRkQsU0FFVTtBQUNSLGNBQUlTLE1BQU0sS0FBSzJCLFdBQVgsSUFBMEJBLFdBQVcsS0FBS3JDLEdBQTlDLEVBQW1EO0FBQ2pELGtCQUFNb0Isa0JBQUdtQixNQUFILENBQVVGLFdBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBQ0RoRCx3QkFBTzRCLElBQVAsQ0FBYSwwQkFBeUJQLE1BQU8sR0FBN0M7QUFDRCxPQXhCRCxNQXdCTyxJQUFJLENBQUNQLGNBQUt3QyxVQUFMLENBQWdCakMsTUFBaEIsQ0FBTCxFQUE4QjtBQUNuQ0EsUUFBQUEsTUFBTSxHQUFHUCxjQUFLeUMsT0FBTCxDQUFhQyxPQUFPLENBQUNDLEdBQVIsRUFBYixFQUE0QnBDLE1BQTVCLENBQVQ7O0FBQ0FyQix3QkFBTzBELElBQVAsQ0FBYSxpQ0FBZ0MvQyxHQUFJLGlCQUFyQyxHQUNULHFFQUFvRVUsTUFBTyxJQURsRSxHQUVULHdCQUZIO0FBR0Q7O0FBRURYLE1BQUFBLGtCQUFrQixDQUFDVyxNQUFELEVBQVNULHNCQUFULENBQWxCOztBQUVBLFVBQUlELEdBQUcsS0FBS1UsTUFBUixLQUFtQkUsV0FBVyxJQUFJbkIsZUFBbEMsQ0FBSixFQUF3RDtBQUN0RGxCLFFBQUFBLGtCQUFrQixDQUFDeUUsR0FBbkIsQ0FBdUJoRCxHQUF2QixFQUE0QjtBQUMxQnNDLFVBQUFBLElBQUksRUFBRTFCLFdBRG9CO0FBRTFCaEIsVUFBQUEsWUFBWSxFQUFFSCxlQUZZO0FBRzFCSSxVQUFBQSxRQUFRLEVBQUVhO0FBSGdCLFNBQTVCO0FBS0Q7O0FBQ0QsYUFBT0EsTUFBUDtBQUNELEtBdEdZLEVBQWI7QUF1R0QsRzs7OztTQUVjd0IsVzs7Ozs7aURBQWYsV0FBNEJsQyxHQUE1QixFQUFpQzhCLFVBQWpDLEVBQTZDO0FBQzNDLFFBQUltQixNQUFKOztBQUNBLFFBQUk7QUFDRkEsTUFBQUEsTUFBTSxHQUFHbEUsYUFBSThCLEtBQUosQ0FBVWIsR0FBVixDQUFUO0FBQ0QsS0FGRCxDQUVFLE9BQU9rRCxHQUFQLEVBQVk7QUFDWixZQUFNLElBQUk3QyxLQUFKLENBQVcsb0JBQW1CTCxHQUFJLEdBQWxDLENBQU47QUFDRDs7QUFFRCxRQUFJO0FBQ0YsWUFBTW1ELE9BQU8sR0FBR04sT0FBTyxDQUFDTyxNQUFSLEVBQWhCO0FBRUEsWUFBTSxJQUFJQyxpQkFBSixDQUFNLENBQUNULE9BQUQsRUFBVVUsTUFBVixLQUFxQjtBQUMvQiw4QkFBUUwsTUFBTSxDQUFDTSxJQUFmLEVBQ0dDLEVBREgsQ0FDTSxPQUROLEVBQ2VGLE1BRGYsRUFFR0UsRUFGSCxDQUVNLFVBRk4sRUFFbUJDLEdBQUQsSUFBUztBQUV2QixjQUFJQSxHQUFHLENBQUNDLFVBQUosSUFBa0IsR0FBdEIsRUFBMkI7QUFDekIsbUJBQU9KLE1BQU0sQ0FBRSwyQkFBMEJHLEdBQUcsQ0FBQ0MsVUFBVyxFQUEzQyxDQUFiO0FBQ0Q7QUFDRixTQVBILEVBUUdDLElBUkgsQ0FRUUMsYUFBSUMsaUJBQUosQ0FBc0IvQixVQUF0QixDQVJSLEVBU0cwQixFQVRILENBU00sT0FUTixFQVNlWixPQVRmO0FBVUQsT0FYSyxDQUFOOztBQUhFLDhCQWVvQkMsT0FBTyxDQUFDTyxNQUFSLENBQWVELE9BQWYsQ0FmcEI7QUFBQTtBQUFBLFlBZUtXLE9BZkw7QUFBQSxZQWVjQyxFQWZkOztBQWdCRixZQUFNQyxjQUFjLEdBQUdGLE9BQU8sR0FBR0MsRUFBRSxHQUFHLElBQXRDOztBQWhCRSwwQkFpQm1CM0Msa0JBQUc2QyxJQUFILENBQVFuQyxVQUFSLENBakJuQjtBQUFBLFlBaUJLb0MsSUFqQkwsU0FpQktBLElBakJMOztBQWtCRjdFLHNCQUFPQyxLQUFQLENBQWMsSUFBRzJELE1BQU0sQ0FBQ00sSUFBSyxNQUFLWSxvQkFBS0Msb0JBQUwsQ0FBMEJGLElBQTFCLENBQWdDLElBQXJELEdBQ1YsMkJBQTBCcEMsVUFBVyxRQUFPa0MsY0FBYyxDQUFDSyxPQUFmLENBQXVCLENBQXZCLENBQTBCLEdBRHpFOztBQUVBLFVBQUlMLGNBQWMsSUFBSSxDQUF0QixFQUF5QjtBQUN2QixjQUFNTSxXQUFXLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXTixJQUFJLEdBQUdGLGNBQWxCLENBQXBCOztBQUNBM0Usd0JBQU9DLEtBQVAsQ0FBYywrQkFBOEI2RSxvQkFBS0Msb0JBQUwsQ0FBMEJFLFdBQTFCLENBQXVDLElBQW5GO0FBQ0Q7O0FBQ0QsYUFBT3hDLFVBQVA7QUFDRCxLQXpCRCxDQXlCRSxPQUFPb0IsR0FBUCxFQUFZO0FBQ1osWUFBTSxJQUFJN0MsS0FBSixDQUFXLG9DQUFtQzRDLE1BQU0sQ0FBQ00sSUFBSyxLQUFJTCxHQUFHLENBQUMzRCxPQUFRLEVBQTFFLENBQU47QUFDRDtBQUNGLEc7Ozs7U0FFY2tGLE87Ozs7OzZDQUFmLFdBQXdCQyxHQUF4QixFQUE2QjtBQUMzQixVQUFNQyxNQUFNLEdBQUcsRUFBZjtBQUQyQjtBQUFBO0FBQUE7O0FBQUE7QUFFM0Isa0NBQXlCdkQsa0JBQUd3RCxPQUFILENBQVdGLEdBQVgsQ0FBekIsK0hBQTBDO0FBQUEsY0FBL0JHLElBQStCOztBQUN4QyxjQUFNQyxXQUFXLEdBQUczRSxjQUFLNEUsSUFBTCxDQUFVTCxHQUFWLEVBQWVHLElBQWYsQ0FBcEI7O0FBQ0FGLFFBQUFBLE1BQU0sQ0FBQ0ssSUFBUCxDQUFZRixXQUFaOztBQUNBLFlBQUksT0FBTzFELGtCQUFHNkMsSUFBSCxDQUFRYSxXQUFSLENBQVAsRUFBNkJHLFdBQTdCLEVBQUosRUFBZ0Q7QUFDOUNOLFVBQUFBLE1BQU0sQ0FBQ0ssSUFBUCxDQUFZLFVBQVVQLE9BQU8sQ0FBQ0ssV0FBRCxDQUFqQixDQUFaO0FBQ0Q7QUFDRjtBQVIwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVMzQixXQUFPSCxNQUFQO0FBQ0QsRzs7OztTQUVjakMsUTs7Ozs7OENBQWYsV0FBeUJ3QyxPQUF6QixFQUFrQ0MsT0FBbEMsRUFBMkNsRixzQkFBM0MsRUFBbUU7QUFDakUsVUFBTW1GLG1CQUFJQyxjQUFKLENBQW1CSCxPQUFuQixDQUFOOztBQUVBLFFBQUksQ0FBQzNFLGdCQUFFRSxPQUFGLENBQVVSLHNCQUFWLENBQUwsRUFBd0M7QUFDdENBLE1BQUFBLHNCQUFzQixHQUFHLENBQUNBLHNCQUFELENBQXpCO0FBQ0Q7O0FBRUQsVUFBTXVDLE9BQU8sU0FBU1QsdUJBQVFVLE9BQVIsRUFBdEI7O0FBQ0EsUUFBSTtBQUNGcEQsc0JBQU9DLEtBQVAsQ0FBYyxjQUFhNEYsT0FBUSxHQUFuQzs7QUFDQSxZQUFNRSxtQkFBSUUsWUFBSixDQUFpQkosT0FBakIsRUFBMEIxQyxPQUExQixDQUFOO0FBQ0EsWUFBTStDLGlCQUFpQixTQUFTZCxPQUFPLENBQUNqQyxPQUFELENBQXZDOztBQUNBbkQsc0JBQU9DLEtBQVAsQ0FBYyxhQUFZaUcsaUJBQWlCLENBQUNuRCxNQUFPLGtCQUFpQjhDLE9BQVEsR0FBNUU7O0FBQ0EsWUFBTU0sa0JBQWtCLEdBQUlDLFlBQUQsSUFBa0J4RixzQkFBc0IsQ0FBQ0MsUUFBdkIsQ0FBZ0NDLGNBQUtDLE9BQUwsQ0FBYXFGLFlBQWIsQ0FBaEMsS0FDeENsRixnQkFBRW1GLElBQUYsQ0FBT3pGLHNCQUFQLEVBQWdDMEYsQ0FBRCxJQUFPRixZQUFZLENBQUN2RixRQUFiLENBQXVCLEdBQUV5RixDQUFFLEdBQUV4RixjQUFLeUYsR0FBSSxFQUF0QyxDQUF0QyxDQURMOztBQUVBLFlBQU1DLFdBQVcsR0FBR04saUJBQWlCLENBQ2xDTyxHQURpQixDQUNaQyxRQUFELElBQWM1RixjQUFLNkYsUUFBTCxDQUFjeEQsT0FBZCxFQUF1QnVELFFBQXZCLENBREQsRUFFakJFLE1BRmlCLENBRVRSLFlBQUQsSUFBa0JELGtCQUFrQixDQUFDQyxZQUFELENBRjFCLEVBR2pCSyxHQUhpQixDQUdaTCxZQUFELElBQWtCdEYsY0FBS3lDLE9BQUwsQ0FBYUosT0FBYixFQUFzQmlELFlBQXRCLENBSEwsQ0FBcEI7O0FBSUEsWUFBTVMsYUFBYSxHQUFHM0YsZ0JBQUU0RixVQUFGLENBQWFaLGlCQUFiLEVBQWdDTSxXQUFoQyxFQUVuQkksTUFGbUIsQ0FFWEcsZ0JBQUQsSUFBc0IsQ0FBQzdGLGdCQUFFbUYsSUFBRixDQUFPRyxXQUFQLEVBQXFCUSxjQUFELElBQW9CQSxjQUFjLENBQUNDLFVBQWYsQ0FBMEJGLGdCQUExQixDQUF4QyxDQUZYLENBQXRCOztBQUdBLFlBQU0vQyxrQkFBRWtELEdBQUYsQ0FBTUwsYUFBTjtBQUFBLG9EQUFxQixXQUFPSCxRQUFQLEVBQW9CO0FBQzdDLG9CQUFVM0Usa0JBQUdDLE1BQUgsQ0FBVTBFLFFBQVYsQ0FBVixFQUErQjtBQUM3QixrQkFBTTNFLGtCQUFHbUIsTUFBSCxDQUFVd0QsUUFBVixDQUFOO0FBQ0Q7QUFDRixTQUpLOztBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQU47QUFLQSxZQUFNUyxjQUFjLEdBQUcsT0FBTy9CLE9BQU8sQ0FBQ2pDLE9BQUQsQ0FBZCxFQUNwQnNELEdBRG9CLENBQ2ZDLFFBQUQsSUFBYzVGLGNBQUs2RixRQUFMLENBQWN4RCxPQUFkLEVBQXVCdUQsUUFBdkIsQ0FERSxFQUVwQkUsTUFGb0IsQ0FFWlIsWUFBRCxJQUFrQkQsa0JBQWtCLENBQUNDLFlBQUQsQ0FGdkIsRUFJcEJnQixJQUpvQixDQUlmLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUFVRCxDQUFDLENBQUNFLEtBQUYsQ0FBUXpHLGNBQUt5RixHQUFiLEVBQWtCeEQsTUFBbEIsR0FBMkJ1RSxDQUFDLENBQUNDLEtBQUYsQ0FBUXpHLGNBQUt5RixHQUFiLEVBQWtCeEQsTUFKeEMsQ0FBdkI7O0FBS0EsVUFBSTdCLGdCQUFFc0csT0FBRixDQUFVTCxjQUFWLENBQUosRUFBK0I7QUFDN0IsY0FBTSxJQUFJbkcsS0FBSixDQUFXLDhDQUE2Q0osc0JBQXVCLGFBQXJFLEdBQ2IsMENBQXlDQSxzQkFBdUIsY0FEbkQsR0FFYixrQkFGRyxDQUFOO0FBR0Q7O0FBQ0QsWUFBTTZHLGFBQWEsR0FBR3ZHLGdCQUFFaUIsS0FBRixDQUFRZ0YsY0FBUixDQUF0Qjs7QUFDQW5ILHNCQUFPQyxLQUFQLENBQWMsV0FBVWtILGNBQWMsQ0FBQ3BFLE1BQU8scUNBQWpDLEdBQ1YsYUFBWTBFLGFBQWMseUJBRDdCOztBQUVBLFlBQU0xRixrQkFBRzJGLEVBQUgsQ0FBTTVHLGNBQUt5QyxPQUFMLENBQWFKLE9BQWIsRUFBc0JzRSxhQUF0QixDQUFOLEVBQTRDM0csY0FBS3lDLE9BQUwsQ0FBYXVDLE9BQWIsRUFBc0IyQixhQUF0QixDQUE1QyxFQUFrRjtBQUN0RkUsUUFBQUEsTUFBTSxFQUFFO0FBRDhFLE9BQWxGLENBQU47QUFHQSxhQUFPN0csY0FBS3lDLE9BQUwsQ0FBYXVDLE9BQWIsRUFBc0IyQixhQUF0QixDQUFQO0FBQ0QsS0FwQ0QsU0FvQ1U7QUFDUixZQUFNMUYsa0JBQUdtQixNQUFILENBQVVDLE9BQVYsQ0FBTjtBQUNEO0FBQ0YsRzs7OztBQUVELFNBQVN5RSxpQkFBVCxDQUE0QmpILEdBQTVCLEVBQWlDO0FBQy9CLFNBQVEsdUNBQUQsQ0FBMEMwQixJQUExQyxDQUErQzFCLEdBQS9DLENBQVA7QUFDRDs7QUFFRCxTQUFTa0gsZUFBVCxDQUEwQkMsR0FBMUIsRUFBK0I7QUFJN0IsU0FBT2hELG9CQUFLaUQsUUFBTCxDQUFjRCxHQUFkLElBQXFCQSxHQUFyQixHQUEyQixHQUFsQztBQUNEOztBQUVELFNBQVNFLHFCQUFULENBQWdDQyxXQUFoQyxFQUE2QztBQUczQyxNQUFJQyxRQUFRLEdBQUcsR0FBZjs7QUFDQSxNQUFJLE9BQU9ELFdBQVcsQ0FBQ0UsT0FBWixDQUFvQkMsRUFBM0IsS0FBa0MsV0FBbEMsSUFBaURILFdBQVcsQ0FBQ0UsT0FBWixDQUFvQkMsRUFBekUsRUFBNkU7QUFDM0VGLElBQUFBLFFBQVEsR0FBR0QsV0FBVyxDQUFDRSxPQUFaLENBQW9CQyxFQUFwQixHQUF5QixJQUFwQzs7QUFDQSxRQUFJRixRQUFRLEtBQUssQ0FBakIsRUFBb0I7QUFHbEJBLE1BQUFBLFFBQVEsR0FBRyxHQUFYO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPQSxRQUFQO0FBQ0Q7O0FBUUQsU0FBU0csU0FBVCxDQUFvQkMsS0FBcEIsRUFBMkJDLEtBQTNCLEVBQWtDQyxNQUFsQyxFQUEwQztBQUN4QyxNQUFJdEgsZ0JBQUVFLE9BQUYsQ0FBVWtILEtBQVYsQ0FBSixFQUFzQjtBQUNwQixXQUFPQSxLQUFLLENBQUM3QixHQUFOLENBQVdnQyxJQUFELElBQVVKLFNBQVMsQ0FBQ0ksSUFBRCxFQUFPRixLQUFQLEVBQWNDLE1BQWQsQ0FBN0IsQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJdEgsZ0JBQUV3SCxhQUFGLENBQWdCSixLQUFoQixDQUFKLEVBQTRCO0FBQ2pDLFdBQU9wSCxnQkFBRXlILE1BQUYsQ0FBU0wsS0FBVCxFQUFnQixDQUFDTSxTQUFELEVBQVlDLEtBQVosRUFBbUJDLEdBQW5CLHFDQUNsQkYsU0FEa0I7QUFFckIsT0FBQ0UsR0FBRyxLQUFLUCxLQUFSLEdBQWdCQyxNQUFoQixHQUF5Qk0sR0FBMUIsR0FBZ0NULFNBQVMsQ0FBQ1EsS0FBRCxFQUFRTixLQUFSLEVBQWVDLE1BQWY7QUFGcEIsTUFBaEIsRUFHSCxFQUhHLENBQVA7QUFJRDs7QUFFRCxTQUFPRixLQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBfZnMgZnJvbSAnZnMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgdGVtcERpciwgZnMsIHV0aWwsIHppcCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCByZXF1ZXN0IGZyb20gJ3JlcXVlc3QnO1xuaW1wb3J0IGFzeW5jUmVxdWVzdCBmcm9tICdyZXF1ZXN0LXByb21pc2UnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IEFzeW5jTG9jayBmcm9tICdhc3luYy1sb2NrJztcbmltcG9ydCBzYW5pdGl6ZSBmcm9tICdzYW5pdGl6ZS1maWxlbmFtZSc7XG5cbmNvbnN0IFpJUF9FWFRTID0gWycuemlwJywgJy5pcGEnXTtcbmNvbnN0IFpJUF9NSU1FX1RZUEVTID0gW1xuICAnYXBwbGljYXRpb24vemlwJyxcbiAgJ2FwcGxpY2F0aW9uL3gtemlwLWNvbXByZXNzZWQnLFxuICAnbXVsdGlwYXJ0L3gtemlwJyxcbl07XG5jb25zdCBBUFBMSUNBVElPTlNfQ0FDSEUgPSBuZXcgTFJVKHtcbiAgbWF4OiAxMDAsXG59KTtcbmNvbnN0IEFQUExJQ0FUSU9OU19DQUNIRV9HVUFSRCA9IG5ldyBBc3luY0xvY2soKTtcblxuYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVIZWFkZXJzIChsaW5rKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhc3luY1JlcXVlc3Qoe1xuICAgICAgdXJsOiBsaW5rLFxuICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICByZXNvbHZlV2l0aEZ1bGxSZXNwb25zZTogdHJ1ZSxcbiAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dnZXIuZGVidWcoYENhbm5vdCBzZW5kIEhFQUQgcmVxdWVzdCB0byAnJHtsaW5rfScuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlZEFwcGxpY2F0aW9uUGF0aCAobGluaywgY3VycmVudE1vZGlmaWVkKSB7XG4gIGlmICghQVBQTElDQVRJT05TX0NBQ0hFLmhhcyhsaW5rKSB8fCAhY3VycmVudE1vZGlmaWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB7bGFzdE1vZGlmaWVkLCBmdWxsUGF0aH0gPSBBUFBMSUNBVElPTlNfQ0FDSEUuZ2V0KGxpbmspO1xuICBpZiAobGFzdE1vZGlmaWVkICYmIGN1cnJlbnRNb2RpZmllZC5nZXRUaW1lKCkgPD0gbGFzdE1vZGlmaWVkLmdldFRpbWUoKSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgUmV1c2luZyBhbHJlYWR5IGRvd25sb2FkZWQgYXBwbGljYXRpb24gYXQgJyR7ZnVsbFBhdGh9J2ApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuICBsb2dnZXIuZGVidWcoYCdMYXN0LU1vZGlmaWVkJyB0aW1lc3RhbXAgb2YgJyR7bGlua30nIGhhcyBiZWVuIHVwZGF0ZWQuIGAgK1xuICAgIGBBbiB1cGRhdGVkIGNvcHkgb2YgdGhlIGFwcGxpY2F0aW9uIGlzIGdvaW5nIHRvIGJlIGRvd25sb2FkZWQuYCk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlBcHBFeHRlbnNpb24gKGFwcCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucykge1xuICBpZiAoc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucy5pbmNsdWRlcyhwYXRoLmV4dG5hbWUoYXBwKSkpIHtcbiAgICByZXR1cm4gYXBwO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgTmV3IGFwcCBwYXRoICcke2FwcH0nIGRpZCBub3QgaGF2ZSBleHRlbnNpb24ocykgJyR7c3VwcG9ydGVkQXBwRXh0ZW5zaW9uc30nYCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbmZpZ3VyZUFwcCAoYXBwLCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKSB7XG4gIGlmICghXy5pc1N0cmluZyhhcHApKSB7XG4gICAgLy8gaW1tZWRpYXRlbHkgc2hvcnRjaXJjdWl0IGlmIG5vdCBnaXZlbiBhbiBhcHBcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFfLmlzQXJyYXkoc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucykpIHtcbiAgICBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zID0gW3N1cHBvcnRlZEFwcEV4dGVuc2lvbnNdO1xuICB9XG5cbiAgbGV0IG5ld0FwcCA9IGFwcDtcbiAgbGV0IHNob3VsZFVuemlwQXBwID0gZmFsc2U7XG4gIGxldCBhcmNoaXZlSGFzaCA9IG51bGw7XG4gIGxldCBjdXJyZW50TW9kaWZpZWQgPSBudWxsO1xuICBjb25zdCB7cHJvdG9jb2x9ID0gdXJsLnBhcnNlKG5ld0FwcCk7XG4gIGNvbnN0IGlzVXJsID0gWydodHRwOicsICdodHRwczonXS5pbmNsdWRlcyhwcm90b2NvbCk7XG5cbiAgcmV0dXJuIGF3YWl0IEFQUExJQ0FUSU9OU19DQUNIRV9HVUFSRC5hY3F1aXJlKGFwcCwgYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc1VybCkge1xuICAgICAgLy8gVXNlIHRoZSBhcHAgZnJvbSByZW1vdGUgVVJMXG4gICAgICBsb2dnZXIuaW5mbyhgVXNpbmcgZG93bmxvYWRhYmxlIGFwcCAnJHtuZXdBcHB9J2ApO1xuICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IHJldHJpZXZlSGVhZGVycyhuZXdBcHApO1xuICAgICAgaWYgKGhlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYExhc3QtTW9kaWZpZWQ6ICR7aGVhZGVyc1snbGFzdC1tb2RpZmllZCddfWApO1xuICAgICAgICBjdXJyZW50TW9kaWZpZWQgPSBuZXcgRGF0ZShoZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGVkUGF0aCA9IGdldENhY2hlZEFwcGxpY2F0aW9uUGF0aChhcHAsIGN1cnJlbnRNb2RpZmllZCk7XG4gICAgICBpZiAoY2FjaGVkUGF0aCkge1xuICAgICAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGNhY2hlZFBhdGgpKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYFJldXNpbmcgdGhlIHByZXZpb3VzbHkgZG93bmxvYWRlZCBhcHBsaWNhdGlvbiBhdCAnJHtjYWNoZWRQYXRofSdgKTtcbiAgICAgICAgICByZXR1cm4gdmVyaWZ5QXBwRXh0ZW5zaW9uKGNhY2hlZFBhdGgsIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKGBUaGUgYXBwbGljYXRpb24gYXQgJyR7Y2FjaGVkUGF0aH0nIGRvZXMgbm90IGV4aXN0IGFueW1vcmUuIERlbGV0aW5nIGl0IGZyb20gdGhlIGNhY2hlYCk7XG4gICAgICAgIEFQUExJQ0FUSU9OU19DQUNIRS5kZWwoYXBwKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWxlTmFtZSA9IGBhcHBpdW0tYXBwJHtfLmZpcnN0KHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpfWA7XG5cbiAgICAgIC8vIHRvIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHVuemlwIHRoZSBhcHAsIHdlIGhhdmUgYSBudW1iZXIgb2YgcGxhY2VzXG4gICAgICAvLyB0byBsb29rOiBjb250ZW50IHR5cGUsIGNvbnRlbnQgZGlzcG9zaXRpb24sIG9yIHRoZSBmaWxlIGV4dGVuc2lvblxuICAgICAgY29uc3QgZG93bmxvYWRaaXBOYW1lID0gJ2FwcGl1bS1hcHAuemlwJztcbiAgICAgIGlmIChoZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYENvbnRlbnQtVHlwZTogJHtoZWFkZXJzWydjb250ZW50LXR5cGUnXX1gKTtcbiAgICAgICAgLy8gdGhlIGZpbGV0eXBlIG1heSBub3QgYmUgb2J2aW91cyBmb3IgY2VydGFpbiB1cmxzLCBzbyBjaGVjayB0aGUgbWltZSB0eXBlIHRvb1xuICAgICAgICBpZiAoWklQX01JTUVfVFlQRVMuaW5jbHVkZXMoaGVhZGVyc1snY29udGVudC10eXBlJ10pKSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBkb3dubG9hZFppcE5hbWU7XG4gICAgICAgICAgc2hvdWxkVW56aXBBcHAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFpJUF9FWFRTLmluY2x1ZGVzKHBhdGguZXh0bmFtZShuZXdBcHApKSkge1xuICAgICAgICBmaWxlTmFtZSA9IGRvd25sb2FkWmlwTmFtZTtcbiAgICAgICAgc2hvdWxkVW56aXBBcHAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhlYWRlcnNbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSAmJiAvXmF0dGFjaG1lbnQvaS50ZXN0KGhlYWRlcnNbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvZmlsZW5hbWU9XCIoW15cIl0rKS9pLmV4ZWMoaGVhZGVyc1snY29udGVudC1kaXNwb3NpdGlvbiddKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKGBQYXJzZWQgZmlsZSBuYW1lICcke21hdGNoWzFdfScgZnJvbSAnQ29udGVudC1EaXNwb3NpdGlvbicgaGVhZGVyYCk7XG4gICAgICAgICAgZmlsZU5hbWUgPSBzYW5pdGl6ZShtYXRjaFsxXSwge3JlcGxhY2VtZW50OiAnLSd9KTtcbiAgICAgICAgICBzaG91bGRVbnppcEFwcCA9IHNob3VsZFVuemlwQXBwIHx8IFpJUF9FWFRTLmluY2x1ZGVzKHBhdGguZXh0bmFtZShmaWxlTmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRQYXRoID0gYXdhaXQgdGVtcERpci5wYXRoKHtcbiAgICAgICAgcHJlZml4OiBmaWxlTmFtZSxcbiAgICAgICAgc3VmZml4OiAnJyxcbiAgICAgIH0pO1xuICAgICAgbmV3QXBwID0gYXdhaXQgZG93bmxvYWRBcHAobmV3QXBwLCB0YXJnZXRQYXRoKTtcbiAgICB9IGVsc2UgaWYgKGF3YWl0IGZzLmV4aXN0cyhuZXdBcHApKSB7XG4gICAgICAvLyBVc2UgdGhlIGxvY2FsIGFwcFxuICAgICAgbG9nZ2VyLmluZm8oYFVzaW5nIGxvY2FsIGFwcCAnJHtuZXdBcHB9J2ApO1xuICAgICAgc2hvdWxkVW56aXBBcHAgPSBaSVBfRVhUUy5pbmNsdWRlcyhwYXRoLmV4dG5hbWUobmV3QXBwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgVGhlIGFwcGxpY2F0aW9uIGF0ICcke25ld0FwcH0nIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhY2Nlc3NpYmxlYDtcbiAgICAgIC8vIHByb3RvY29sIHZhbHVlIGZvciAnQzpcXFxcdGVtcCcgaXMgJ2M6Jywgc28gd2UgY2hlY2sgdGhlIGxlbmd0aCBhcyB3ZWxsXG4gICAgICBpZiAoXy5pc1N0cmluZyhwcm90b2NvbCkgJiYgcHJvdG9jb2wubGVuZ3RoID4gMikge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBgVGhlIHByb3RvY29sICcke3Byb3RvY29sfScgdXNlZCBpbiAnJHtuZXdBcHB9JyBpcyBub3Qgc3VwcG9ydGVkLiBgICtcbiAgICAgICAgICBgT25seSBodHRwOiBhbmQgaHR0cHM6IHByb3RvY29scyBhcmUgc3VwcG9ydGVkYDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVbnppcEFwcCkge1xuICAgICAgY29uc3QgYXJjaGl2ZVBhdGggPSBuZXdBcHA7XG4gICAgICBhcmNoaXZlSGFzaCA9IGF3YWl0IGZzLmhhc2goYXJjaGl2ZVBhdGgpO1xuICAgICAgaWYgKEFQUExJQ0FUSU9OU19DQUNIRS5oYXMoYXBwKSAmJiBhcmNoaXZlSGFzaCA9PT0gQVBQTElDQVRJT05TX0NBQ0hFLmdldChhcHApLmhhc2gpIHtcbiAgICAgICAgY29uc3Qge2Z1bGxQYXRofSA9IEFQUExJQ0FUSU9OU19DQUNIRS5nZXQoYXBwKTtcbiAgICAgICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhmdWxsUGF0aCkpIHtcbiAgICAgICAgICBpZiAoYXJjaGl2ZVBhdGggIT09IGFwcCkge1xuICAgICAgICAgICAgYXdhaXQgZnMucmltcmFmKGFyY2hpdmVQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYFdpbGwgcmV1c2UgcHJldmlvdXNseSBjYWNoZWQgYXBwbGljYXRpb24gYXQgJyR7ZnVsbFBhdGh9J2ApO1xuICAgICAgICAgIHJldHVybiB2ZXJpZnlBcHBFeHRlbnNpb24oZnVsbFBhdGgsIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKGBUaGUgYXBwbGljYXRpb24gYXQgJyR7ZnVsbFBhdGh9JyBkb2VzIG5vdCBleGlzdCBhbnltb3JlLiBEZWxldGluZyBpdCBmcm9tIHRoZSBjYWNoZWApO1xuICAgICAgICBBUFBMSUNBVElPTlNfQ0FDSEUuZGVsKGFwcCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gICAgICB0cnkge1xuICAgICAgICBuZXdBcHAgPSBhd2FpdCB1bnppcEFwcChhcmNoaXZlUGF0aCwgdG1wUm9vdCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobmV3QXBwICE9PSBhcmNoaXZlUGF0aCAmJiBhcmNoaXZlUGF0aCAhPT0gYXBwKSB7XG4gICAgICAgICAgYXdhaXQgZnMucmltcmFmKGFyY2hpdmVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nZ2VyLmluZm8oYFVuemlwcGVkIGxvY2FsIGFwcCB0byAnJHtuZXdBcHB9J2ApO1xuICAgIH0gZWxzZSBpZiAoIXBhdGguaXNBYnNvbHV0ZShuZXdBcHApKSB7XG4gICAgICBuZXdBcHAgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgbmV3QXBwKTtcbiAgICAgIGxvZ2dlci53YXJuKGBUaGUgY3VycmVudCBhcHBsaWNhdGlvbiBwYXRoICcke2FwcH0nIGlzIHJlbGF0aXZlLCBgICtcbiAgICAgICAgYHdoaWNoIG1pZ2h0IGNhdXNlIGZ1cnRoZXIgaXNzdWVzLiBUaGUgcGF0aCBoYXMgYmVlbiByZXdyaXR0ZW4gdG8gJyR7bmV3QXBwfScgYCArXG4gICAgICAgIGBpbiBvcmRlciB0byBhdm9pZCB0aGVtYCk7XG4gICAgfVxuXG4gICAgdmVyaWZ5QXBwRXh0ZW5zaW9uKG5ld0FwcCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyk7XG5cbiAgICBpZiAoYXBwICE9PSBuZXdBcHAgJiYgKGFyY2hpdmVIYXNoIHx8IGN1cnJlbnRNb2RpZmllZCkpIHtcbiAgICAgIEFQUExJQ0FUSU9OU19DQUNIRS5zZXQoYXBwLCB7XG4gICAgICAgIGhhc2g6IGFyY2hpdmVIYXNoLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IGN1cnJlbnRNb2RpZmllZCxcbiAgICAgICAgZnVsbFBhdGg6IG5ld0FwcCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXBwO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBcHAgKGFwcCwgdGFyZ2V0UGF0aCkge1xuICBsZXQgYXBwVXJsO1xuICB0cnkge1xuICAgIGFwcFVybCA9IHVybC5wYXJzZShhcHApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQXBwIFVSTCAoJHthcHB9KWApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdGFydGVkID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAvLyBkb24ndCB1c2UgcmVxdWVzdC1wcm9taXNlIGhlcmUsIHdlIG5lZWQgc3RyZWFtc1xuICAgIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlcXVlc3QoYXBwVXJsLmhyZWYpXG4gICAgICAgIC5vbignZXJyb3InLCByZWplY3QpIC8vIGhhbmRsZSByZWFsIGVycm9ycywgbGlrZSBjb25uZWN0aW9uIGVycm9yc1xuICAgICAgICAub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgICAgICAgIC8vIGhhbmRsZSByZXNwb25zZXMgdGhhdCBmYWlsLCBsaWtlIDQwNHNcbiAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGBFcnJvciBkb3dubG9hZGluZyBmaWxlOiAke3Jlcy5zdGF0dXNDb2RlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnBpcGUoX2ZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldFBhdGgpKVxuICAgICAgICAub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgfSk7XG4gICAgY29uc3QgW3NlY29uZHMsIG5zXSA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0ZWQpO1xuICAgIGNvbnN0IHNlY29uZHNFbGFwc2VkID0gc2Vjb25kcyArIG5zIC8gMUUwOTtcbiAgICBjb25zdCB7c2l6ZX0gPSBhd2FpdCBmcy5zdGF0KHRhcmdldFBhdGgpO1xuICAgIGxvZ2dlci5kZWJ1ZyhgJyR7YXBwVXJsLmhyZWZ9JyAoJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSkgYCArXG4gICAgICBgaGFzIGJlZW4gZG93bmxvYWRlZCB0byAnJHt0YXJnZXRQYXRofScgaW4gJHtzZWNvbmRzRWxhcHNlZC50b0ZpeGVkKDMpfXNgKTtcbiAgICBpZiAoc2Vjb25kc0VsYXBzZWQgPj0gMikge1xuICAgICAgY29uc3QgYnl0ZXNQZXJTZWMgPSBNYXRoLmZsb29yKHNpemUgLyBzZWNvbmRzRWxhcHNlZCk7XG4gICAgICBsb2dnZXIuZGVidWcoYEFwcHJveGltYXRlIGRvd25sb2FkIHNwZWVkOiAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcoYnl0ZXNQZXJTZWMpfS9zYCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRQYXRoO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2JsZW0gZG93bmxvYWRpbmcgYXBwIGZyb20gdXJsICR7YXBwVXJsLmhyZWZ9OiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdhbGtEaXIgKGRpcikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGF3YWl0IGZzLnJlYWRkaXIoZGlyKSkge1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gcGF0aC5qb2luKGRpciwgbmFtZSk7XG4gICAgcmVzdWx0LnB1c2goY3VycmVudFBhdGgpO1xuICAgIGlmICgoYXdhaXQgZnMuc3RhdChjdXJyZW50UGF0aCkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLihhd2FpdCB3YWxrRGlyKGN1cnJlbnRQYXRoKSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5hc3luYyBmdW5jdGlvbiB1bnppcEFwcCAoemlwUGF0aCwgZHN0Um9vdCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucykge1xuICBhd2FpdCB6aXAuYXNzZXJ0VmFsaWRaaXAoemlwUGF0aCk7XG5cbiAgaWYgKCFfLmlzQXJyYXkoc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucykpIHtcbiAgICBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zID0gW3N1cHBvcnRlZEFwcEV4dGVuc2lvbnNdO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICB0cnkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgVW56aXBwaW5nICcke3ppcFBhdGh9J2ApO1xuICAgIGF3YWl0IHppcC5leHRyYWN0QWxsVG8oemlwUGF0aCwgdG1wUm9vdCk7XG4gICAgY29uc3QgYWxsRXh0cmFjdGVkSXRlbXMgPSBhd2FpdCB3YWxrRGlyKHRtcFJvb3QpO1xuICAgIGxvZ2dlci5kZWJ1ZyhgRXh0cmFjdGVkICR7YWxsRXh0cmFjdGVkSXRlbXMubGVuZ3RofSBpdGVtKHMpIGZyb20gJyR7emlwUGF0aH0nYCk7XG4gICAgY29uc3QgaXNTdXBwb3J0ZWRBcHBJdGVtID0gKHJlbGF0aXZlUGF0aCkgPT4gc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucy5pbmNsdWRlcyhwYXRoLmV4dG5hbWUocmVsYXRpdmVQYXRoKSlcbiAgICAgIHx8IF8uc29tZShzdXBwb3J0ZWRBcHBFeHRlbnNpb25zLCAoeCkgPT4gcmVsYXRpdmVQYXRoLmluY2x1ZGVzKGAke3h9JHtwYXRoLnNlcH1gKSk7XG4gICAgY29uc3QgaXRlbXNUb0tlZXAgPSBhbGxFeHRyYWN0ZWRJdGVtc1xuICAgICAgLm1hcCgoaXRlbVBhdGgpID0+IHBhdGgucmVsYXRpdmUodG1wUm9vdCwgaXRlbVBhdGgpKVxuICAgICAgLmZpbHRlcigocmVsYXRpdmVQYXRoKSA9PiBpc1N1cHBvcnRlZEFwcEl0ZW0ocmVsYXRpdmVQYXRoKSlcbiAgICAgIC5tYXAoKHJlbGF0aXZlUGF0aCkgPT4gcGF0aC5yZXNvbHZlKHRtcFJvb3QsIHJlbGF0aXZlUGF0aCkpO1xuICAgIGNvbnN0IGl0ZW1zVG9SZW1vdmUgPSBfLmRpZmZlcmVuY2UoYWxsRXh0cmFjdGVkSXRlbXMsIGl0ZW1zVG9LZWVwKVxuICAgICAgLy8gQXZvaWQgcGFyZW50IGZvbGRlcnMgdG8gYmUgcmVjdXJzaXZlbHkgcmVtb3ZlZFxuICAgICAgLmZpbHRlcigoaXRlbVRvUmVtb3ZlUGF0aCkgPT4gIV8uc29tZShpdGVtc1RvS2VlcCwgKGl0ZW1Ub0tlZXBQYXRoKSA9PiBpdGVtVG9LZWVwUGF0aC5zdGFydHNXaXRoKGl0ZW1Ub1JlbW92ZVBhdGgpKSk7XG4gICAgYXdhaXQgQi5hbGwoaXRlbXNUb1JlbW92ZSwgYXN5bmMgKGl0ZW1QYXRoKSA9PiB7XG4gICAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGl0ZW1QYXRoKSkge1xuICAgICAgICBhd2FpdCBmcy5yaW1yYWYoaXRlbVBhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFsbEJ1bmRsZUl0ZW1zID0gKGF3YWl0IHdhbGtEaXIodG1wUm9vdCkpXG4gICAgICAubWFwKChpdGVtUGF0aCkgPT4gcGF0aC5yZWxhdGl2ZSh0bXBSb290LCBpdGVtUGF0aCkpXG4gICAgICAuZmlsdGVyKChyZWxhdGl2ZVBhdGgpID0+IGlzU3VwcG9ydGVkQXBwSXRlbShyZWxhdGl2ZVBhdGgpKVxuICAgICAgLy8gR2V0IHRoZSB0b3AgbGV2ZWwgbWF0Y2hcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnNwbGl0KHBhdGguc2VwKS5sZW5ndGggLSBiLnNwbGl0KHBhdGguc2VwKS5sZW5ndGgpO1xuICAgIGlmIChfLmlzRW1wdHkoYWxsQnVuZGxlSXRlbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFwcCB6aXAgdW56aXBwZWQgT0ssIGJ1dCB3ZSBjb3VsZCBub3QgZmluZCAke3N1cHBvcnRlZEFwcEV4dGVuc2lvbnN9IGJ1bmRsZShzKSBgICtcbiAgICAgICAgYGluIGl0LiBNYWtlIHN1cmUgeW91ciBhcmNoaXZlIGNvbnRhaW5zICR7c3VwcG9ydGVkQXBwRXh0ZW5zaW9uc30gcGFja2FnZShzKSBgICtcbiAgICAgICAgYGFuZCBub3RoaW5nIGVsc2VgKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hlZEJ1bmRsZSA9IF8uZmlyc3QoYWxsQnVuZGxlSXRlbXMpO1xuICAgIGxvZ2dlci5kZWJ1ZyhgTWF0Y2hlZCAke2FsbEJ1bmRsZUl0ZW1zLmxlbmd0aH0gaXRlbShzKSBpbiB0aGUgZXh0cmFjdGVkIGFyY2hpdmUuIGAgK1xuICAgICAgYEFzc3VtaW5nICcke21hdGNoZWRCdW5kbGV9JyBpcyB0aGUgY29ycmVjdCBidW5kbGVgKTtcbiAgICBhd2FpdCBmcy5tdihwYXRoLnJlc29sdmUodG1wUm9vdCwgbWF0Y2hlZEJ1bmRsZSksIHBhdGgucmVzb2x2ZShkc3RSb290LCBtYXRjaGVkQnVuZGxlKSwge1xuICAgICAgbWtkaXJwOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShkc3RSb290LCBtYXRjaGVkQnVuZGxlKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQYWNrYWdlT3JCdW5kbGUgKGFwcCkge1xuICByZXR1cm4gKC9eKFthLXpBLVowLTlcXC1fXStcXC5bYS16QS1aMC05XFwtX10rKSskLykudGVzdChhcHApO1xufVxuXG5mdW5jdGlvbiBnZXRDb29yZERlZmF1bHQgKHZhbCkge1xuICAvLyBnb2luZyB0aGUgbG9uZyB3YXkgYW5kIGNoZWNraW5nIGZvciB1bmRlZmluZWQgYW5kIG51bGwgc2luY2VcbiAgLy8gd2UgY2FuJ3QgYmUgYXNzdXJlZCBgZWxJZGAgaXMgYSBzdHJpbmcgYW5kIG5vdCBhbiBpbnQuIFNhbWVcbiAgLy8gdGhpbmcgd2l0aCBkZXN0RWxlbWVudCBiZWxvdy5cbiAgcmV0dXJuIHV0aWwuaGFzVmFsdWUodmFsKSA/IHZhbCA6IDAuNTtcbn1cblxuZnVuY3Rpb24gZ2V0U3dpcGVUb3VjaER1cmF0aW9uICh3YWl0R2VzdHVyZSkge1xuICAvLyB0aGUgdG91Y2ggYWN0aW9uIGFwaSB1c2VzIG1zLCB3ZSB3YW50IHNlY29uZHNcbiAgLy8gMC44IGlzIHRoZSBkZWZhdWx0IHRpbWUgZm9yIHRoZSBvcGVyYXRpb25cbiAgbGV0IGR1cmF0aW9uID0gMC44O1xuICBpZiAodHlwZW9mIHdhaXRHZXN0dXJlLm9wdGlvbnMubXMgIT09ICd1bmRlZmluZWQnICYmIHdhaXRHZXN0dXJlLm9wdGlvbnMubXMpIHtcbiAgICBkdXJhdGlvbiA9IHdhaXRHZXN0dXJlLm9wdGlvbnMubXMgLyAxMDAwO1xuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gc2V0IHRvIGEgdmVyeSBsb3cgbnVtYmVyLCBzaW5jZSB0aGV5IHdhbnRlZCBpdCBmYXN0XG4gICAgICAvLyBidXQgYmVsb3cgMC4xIGJlY29tZXMgMCBzdGVwcywgd2hpY2ggY2F1c2VzIGVycm9yc1xuICAgICAgZHVyYXRpb24gPSAwLjE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXJhdGlvbjtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBmaW5kIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGtleSAnaW5LZXknIGFuZCByZW5hbWUgdGhlbSAnb3V0S2V5J1xuICogQHBhcmFtIHsqfSBpbnB1dCBBbnkgdHlwZSBvZiBpbnB1dFxuICogQHBhcmFtIHtTdHJpbmd9IGluS2V5IFRoZSBrZXkgbmFtZSB0byByZXBsYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0S2V5IFRoZSBrZXkgbmFtZSB0byByZXBsYWNlIGl0IHdpdGhcbiAqL1xuZnVuY3Rpb24gcmVuYW1lS2V5IChpbnB1dCwgaW5LZXksIG91dEtleSkge1xuICBpZiAoXy5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHJlbmFtZUtleShpdGVtLCBpbktleSwgb3V0S2V5KSk7XG4gIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KGlucHV0KSkge1xuICAgIHJldHVybiBfLnJlZHVjZShpbnB1dCwgKHJlc3VsdE9iaiwgdmFsdWUsIGtleSkgPT4gKHtcbiAgICAgIC4uLnJlc3VsdE9iaixcbiAgICAgIFtrZXkgPT09IGluS2V5ID8gb3V0S2V5IDoga2V5XTogcmVuYW1lS2V5KHZhbHVlLCBpbktleSwgb3V0S2V5KSxcbiAgICB9KSwge30pO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5leHBvcnQge1xuICBjb25maWd1cmVBcHAsIGlzUGFja2FnZU9yQnVuZGxlLCBnZXRDb29yZERlZmF1bHQsIGdldFN3aXBlVG91Y2hEdXJhdGlvbiwgcmVuYW1lS2V5LFxufTtcbiJdLCJmaWxlIjoibGliL2Jhc2Vkcml2ZXIvaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
