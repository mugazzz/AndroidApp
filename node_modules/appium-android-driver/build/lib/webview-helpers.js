"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CHROMIUM_WIN = exports.WEBVIEW_BASE = exports.WEBVIEW_WIN = exports.NATIVE_WIN = exports.helpers = exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireDefault(require("./logger"));

var _asyncbox = require("asyncbox");

const NATIVE_WIN = "NATIVE_APP";
exports.NATIVE_WIN = NATIVE_WIN;
const WEBVIEW_WIN = "WEBVIEW";
exports.WEBVIEW_WIN = WEBVIEW_WIN;
const WEBVIEW_BASE = `${WEBVIEW_WIN}_`;
exports.WEBVIEW_BASE = WEBVIEW_BASE;
const WEBVIEW_REGEXP = new RegExp(`@?webview_devtools_remote_(\\d+)`);
const WEBVIEW_PID_REGEXP = new RegExp(`${WEBVIEW_BASE}(\\d+)`);
const CHROMIUM_WIN = "CHROMIUM";
exports.CHROMIUM_WIN = CHROMIUM_WIN;
const CROSSWALK_SOCKET_SUFFIX = "_devtools_remote";
const CROSSWALK_REGEXP_STRING = `(\\S*)${CROSSWALK_SOCKET_SUFFIX}`;
const CROSSWALK_REGEXP = new RegExp(`@${CROSSWALK_REGEXP_STRING}`);
const CROSSWALK_PROCESS_REGEXP = new RegExp(WEBVIEW_BASE + CROSSWALK_REGEXP_STRING);
let helpers = {};
exports.helpers = helpers;

function webviewsFromProcs(_x, _x2) {
  return _webviewsFromProcs.apply(this, arguments);
}

function _webviewsFromProcs() {
  _webviewsFromProcs = (0, _asyncToGenerator2.default)(function* (adb, deviceSocket) {
    let webviews = [];
    let out = yield adb.shell(["cat", "/proc/net/unix"]);
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = out.split("\n")[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        let line = _step3.value;
        line = line.trim();

        if (deviceSocket) {
          if (line.indexOf(`@${deviceSocket}`) === line.length - deviceSocket.length - 1) {
            if (deviceSocket === "chrome_devtools_remote") {
              webviews.push(CHROMIUM_WIN);
              continue;
            }
          }
        }

        let webviewPid;
        let crosswalkWebviewSocket;

        if (webviewPid = line.match(WEBVIEW_REGEXP)) {
          webviews.push(`${WEBVIEW_BASE}${webviewPid[1]}`);
        } else if (crosswalkWebviewSocket = line.match(CROSSWALK_REGEXP)) {
          if (deviceSocket) {
            if (crosswalkWebviewSocket[0].slice(1) === deviceSocket) {
              webviews.push(`${WEBVIEW_BASE}${crosswalkWebviewSocket[1]}`);
            }
          } else {
            webviews.push(`${WEBVIEW_BASE}${crosswalkWebviewSocket[1]}${CROSSWALK_SOCKET_SUFFIX}`);
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return _lodash.default.uniq(webviews);
  });
  return _webviewsFromProcs.apply(this, arguments);
}

helpers.procFromWebview = function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (adb, webview) {
    if (webview.match(WEBVIEW_PID_REGEXP) === null) {
      let processName = webview.match(CROSSWALK_PROCESS_REGEXP);

      if (processName === null) {
        throw new Error(`Could not find process name for webview ${webview}`);
      }

      return processName[1];
    }

    let pid = webview.match(/\d+$/);

    if (!pid) {
      throw new Error(`Could not find PID for webview ${webview}`);
    }

    pid = pid[0];

    _logger.default.debug(`${webview} mapped to pid ${pid}`);

    _logger.default.debug("Getting process name for webview");

    let out = yield adb.shell("ps");
    let pkg = "unknown";
    let lines = out.split(/\r?\n/);
    const fullHeader = lines[0].trim();
    const header = fullHeader.split(/\s+/);
    const pidColumn = header.indexOf('PID');
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        let line = _step.value;
        const entries = line.trim().split(/\s+/);
        const pidEntry = entries[pidColumn];

        if (pidEntry === pid) {
          pkg = _lodash.default.last(entries);

          _logger.default.debug(`Parsed pid: '${pidEntry}' pkg: '${pkg}' from`);

          _logger.default.debug(`    ${fullHeader}`);

          _logger.default.debug(`    ${line}`);

          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    _logger.default.debug(`Returning process name: '${pkg}'`);

    return pkg;
  });

  return function (_x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

helpers.getWebviews = function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* (adb, deviceSocket) {
    _logger.default.debug("Getting a list of available webviews");

    let webviews = yield webviewsFromProcs(adb, deviceSocket);

    if (deviceSocket) {
      return webviews;
    }

    webviews = yield (0, _asyncbox.asyncmap)(webviews, function () {
      var _ref3 = (0, _asyncToGenerator2.default)(function* (webviewName) {
        let pkg = yield helpers.procFromWebview(adb, webviewName);
        return WEBVIEW_BASE + pkg;
      });

      return function (_x7) {
        return _ref3.apply(this, arguments);
      };
    }());

    _logger.default.debug(`Found webviews: ${JSON.stringify(webviews)}`);

    return webviews;
  });

  return function (_x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();

helpers.decorateChromeOptions = function (caps, opts, deviceId) {
  if (opts.chromeOptions) {
    if (opts.chromeOptions.Arguments) {
      opts.chromeOptions.args = [...(opts.chromeOptions.args || []), ...opts.chromeOptions.Arguments];
      delete opts.chromeOptions.Arguments;
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _lodash.default.toPairs(opts.chromeOptions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        let _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
            opt = _step2$value[0],
            val = _step2$value[1];

        if (_lodash.default.isUndefined(caps.chromeOptions[opt])) {
          caps.chromeOptions[opt] = val;
        } else {
          _logger.default.warn(`Cannot pass option ${caps.chromeOptions[opt]} because ` + "Appium needs it to make chromeDriver work");
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  caps.chromeOptions.androidDeviceSerial = deviceId;
  return caps;
};

var _default = helpers;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi93ZWJ2aWV3LWhlbHBlcnMuanMiXSwibmFtZXMiOlsiTkFUSVZFX1dJTiIsIldFQlZJRVdfV0lOIiwiV0VCVklFV19CQVNFIiwiV0VCVklFV19SRUdFWFAiLCJSZWdFeHAiLCJXRUJWSUVXX1BJRF9SRUdFWFAiLCJDSFJPTUlVTV9XSU4iLCJDUk9TU1dBTEtfU09DS0VUX1NVRkZJWCIsIkNST1NTV0FMS19SRUdFWFBfU1RSSU5HIiwiQ1JPU1NXQUxLX1JFR0VYUCIsIkNST1NTV0FMS19QUk9DRVNTX1JFR0VYUCIsImhlbHBlcnMiLCJ3ZWJ2aWV3c0Zyb21Qcm9jcyIsImFkYiIsImRldmljZVNvY2tldCIsIndlYnZpZXdzIiwib3V0Iiwic2hlbGwiLCJzcGxpdCIsImxpbmUiLCJ0cmltIiwiaW5kZXhPZiIsImxlbmd0aCIsInB1c2giLCJ3ZWJ2aWV3UGlkIiwiY3Jvc3N3YWxrV2Vidmlld1NvY2tldCIsIm1hdGNoIiwic2xpY2UiLCJfIiwidW5pcSIsInByb2NGcm9tV2VidmlldyIsIndlYnZpZXciLCJwcm9jZXNzTmFtZSIsIkVycm9yIiwicGlkIiwibG9nZ2VyIiwiZGVidWciLCJwa2ciLCJsaW5lcyIsImZ1bGxIZWFkZXIiLCJoZWFkZXIiLCJwaWRDb2x1bW4iLCJlbnRyaWVzIiwicGlkRW50cnkiLCJsYXN0IiwiZ2V0V2Vidmlld3MiLCJ3ZWJ2aWV3TmFtZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWNvcmF0ZUNocm9tZU9wdGlvbnMiLCJjYXBzIiwib3B0cyIsImRldmljZUlkIiwiY2hyb21lT3B0aW9ucyIsIkFyZ3VtZW50cyIsImFyZ3MiLCJ0b1BhaXJzIiwib3B0IiwidmFsIiwiaXNVbmRlZmluZWQiLCJ3YXJuIiwiYW5kcm9pZERldmljZVNlcmlhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLFVBQVUsR0FBRyxZQUFuQjs7QUFDQSxNQUFNQyxXQUFXLEdBQUcsU0FBcEI7O0FBQ0EsTUFBTUMsWUFBWSxHQUFJLEdBQUVELFdBQVksR0FBcEM7O0FBQ0EsTUFBTUUsY0FBYyxHQUFHLElBQUlDLE1BQUosQ0FBWSxrQ0FBWixDQUF2QjtBQUNBLE1BQU1DLGtCQUFrQixHQUFHLElBQUlELE1BQUosQ0FBWSxHQUFFRixZQUFhLFFBQTNCLENBQTNCO0FBQ0EsTUFBTUksWUFBWSxHQUFHLFVBQXJCOztBQUNBLE1BQU1DLHVCQUF1QixHQUFHLGtCQUFoQztBQUNBLE1BQU1DLHVCQUF1QixHQUFJLFNBQVFELHVCQUF3QixFQUFqRTtBQUNBLE1BQU1FLGdCQUFnQixHQUFHLElBQUlMLE1BQUosQ0FBWSxJQUFHSSx1QkFBd0IsRUFBdkMsQ0FBekI7QUFDQSxNQUFNRSx3QkFBd0IsR0FBRyxJQUFJTixNQUFKLENBQVdGLFlBQVksR0FBR00sdUJBQTFCLENBQWpDO0FBR0EsSUFBSUcsT0FBTyxHQUFHLEVBQWQ7OztTQVFlQyxpQjs7Ozs7dURBQWYsV0FBa0NDLEdBQWxDLEVBQXVDQyxZQUF2QyxFQUFxRDtBQUNuRCxRQUFJQyxRQUFRLEdBQUcsRUFBZjtBQUNBLFFBQUlDLEdBQUcsU0FBU0gsR0FBRyxDQUFDSSxLQUFKLENBQVUsQ0FBQyxLQUFELEVBQVEsZ0JBQVIsQ0FBVixDQUFoQjtBQUZtRDtBQUFBO0FBQUE7O0FBQUE7QUFHbkQsNEJBQWlCRCxHQUFHLENBQUNFLEtBQUosQ0FBVSxJQUFWLENBQWpCLG1JQUFrQztBQUFBLFlBQXpCQyxJQUF5QjtBQUNoQ0EsUUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUNDLElBQUwsRUFBUDs7QUFFQSxZQUFJTixZQUFKLEVBQWtCO0FBQ2hCLGNBQUlLLElBQUksQ0FBQ0UsT0FBTCxDQUFjLElBQUdQLFlBQWEsRUFBOUIsTUFBcUNLLElBQUksQ0FBQ0csTUFBTCxHQUFjUixZQUFZLENBQUNRLE1BQTNCLEdBQW9DLENBQTdFLEVBQWdGO0FBQzlFLGdCQUFJUixZQUFZLEtBQUssd0JBQXJCLEVBQStDO0FBQzdDQyxjQUFBQSxRQUFRLENBQUNRLElBQVQsQ0FBY2pCLFlBQWQ7QUFDQTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFJa0IsVUFBSjtBQUNBLFlBQUlDLHNCQUFKOztBQUNBLFlBQUtELFVBQVUsR0FBR0wsSUFBSSxDQUFDTyxLQUFMLENBQVd2QixjQUFYLENBQWxCLEVBQStDO0FBRzdDWSxVQUFBQSxRQUFRLENBQUNRLElBQVQsQ0FBZSxHQUFFckIsWUFBYSxHQUFFc0IsVUFBVSxDQUFDLENBQUQsQ0FBSSxFQUE5QztBQUNELFNBSkQsTUFJTyxJQUFLQyxzQkFBc0IsR0FBR04sSUFBSSxDQUFDTyxLQUFMLENBQVdqQixnQkFBWCxDQUE5QixFQUE2RDtBQUNsRSxjQUFJSyxZQUFKLEVBQWtCO0FBQ2hCLGdCQUFJVyxzQkFBc0IsQ0FBQyxDQUFELENBQXRCLENBQTBCRSxLQUExQixDQUFnQyxDQUFoQyxNQUF1Q2IsWUFBM0MsRUFBeUQ7QUFDdkRDLGNBQUFBLFFBQVEsQ0FBQ1EsSUFBVCxDQUFlLEdBQUVyQixZQUFhLEdBQUV1QixzQkFBc0IsQ0FBQyxDQUFELENBQUksRUFBMUQ7QUFDRDtBQUNGLFdBSkQsTUFJTztBQUNMVixZQUFBQSxRQUFRLENBQUNRLElBQVQsQ0FBZSxHQUFFckIsWUFBYSxHQUFFdUIsc0JBQXNCLENBQUMsQ0FBRCxDQUFJLEdBQUVsQix1QkFBd0IsRUFBcEY7QUFDRDtBQUNGO0FBQ0Y7QUE5QmtEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBK0JuRCxXQUFPcUIsZ0JBQUVDLElBQUYsQ0FBT2QsUUFBUCxDQUFQO0FBQ0QsRzs7OztBQU9ESixPQUFPLENBQUNtQixlQUFSO0FBQUEsNkNBQTBCLFdBQWdCakIsR0FBaEIsRUFBcUJrQixPQUFyQixFQUE4QjtBQUN0RCxRQUFJQSxPQUFPLENBQUNMLEtBQVIsQ0FBY3JCLGtCQUFkLE1BQXNDLElBQTFDLEVBQWdEO0FBQzlDLFVBQUkyQixXQUFXLEdBQUdELE9BQU8sQ0FBQ0wsS0FBUixDQUFjaEIsd0JBQWQsQ0FBbEI7O0FBQ0EsVUFBSXNCLFdBQVcsS0FBSyxJQUFwQixFQUEwQjtBQUN4QixjQUFNLElBQUlDLEtBQUosQ0FBVywyQ0FBMENGLE9BQVEsRUFBN0QsQ0FBTjtBQUNEOztBQUNELGFBQU9DLFdBQVcsQ0FBQyxDQUFELENBQWxCO0FBQ0Q7O0FBR0QsUUFBSUUsR0FBRyxHQUFHSCxPQUFPLENBQUNMLEtBQVIsQ0FBYyxNQUFkLENBQVY7O0FBQ0EsUUFBSSxDQUFDUSxHQUFMLEVBQVU7QUFDUixZQUFNLElBQUlELEtBQUosQ0FBVyxrQ0FBaUNGLE9BQVEsRUFBcEQsQ0FBTjtBQUNEOztBQUNERyxJQUFBQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQyxDQUFELENBQVQ7O0FBQ0FDLG9CQUFPQyxLQUFQLENBQWMsR0FBRUwsT0FBUSxrQkFBaUJHLEdBQUksRUFBN0M7O0FBQ0FDLG9CQUFPQyxLQUFQLENBQWEsa0NBQWI7O0FBQ0EsUUFBSXBCLEdBQUcsU0FBU0gsR0FBRyxDQUFDSSxLQUFKLENBQVUsSUFBVixDQUFoQjtBQUNBLFFBQUlvQixHQUFHLEdBQUcsU0FBVjtBQUNBLFFBQUlDLEtBQUssR0FBR3RCLEdBQUcsQ0FBQ0UsS0FBSixDQUFVLE9BQVYsQ0FBWjtBQVFBLFVBQU1xQixVQUFVLEdBQUdELEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2xCLElBQVQsRUFBbkI7QUFDQSxVQUFNb0IsTUFBTSxHQUFHRCxVQUFVLENBQUNyQixLQUFYLENBQWlCLEtBQWpCLENBQWY7QUFDQSxVQUFNdUIsU0FBUyxHQUFHRCxNQUFNLENBQUNuQixPQUFQLENBQWUsS0FBZixDQUFsQjtBQTdCc0Q7QUFBQTtBQUFBOztBQUFBO0FBK0J0RCwyQkFBaUJpQixLQUFqQiw4SEFBd0I7QUFBQSxZQUFmbkIsSUFBZTtBQUN0QixjQUFNdUIsT0FBTyxHQUFHdkIsSUFBSSxDQUFDQyxJQUFMLEdBQVlGLEtBQVosQ0FBa0IsS0FBbEIsQ0FBaEI7QUFDQSxjQUFNeUIsUUFBUSxHQUFHRCxPQUFPLENBQUNELFNBQUQsQ0FBeEI7O0FBQ0EsWUFBSUUsUUFBUSxLQUFLVCxHQUFqQixFQUFzQjtBQUNwQkcsVUFBQUEsR0FBRyxHQUFHVCxnQkFBRWdCLElBQUYsQ0FBT0YsT0FBUCxDQUFOOztBQUNBUCwwQkFBT0MsS0FBUCxDQUFjLGdCQUFlTyxRQUFTLFdBQVVOLEdBQUksUUFBcEQ7O0FBQ0FGLDBCQUFPQyxLQUFQLENBQWMsT0FBTUcsVUFBVyxFQUEvQjs7QUFDQUosMEJBQU9DLEtBQVAsQ0FBYyxPQUFNakIsSUFBSyxFQUF6Qjs7QUFFQTtBQUNEO0FBQ0Y7QUExQ3FEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBNEN0RGdCLG9CQUFPQyxLQUFQLENBQWMsNEJBQTJCQyxHQUFJLEdBQTdDOztBQUNBLFdBQU9BLEdBQVA7QUFDRCxHQTlDRDs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFvREExQixPQUFPLENBQUNrQyxXQUFSO0FBQUEsOENBQXNCLFdBQWdCaEMsR0FBaEIsRUFBcUJDLFlBQXJCLEVBQW1DO0FBQ3ZEcUIsb0JBQU9DLEtBQVAsQ0FBYSxzQ0FBYjs7QUFDQSxRQUFJckIsUUFBUSxTQUFTSCxpQkFBaUIsQ0FBQ0MsR0FBRCxFQUFNQyxZQUFOLENBQXRDOztBQUVBLFFBQUlBLFlBQUosRUFBa0I7QUFDaEIsYUFBT0MsUUFBUDtBQUNEOztBQUVEQSxJQUFBQSxRQUFRLFNBQVMsd0JBQVNBLFFBQVQ7QUFBQSxrREFBbUIsV0FBTytCLFdBQVAsRUFBdUI7QUFDekQsWUFBSVQsR0FBRyxTQUFTMUIsT0FBTyxDQUFDbUIsZUFBUixDQUF3QmpCLEdBQXhCLEVBQTZCaUMsV0FBN0IsQ0FBaEI7QUFDQSxlQUFPNUMsWUFBWSxHQUFHbUMsR0FBdEI7QUFDRCxPQUhnQjs7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUFqQjs7QUFJQUYsb0JBQU9DLEtBQVAsQ0FBYyxtQkFBa0JXLElBQUksQ0FBQ0MsU0FBTCxDQUFlakMsUUFBZixDQUF5QixFQUF6RDs7QUFDQSxXQUFPQSxRQUFQO0FBQ0QsR0FkRDs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnQkFKLE9BQU8sQ0FBQ3NDLHFCQUFSLEdBQWdDLFVBQVVDLElBQVYsRUFBZ0JDLElBQWhCLEVBQXNCQyxRQUF0QixFQUFnQztBQUU5RCxNQUFJRCxJQUFJLENBQUNFLGFBQVQsRUFBd0I7QUFDdEIsUUFBSUYsSUFBSSxDQUFDRSxhQUFMLENBQW1CQyxTQUF2QixFQUFrQztBQUVoQ0gsTUFBQUEsSUFBSSxDQUFDRSxhQUFMLENBQW1CRSxJQUFuQixHQUEwQixDQUFDLElBQUlKLElBQUksQ0FBQ0UsYUFBTCxDQUFtQkUsSUFBbkIsSUFBMkIsRUFBL0IsQ0FBRCxFQUFxQyxHQUFHSixJQUFJLENBQUNFLGFBQUwsQ0FBbUJDLFNBQTNELENBQTFCO0FBQ0EsYUFBT0gsSUFBSSxDQUFDRSxhQUFMLENBQW1CQyxTQUExQjtBQUNEOztBQUxxQjtBQUFBO0FBQUE7O0FBQUE7QUFNdEIsNEJBQXVCMUIsZ0JBQUU0QixPQUFGLENBQVVMLElBQUksQ0FBQ0UsYUFBZixDQUF2QixtSUFBc0Q7QUFBQTtBQUFBLFlBQTVDSSxHQUE0QztBQUFBLFlBQXZDQyxHQUF1Qzs7QUFDcEQsWUFBSTlCLGdCQUFFK0IsV0FBRixDQUFjVCxJQUFJLENBQUNHLGFBQUwsQ0FBbUJJLEdBQW5CLENBQWQsQ0FBSixFQUE0QztBQUMxQ1AsVUFBQUEsSUFBSSxDQUFDRyxhQUFMLENBQW1CSSxHQUFuQixJQUEwQkMsR0FBMUI7QUFDRCxTQUZELE1BRU87QUFDTHZCLDBCQUFPeUIsSUFBUCxDQUFhLHNCQUFxQlYsSUFBSSxDQUFDRyxhQUFMLENBQW1CSSxHQUFuQixDQUF3QixXQUE5QyxHQUNBLDJDQURaO0FBRUQ7QUFDRjtBQWJxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBY3ZCOztBQUdEUCxFQUFBQSxJQUFJLENBQUNHLGFBQUwsQ0FBbUJRLG1CQUFuQixHQUF5Q1QsUUFBekM7QUFDQSxTQUFPRixJQUFQO0FBQ0QsQ0FyQkQ7O2VBdUJldkMsTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IGFzeW5jbWFwIH0gZnJvbSAnYXN5bmNib3gnO1xuXG5jb25zdCBOQVRJVkVfV0lOID0gXCJOQVRJVkVfQVBQXCI7XG5jb25zdCBXRUJWSUVXX1dJTiA9IFwiV0VCVklFV1wiO1xuY29uc3QgV0VCVklFV19CQVNFID0gYCR7V0VCVklFV19XSU59X2A7XG5jb25zdCBXRUJWSUVXX1JFR0VYUCA9IG5ldyBSZWdFeHAoYEA/d2Vidmlld19kZXZ0b29sc19yZW1vdGVfKFxcXFxkKylgKTtcbmNvbnN0IFdFQlZJRVdfUElEX1JFR0VYUCA9IG5ldyBSZWdFeHAoYCR7V0VCVklFV19CQVNFfShcXFxcZCspYCk7XG5jb25zdCBDSFJPTUlVTV9XSU4gPSBcIkNIUk9NSVVNXCI7XG5jb25zdCBDUk9TU1dBTEtfU09DS0VUX1NVRkZJWCA9IFwiX2RldnRvb2xzX3JlbW90ZVwiO1xuY29uc3QgQ1JPU1NXQUxLX1JFR0VYUF9TVFJJTkcgPSBgKFxcXFxTKikke0NST1NTV0FMS19TT0NLRVRfU1VGRklYfWA7XG5jb25zdCBDUk9TU1dBTEtfUkVHRVhQID0gbmV3IFJlZ0V4cChgQCR7Q1JPU1NXQUxLX1JFR0VYUF9TVFJJTkd9YCk7XG5jb25zdCBDUk9TU1dBTEtfUFJPQ0VTU19SRUdFWFAgPSBuZXcgUmVnRXhwKFdFQlZJRVdfQkFTRSArIENST1NTV0FMS19SRUdFWFBfU1RSSU5HKTtcblxuXG5sZXQgaGVscGVycyA9IHt9O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGdldHMgYSBsaXN0IG9mIGFuZHJvaWQgc3lzdGVtIHByb2Nlc3NlcyBhbmQgcmV0dXJucyBvbmVzXG4vLyB0aGF0IGxvb2sgbGlrZSB3ZWJ2aWV3cywgd2l0aCB0aGUgYXBwcm9wcmlhdGUgd2VidmlldyBwcmVmaXggYW5kIHRoZWlyIFBJRC5cbi8vIElmIHdlIHBhc3MgaW4gYSBkZXZpY2VTb2NrZXQsIHdlIG9ubHkgYXR0ZW1wdCB0byBmaW5kIHdlYnZpZXdzIHdoaWNoIG1hdGNoXG4vLyB0aGF0IHNvY2tldCBuYW1lICh0aGlzIGlzIGZvciBhcHBzIHdoaWNoIGVtYmVkIENocm9taXVtLCB3aGljaCBpc24ndCB0aGVcbi8vIHNhbWUgYXMgY2hyb21lLWJhY2tlZCB3ZWJ2aWV3cylcbi8vIFRPRE86IHNvbWUgb2YgdGhpcyBmdW5jdGlvbiBiZWxvbmdzIGluIGFwcGl1bS1hZGJcbmFzeW5jIGZ1bmN0aW9uIHdlYnZpZXdzRnJvbVByb2NzIChhZGIsIGRldmljZVNvY2tldCkge1xuICBsZXQgd2Vidmlld3MgPSBbXTtcbiAgbGV0IG91dCA9IGF3YWl0IGFkYi5zaGVsbChbXCJjYXRcIiwgXCIvcHJvYy9uZXQvdW5peFwiXSk7XG4gIGZvciAobGV0IGxpbmUgb2Ygb3V0LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgbGluZSA9IGxpbmUudHJpbSgpO1xuXG4gICAgaWYgKGRldmljZVNvY2tldCkge1xuICAgICAgaWYgKGxpbmUuaW5kZXhPZihgQCR7ZGV2aWNlU29ja2V0fWApID09PSBsaW5lLmxlbmd0aCAtIGRldmljZVNvY2tldC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChkZXZpY2VTb2NrZXQgPT09IFwiY2hyb21lX2RldnRvb2xzX3JlbW90ZVwiKSB7XG4gICAgICAgICAgd2Vidmlld3MucHVzaChDSFJPTUlVTV9XSU4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdlYnZpZXdQaWQ7XG4gICAgbGV0IGNyb3Nzd2Fsa1dlYnZpZXdTb2NrZXQ7XG4gICAgaWYgKCh3ZWJ2aWV3UGlkID0gbGluZS5tYXRjaChXRUJWSUVXX1JFR0VYUCkpKSB7XG4gICAgICAvLyBmb3IgbXVsdGlwbGUgd2Vidmlld3MgYSBsaXN0IG9mICdXRUJWSUVXXzxpbmRleD4nIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgIC8vIHdoZXJlIDxpbmRleD4gaXMgemVybyBiYXNlZCAoc2FtZSBpcyBpbiBzZWxlbmRyb2lkKVxuICAgICAgd2Vidmlld3MucHVzaChgJHtXRUJWSUVXX0JBU0V9JHt3ZWJ2aWV3UGlkWzFdfWApO1xuICAgIH0gZWxzZSBpZiAoKGNyb3Nzd2Fsa1dlYnZpZXdTb2NrZXQgPSBsaW5lLm1hdGNoKENST1NTV0FMS19SRUdFWFApKSkge1xuICAgICAgaWYgKGRldmljZVNvY2tldCkge1xuICAgICAgICBpZiAoY3Jvc3N3YWxrV2Vidmlld1NvY2tldFswXS5zbGljZSgxKSA9PT0gZGV2aWNlU29ja2V0KSB7XG4gICAgICAgICAgd2Vidmlld3MucHVzaChgJHtXRUJWSUVXX0JBU0V9JHtjcm9zc3dhbGtXZWJ2aWV3U29ja2V0WzFdfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ZWJ2aWV3cy5wdXNoKGAke1dFQlZJRVdfQkFTRX0ke2Nyb3Nzd2Fsa1dlYnZpZXdTb2NrZXRbMV19JHtDUk9TU1dBTEtfU09DS0VUX1NVRkZJWH1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIF8udW5pcSh3ZWJ2aWV3cyk7XG59XG5cbi8vIFRha2UgYSB3ZWJ2aWV3IG5hbWUgbGlrZSBXRUJWSUVXXzQyOTYgYW5kIHVzZSAnYWRiIHNoZWxsIHBzJyB0byBmaWd1cmUgb3V0XG4vLyB3aGljaCBhcHAgcGFja2FnZSBpcyBhc3NvY2lhdGVkIHdpdGggdGhhdCB3ZWJ2aWV3LiBPbmUgb2YgdGhlIHJlYXNvbnMgd2Vcbi8vIHdhbnQgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgd2UncmUgbGlzdGluZyB3ZWJ2aWV3cyBmb3IgdGhlIGFjdHVhbCBBVVQsXG4vLyBub3Qgc29tZSBvdGhlciBydW5uaW5nIGFwcFxuLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgY2FsbGVkIHByb2NGcm9tUGlkIGFuZCBleGlzdCBpbiBhcHBpdW0tYWRiXG5oZWxwZXJzLnByb2NGcm9tV2VidmlldyA9IGFzeW5jIGZ1bmN0aW9uIChhZGIsIHdlYnZpZXcpIHtcbiAgaWYgKHdlYnZpZXcubWF0Y2goV0VCVklFV19QSURfUkVHRVhQKSA9PT0gbnVsbCkge1xuICAgIGxldCBwcm9jZXNzTmFtZSA9IHdlYnZpZXcubWF0Y2goQ1JPU1NXQUxLX1BST0NFU1NfUkVHRVhQKTtcbiAgICBpZiAocHJvY2Vzc05hbWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcHJvY2VzcyBuYW1lIGZvciB3ZWJ2aWV3ICR7d2Vidmlld31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NOYW1lWzFdO1xuICB9XG5cbiAgLy8gd2Vidmlld19kZXZ0b29sc19yZW1vdGVfNDI5NiA9PiA0Mjk2XG4gIGxldCBwaWQgPSB3ZWJ2aWV3Lm1hdGNoKC9cXGQrJC8pO1xuICBpZiAoIXBpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgUElEIGZvciB3ZWJ2aWV3ICR7d2Vidmlld31gKTtcbiAgfVxuICBwaWQgPSBwaWRbMF07XG4gIGxvZ2dlci5kZWJ1ZyhgJHt3ZWJ2aWV3fSBtYXBwZWQgdG8gcGlkICR7cGlkfWApO1xuICBsb2dnZXIuZGVidWcoXCJHZXR0aW5nIHByb2Nlc3MgbmFtZSBmb3Igd2Vidmlld1wiKTtcbiAgbGV0IG91dCA9IGF3YWl0IGFkYi5zaGVsbChcInBzXCIpO1xuICBsZXQgcGtnID0gXCJ1bmtub3duXCI7XG4gIGxldCBsaW5lcyA9IG91dC5zcGxpdCgvXFxyP1xcbi8pO1xuXG4gIC8qIE91dHB1dCBvZiBwcyBpcyBsaWtlOlxuICAgVVNFUiAgICAgICBQSUQgIFBQSUQgIFZTSVpFICBSU1MgICBXQ0hBTiAgICBQQyAgICAgICAgIE5BTUUgIF9vcl9cbiAgIFVTRVIgICAgICAgUElEICBQUElEICBWU1ogICAgUlNTICAgV0NIQU4gICAgQUREUiAgICAgUyBOQU1FXG4gICB1MF9hMTM2ICAgNjI0OCAgMTc5ICAgOTQ2MDAwIDQ4MTQ0IGZmZmZmZmZmIDQwMDU5MDNlIFIgY29tLmV4YW1wbGUudGVzdFxuICAgdTBfYTEzNiAgIDYyNDkgIDE3OSAgIDk0NjAwMCA0ODE0NCBmZmZmZmZmZiAgICAgICAgICBSIGNvbS5leGFtcGxlLnRlc3RcbiAgKi9cbiAgY29uc3QgZnVsbEhlYWRlciA9IGxpbmVzWzBdLnRyaW0oKTtcbiAgY29uc3QgaGVhZGVyID0gZnVsbEhlYWRlci5zcGxpdCgvXFxzKy8pO1xuICBjb25zdCBwaWRDb2x1bW4gPSBoZWFkZXIuaW5kZXhPZignUElEJyk7XG5cbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBsaW5lLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICAgIGNvbnN0IHBpZEVudHJ5ID0gZW50cmllc1twaWRDb2x1bW5dO1xuICAgIGlmIChwaWRFbnRyeSA9PT0gcGlkKSB7XG4gICAgICBwa2cgPSBfLmxhc3QoZW50cmllcyk7XG4gICAgICBsb2dnZXIuZGVidWcoYFBhcnNlZCBwaWQ6ICcke3BpZEVudHJ5fScgcGtnOiAnJHtwa2d9JyBmcm9tYCk7XG4gICAgICBsb2dnZXIuZGVidWcoYCAgICAke2Z1bGxIZWFkZXJ9YCk7XG4gICAgICBsb2dnZXIuZGVidWcoYCAgICAke2xpbmV9YCk7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGxvZ2dlci5kZWJ1ZyhgUmV0dXJuaW5nIHByb2Nlc3MgbmFtZTogJyR7cGtnfSdgKTtcbiAgcmV0dXJuIHBrZztcbn07XG5cbi8vIEdldCBhIGxpc3Qgb2YgYXZhaWxhYmxlIHdlYnZpZXdzIGJ5IGludHJvc3BlY3RpbmcgcHJvY2Vzc2VzIHdpdGggYWRiLCB3aGVyZVxuLy8gd2Vidmlld3MgYXJlIGxpc3RlZC4gSXQncyBwb3NzaWJsZSB0byBwYXNzIGluIGEgJ2RldmljZVNvY2tldCcgYXJnLCB3aGljaFxuLy8gbGltaXRzIHRoZSB3ZWJ2aWV3IHBvc3NpYmlsaXRpZXMgdG8gdGhlIG9uZSBydW5uaW5nIG9uIHRoZSBDaHJvbWl1bSBkZXZ0b29sc1xuLy8gc29ja2V0IHdlJ3JlIGludGVyZXN0ZWQgaW4gKHNlZSBub3RlIG9uIHdlYnZpZXdzRnJvbVByb2NzKVxuaGVscGVycy5nZXRXZWJ2aWV3cyA9IGFzeW5jIGZ1bmN0aW9uIChhZGIsIGRldmljZVNvY2tldCkge1xuICBsb2dnZXIuZGVidWcoXCJHZXR0aW5nIGEgbGlzdCBvZiBhdmFpbGFibGUgd2Vidmlld3NcIik7XG4gIGxldCB3ZWJ2aWV3cyA9IGF3YWl0IHdlYnZpZXdzRnJvbVByb2NzKGFkYiwgZGV2aWNlU29ja2V0KTtcblxuICBpZiAoZGV2aWNlU29ja2V0KSB7XG4gICAgcmV0dXJuIHdlYnZpZXdzO1xuICB9XG5cbiAgd2Vidmlld3MgPSBhd2FpdCBhc3luY21hcCh3ZWJ2aWV3cywgYXN5bmMgKHdlYnZpZXdOYW1lKSA9PiB7XG4gICAgbGV0IHBrZyA9IGF3YWl0IGhlbHBlcnMucHJvY0Zyb21XZWJ2aWV3KGFkYiwgd2Vidmlld05hbWUpO1xuICAgIHJldHVybiBXRUJWSUVXX0JBU0UgKyBwa2c7XG4gIH0pO1xuICBsb2dnZXIuZGVidWcoYEZvdW5kIHdlYnZpZXdzOiAke0pTT04uc3RyaW5naWZ5KHdlYnZpZXdzKX1gKTtcbiAgcmV0dXJuIHdlYnZpZXdzO1xufTtcblxuaGVscGVycy5kZWNvcmF0ZUNocm9tZU9wdGlvbnMgPSBmdW5jdGlvbiAoY2Fwcywgb3B0cywgZGV2aWNlSWQpIHtcbiAgLy8gYWRkIG9wdGlvbnMgZnJvbSBhcHBpdW0gc2Vzc2lvbiBjYXBzXG4gIGlmIChvcHRzLmNocm9tZU9wdGlvbnMpIHtcbiAgICBpZiAob3B0cy5jaHJvbWVPcHRpb25zLkFyZ3VtZW50cykge1xuICAgICAgLy8gbWVyZ2UgYEFyZ3VtZW50c2AgYW5kIGBhcmdzYFxuICAgICAgb3B0cy5jaHJvbWVPcHRpb25zLmFyZ3MgPSBbLi4uKG9wdHMuY2hyb21lT3B0aW9ucy5hcmdzIHx8IFtdKSwgLi4ub3B0cy5jaHJvbWVPcHRpb25zLkFyZ3VtZW50c107XG4gICAgICBkZWxldGUgb3B0cy5jaHJvbWVPcHRpb25zLkFyZ3VtZW50cztcbiAgICB9XG4gICAgZm9yIChsZXQgW29wdCwgdmFsXSBvZiBfLnRvUGFpcnMob3B0cy5jaHJvbWVPcHRpb25zKSkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoY2Fwcy5jaHJvbWVPcHRpb25zW29wdF0pKSB7XG4gICAgICAgIGNhcHMuY2hyb21lT3B0aW9uc1tvcHRdID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYENhbm5vdCBwYXNzIG9wdGlvbiAke2NhcHMuY2hyb21lT3B0aW9uc1tvcHRdfSBiZWNhdXNlIGAgK1xuICAgICAgICAgICAgICAgICAgICBcIkFwcGl1bSBuZWVkcyBpdCB0byBtYWtlIGNocm9tZURyaXZlciB3b3JrXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBkZXZpY2UgaWQgZnJvbSBhZGJcbiAgY2Fwcy5jaHJvbWVPcHRpb25zLmFuZHJvaWREZXZpY2VTZXJpYWwgPSBkZXZpY2VJZDtcbiAgcmV0dXJuIGNhcHM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBoZWxwZXJzO1xuZXhwb3J0IHsgaGVscGVycywgTkFUSVZFX1dJTiwgV0VCVklFV19XSU4sIFdFQlZJRVdfQkFTRSwgQ0hST01JVU1fV0lOIH07XG4iXSwiZmlsZSI6ImxpYi93ZWJ2aWV3LWhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
