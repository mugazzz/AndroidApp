"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UiAutomator = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _events = _interopRequireDefault(require("events"));

var _appiumSupport = require("appium-support");

const log = _appiumSupport.logger.getLogger('UiAutomator');

class UiAutomator extends _events.default.EventEmitter {
  constructor(adb) {
    if (!adb) {
      log.errorAndThrow('adb is required to instantiate UiAutomator');
    }

    super();
    this.adb = adb;
    this.tempPath = '/data/local/tmp/';
  }

  start(uiAutomatorBinaryPath, className, startDetector, ...extraParams) {
    var _this = this;

    return (0, _asyncToGenerator2.default)(function* () {
      let processIsAlive;

      try {
        log.debug('Starting UiAutomator');

        _this.changeState(UiAutomator.STATE_STARTING);

        log.debug('Parsing uiautomator jar');

        let jarName = _this.parseJarNameFromPath(uiAutomatorBinaryPath);

        yield _this.adb.push(uiAutomatorBinaryPath, _this.tempPath);
        yield _this.killUiAutomatorOnDevice();
        log.debug('Starting UIAutomator');
        let args = ['shell', 'uiautomator', 'runtest', jarName, '-c', className, ...extraParams];
        _this.proc = _this.adb.createSubProcess(args);

        _this.proc.on('exit', (code, signal) => {
          processIsAlive = false;

          if (_this.state !== UiAutomator.STATE_STOPPED && _this.state !== UiAutomator.STATE_STOPPING) {
            let msg = `UiAutomator exited unexpectedly with code ${code}, ` + `signal ${signal}`;
            log.error(msg);
          } else if (_this.state === UiAutomator.STATE_STOPPING) {
            log.debug('UiAutomator shut down normally');
          }

          _this.changeState(UiAutomator.STATE_STOPPED);
        });

        yield _this.proc.start(startDetector);
        processIsAlive = true;

        _this.changeState(UiAutomator.STATE_ONLINE);

        return _this.proc;
      } catch (e) {
        _this.emit(UiAutomator.EVENT_ERROR, e);

        if (processIsAlive) {
          yield _this.killUiAutomatorOnDevice();
          yield _this.proc.stop();
        }

        log.errorAndThrow(e);
      }
    })();
  }

  shutdown() {
    var _this2 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      log.debug('Shutting down UiAutomator');

      if (_this2.state !== UiAutomator.STATE_STOPPED) {
        _this2.changeState(UiAutomator.STATE_STOPPING);

        yield _this2.proc.stop();
      }

      yield _this2.killUiAutomatorOnDevice();

      _this2.changeState(UiAutomator.STATE_STOPPED);
    })();
  }

  parseJarNameFromPath(binaryPath) {
    let reTest = /.*(\/|\\)(.*\.jar)/.exec(binaryPath);

    if (!reTest) {
      throw new Error(`Unable to parse jar name from ${binaryPath}`);
    }

    let jarName = reTest[2];
    log.debug(`Found jar name: '${jarName}'`);
    return jarName;
  }

  changeState(state) {
    log.debug(`Moving to state '${state}'`);
    this.state = state;
    this.emit(UiAutomator.EVENT_CHANGED, {
      state
    });
  }

  killUiAutomatorOnDevice() {
    var _this3 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      try {
        yield _this3.adb.killProcessesByName('uiautomator');
      } catch (e) {
        log.warn(`Error while killing uiAutomator: ${e}`);
      }
    })();
  }

}

exports.UiAutomator = UiAutomator;
UiAutomator.EVENT_ERROR = 'uiautomator_error';
UiAutomator.EVENT_CHANGED = 'stateChanged';
UiAutomator.STATE_STOPPING = 'stopping';
UiAutomator.STATE_STOPPED = 'stopped';
UiAutomator.STATE_STARTING = 'starting';
UiAutomator.STATE_ONLINE = 'online';
var _default = UiAutomator;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91aWF1dG9tYXRvci5qcyJdLCJuYW1lcyI6WyJsb2ciLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJVaUF1dG9tYXRvciIsImV2ZW50cyIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiYWRiIiwiZXJyb3JBbmRUaHJvdyIsInRlbXBQYXRoIiwic3RhcnQiLCJ1aUF1dG9tYXRvckJpbmFyeVBhdGgiLCJjbGFzc05hbWUiLCJzdGFydERldGVjdG9yIiwiZXh0cmFQYXJhbXMiLCJwcm9jZXNzSXNBbGl2ZSIsImRlYnVnIiwiY2hhbmdlU3RhdGUiLCJTVEFURV9TVEFSVElORyIsImphck5hbWUiLCJwYXJzZUphck5hbWVGcm9tUGF0aCIsInB1c2giLCJraWxsVWlBdXRvbWF0b3JPbkRldmljZSIsImFyZ3MiLCJwcm9jIiwiY3JlYXRlU3ViUHJvY2VzcyIsIm9uIiwiY29kZSIsInNpZ25hbCIsInN0YXRlIiwiU1RBVEVfU1RPUFBFRCIsIlNUQVRFX1NUT1BQSU5HIiwibXNnIiwiZXJyb3IiLCJTVEFURV9PTkxJTkUiLCJlIiwiZW1pdCIsIkVWRU5UX0VSUk9SIiwic3RvcCIsInNodXRkb3duIiwiYmluYXJ5UGF0aCIsInJlVGVzdCIsImV4ZWMiLCJFcnJvciIsIkVWRU5UX0NIQU5HRUQiLCJraWxsUHJvY2Vzc2VzQnlOYW1lIiwid2FybiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFHQSxNQUFNQSxHQUFHLEdBQUdDLHNCQUFPQyxTQUFQLENBQWlCLGFBQWpCLENBQVo7O0FBRUEsTUFBTUMsV0FBTixTQUEwQkMsZ0JBQU9DLFlBQWpDLENBQThDO0FBQzVDQyxFQUFBQSxXQUFXLENBQUVDLEdBQUYsRUFBTztBQUNoQixRQUFJLENBQUNBLEdBQUwsRUFBVTtBQUNSUCxNQUFBQSxHQUFHLENBQUNRLGFBQUosQ0FBa0IsNENBQWxCO0FBQ0Q7O0FBQ0Q7QUFDQSxTQUFLRCxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLRSxRQUFMLEdB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NUI7QUFDQXpDLFdBQVcsQ0FBQzRCLGNBQVosR0FBNkIsVUFBN0I7QUFDQTVCLFdBQVcsQ0FBQzJCLGFBQVosR0FBNEIsU0FBNUI7QUFDQTNCLFdBQVcsQ0FBQ2UsY0FBWixHQUE2QixVQUE3QjtBQUNBZixXQUFXLENBQUMrQixZQUFaLEdBQTJCLFFBQTNCO2VBSWUvQixXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuXG5cbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ1VpQXV0b21hdG9yJyk7XG5cbmNsYXNzIFVpQXV0b21hdG9yIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChhZGIpIHtcbiAgICBpZiAoIWFkYikge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coJ2FkYiBpcyByZXF1aXJlZCB0byBpbnN0YW50aWF0ZSBVaUF1dG9tYXRvcicpO1xuICAgIH1cbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYWRiID0gYWRiO1xuICAgIHRoaXMudGVtcFBhdGggPSAnL2RhdGEvbG9jYWwvdG1wLyc7XG4gIH1cblxuICBhc3luYyBzdGFydCAodWlBdXRvbWF0b3JCaW5hcnlQYXRoLCBjbGFzc05hbWUsIHN0YXJ0RGV0ZWN0b3IsIC4uLmV4dHJhUGFyYW1zKSB7XG4gICAgbGV0IHByb2Nlc3NJc0FsaXZlO1xuICAgIHRyeSB7XG4gICAgICBsb2cuZGVidWcoJ1N0YXJ0aW5nIFVpQXV0b21hdG9yJyk7XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFVpQXV0b21hdG9yLlNUQVRFX1NUQVJUSU5HKTtcblxuICAgICAgbG9nLmRlYnVnKCdQYXJzaW5nIHVpYXV0b21hdG9yIGphcicpO1xuICAgICAgLy8gZXhwZWN0aW5nIGEgcGF0aCBsaWtlIC9hZHMvYWRzL2Zvby5qYXIgb3IgXFxhc2RcXGFzZFxcZm9vLmphclxuICAgICAgbGV0IGphck5hbWUgPSB0aGlzLnBhcnNlSmFyTmFtZUZyb21QYXRoKHVpQXV0b21hdG9yQmluYXJ5UGF0aCk7XG4gICAgICBhd2FpdCB0aGlzLmFkYi5wdXNoKHVpQXV0b21hdG9yQmluYXJ5UGF0aCwgdGhpcy50ZW1wUGF0aCk7XG5cbiAgICAgIC8vIGtpbGxpbmcgYW55IHVpYXV0b21hdG9yIGV4aXN0aW5nIHByb2Nlc3Nlc1xuICAgICAgYXdhaXQgdGhpcy5raWxsVWlBdXRvbWF0b3JPbkRldmljZSgpO1xuXG4gICAgICBsb2cuZGVidWcoJ1N0YXJ0aW5nIFVJQXV0b21hdG9yJyk7XG4gICAgICBsZXQgYXJncyA9IFsnc2hlbGwnLCAndWlhdXRvbWF0b3InLCAncnVudGVzdCcsIGphck5hbWUsICctYycsIGNsYXNzTmFtZSwgLi4uZXh0cmFQYXJhbXNdO1xuICAgICAgdGhpcy5wcm9jID0gdGhpcy5hZGIuY3JlYXRlU3ViUHJvY2VzcyhhcmdzKTtcblxuICAgICAgLy8gaGFuZGxlIG91dC1vZi1ib3VuZCBleGl0IGJ5IHNpbXBseSBlbWl0dGluZyBhIHN0b3BwZWQgc3RhdGVcbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2xlYW51cFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gVWlBdXRvbWF0b3IuU1RBVEVfU1RPUFBFRCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gVWlBdXRvbWF0b3IuU1RBVEVfU1RPUFBJTkcpIHtcbiAgICAgICAgICBsZXQgbXNnID0gYFVpQXV0b21hdG9yIGV4aXRlZCB1bmV4cGVjdGVkbHkgd2l0aCBjb2RlICR7Y29kZX0sIGAgK1xuICAgICAgICAgICAgICAgICAgICBgc2lnbmFsICR7c2lnbmFsfWA7XG4gICAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gVWlBdXRvbWF0b3IuU1RBVEVfU1RPUFBJTkcpIHtcbiAgICAgICAgICBsb2cuZGVidWcoJ1VpQXV0b21hdG9yIHNodXQgZG93biBub3JtYWxseScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoVWlBdXRvbWF0b3IuU1RBVEVfU1RPUFBFRCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KHN0YXJ0RGV0ZWN0b3IpO1xuICAgICAgcHJvY2Vzc0lzQWxpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShVaUF1dG9tYXRvci5TVEFURV9PTkxJTkUpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvYztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmVtaXQoVWlBdXRvbWF0b3IuRVZFTlRfRVJST1IsIGUpO1xuICAgICAgaWYgKHByb2Nlc3NJc0FsaXZlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMua2lsbFVpQXV0b21hdG9yT25EZXZpY2UoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNodXRkb3duICgpIHtcbiAgICBsb2cuZGVidWcoJ1NodXR0aW5nIGRvd24gVWlBdXRvbWF0b3InKTtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gVWlBdXRvbWF0b3IuU1RBVEVfU1RPUFBFRCkge1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShVaUF1dG9tYXRvci5TVEFURV9TVE9QUElORyk7XG4gICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmtpbGxVaUF1dG9tYXRvck9uRGV2aWNlKCk7XG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShVaUF1dG9tYXRvci5TVEFURV9TVE9QUEVEKTtcbiAgfVxuXG4gIHBhcnNlSmFyTmFtZUZyb21QYXRoIChiaW5hcnlQYXRoKSB7XG4gICAgbGV0IHJlVGVzdCA9IC8uKihcXC98XFxcXCkoLipcXC5qYXIpLy5leGVjKGJpbmFyeVBhdGgpO1xuICAgIGlmICghcmVUZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBqYXIgbmFtZSBmcm9tICR7YmluYXJ5UGF0aH1gKTtcbiAgICB9XG4gICAgbGV0IGphck5hbWUgPSByZVRlc3RbMl07XG4gICAgbG9nLmRlYnVnKGBGb3VuZCBqYXIgbmFtZTogJyR7amFyTmFtZX0nYCk7XG4gICAgcmV0dXJuIGphck5hbWU7XG4gIH1cblxuICBjaGFuZ2VTdGF0ZSAoc3RhdGUpIHtcbiAgICBsb2cuZGVidWcoYE1vdmluZyB0byBzdGF0ZSAnJHtzdGF0ZX0nYCk7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZW1pdChVaUF1dG9tYXRvci5FVkVOVF9DSEFOR0VELCB7c3RhdGV9KTtcbiAgfVxuXG4gIGFzeW5jIGtpbGxVaUF1dG9tYXRvck9uRGV2aWNlICgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5hZGIua2lsbFByb2Nlc3Nlc0J5TmFtZSgndWlhdXRvbWF0b3InKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cud2FybihgRXJyb3Igd2hpbGUga2lsbGluZyB1aUF1dG9tYXRvcjogJHtlfWApO1xuICAgIH1cbiAgfVxuXG59XG5cblVpQXV0b21hdG9yLkVWRU5UX0VSUk9SID0gJ3VpYXV0b21hdG9yX2Vycm9yJztcblVpQXV0b21hdG9yLkVWRU5UX0NIQU5HRUQgPSAnc3RhdGVDaGFuZ2VkJztcblVpQXV0b21hdG9yLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcblVpQXV0b21hdG9yLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5VaUF1dG9tYXRvci5TVEFURV9TVEFSVElORyA9ICdzdGFydGluZyc7XG5VaUF1dG9tYXRvci5TVEFURV9PTkxJTkUgPSAnb25saW5lJztcblxuXG5leHBvcnQgeyBVaUF1dG9tYXRvciB9O1xuZXhwb3J0IGRlZmF1bHQgVWlBdXRvbWF0b3I7XG4iXSwiZmlsZSI6ImxpYi91aWF1dG9tYXRvci5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
