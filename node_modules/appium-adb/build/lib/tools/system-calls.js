"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ADB_EXEC_TIMEOUT = exports.default = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _shellQuote = require("shell-quote");

let systemCallMethods = {};
const DEFAULT_ADB_EXEC_TIMEOUT = 20000;
exports.DEFAULT_ADB_EXEC_TIMEOUT = DEFAULT_ADB_EXEC_TIMEOUT;
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
const DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp(`error: device ('.+' )?not found`, 'i');
const DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');
const CERTS_ROOT = '/system/etc/security/cacerts';
systemCallMethods.getSdkBinaryPath = _lodash.default.memoize(function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (binaryName) {
    _logger.default.info(`Checking whether ${binaryName} is present`);

    if (this.sdkRoot) {
      return yield this.getBinaryFromSdkRoot(binaryName);
    }

    _logger.default.warn(`The ANDROID_HOME environment variable is not set to the Android SDK ` + `root directory path. ANDROID_HOME is required for compatibility ` + `with SDK 23+. Checking along PATH for ${binaryName}.`);

    return yield this.getBinaryFromPath(binaryName);
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
systemCallMethods.getCommandForOS = _lodash.default.memoize(function () {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});
systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function (binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return `${binaryName}.bat`;
  }

  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return `${binaryName}.exe`;
  }

  return binaryName;
});
systemCallMethods.getBinaryFromSdkRoot = _lodash.default.memoize(function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* (binaryName) {
    let binaryLoc = null;
    binaryName = this.getBinaryNameForOS(binaryName);
    let binaryLocs = [_path.default.resolve(this.sdkRoot, "platform-tools", binaryName), _path.default.resolve(this.sdkRoot, "emulator", binaryName), _path.default.resolve(this.sdkRoot, "tools", binaryName), _path.default.resolve(this.sdkRoot, "tools", "bin", binaryName)];

    _lodash.default.forEach((yield (0, _helpers.getBuildToolsDirs)(this.sdkRoot)), dir => binaryLocs.push(_path.default.resolve(dir, binaryName)));

    for (var _i = 0; _i < binaryLocs.length; _i++) {
      let loc = binaryLocs[_i];

      if (yield _appiumSupport.fs.exists(loc)) {
        binaryLoc = loc;
        break;
      }
    }

    if (_lodash.default.isNull(binaryLoc)) {
      throw new Error(`Could not find ${binaryName} in ${binaryLocs}. ` + `Do you have the Android SDK installed at '${this.sdkRoot}'?`);
    }

    binaryLoc = binaryLoc.trim();

    _logger.default.info(`Using ${binaryName} from ${binaryLoc}`);

    return binaryLoc;
  });

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());

systemCallMethods.getBinaryFromPath = function () {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (binaryName) {
    let binaryLoc = null;
    let cmd = this.getCommandForOS();

    try {
      let _ref4 = yield (0, _teen_process.exec)(cmd, [binaryName]),
          stdout = _ref4.stdout;

      _logger.default.info(`Using ${binaryName} from ${stdout}`);

      binaryLoc = stdout.trim();
      return binaryLoc;
    } catch (e) {
      throw new Error(`Could not find ${binaryName} Please set the ANDROID_HOME ` + `environment variable with the Android SDK root directory path.`);
    }
  });

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}();

systemCallMethods.getConnectedDevices = (0, _asyncToGenerator2.default)(function* () {
  _logger.default.debug("Getting connected devices...");

  try {
    let _ref6 = yield (0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices'])),
        stdout = _ref6.stdout;

    let startingIndex = stdout.indexOf("List of devices");

    if (startingIndex === -1) {
      throw new Error(`Unexpected output while trying to get devices. output was: ${stdout}`);
    }

    stdout = stdout.slice(startingIndex);
    let devices = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = stdout.split("\n")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        let line = _step.value;

        if (line.trim() !== "" && line.indexOf("List of devices") === -1 && line.indexOf("adb server") === -1 && line.indexOf("* daemon") === -1 && line.indexOf("offline") === -1) {
          let lineInfo = line.split("\t");
          devices.push({
            udid: lineInfo[0],
            state: lineInfo[1]
          });
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    _logger.default.debug(`${devices.length} device(s) connected`);

    return devices;
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }
});

systemCallMethods.getDevicesWithRetry = function () {
  var _ref7 = (0, _asyncToGenerator2.default)(function* (timeoutMs = 20000) {
    var _this = this;

    let start = Date.now();

    _logger.default.debug("Trying to find a connected android device");

    let getDevices = function () {
      var _ref8 = (0, _asyncToGenerator2.default)(function* () {
        if (Date.now() - start > timeoutMs) {
          throw new Error("Could not find a connected Android device.");
        }

        try {
          let devices = yield _this.getConnectedDevices();

          if (devices.length < 1) {
            _logger.default.debug("Could not find devices, restarting adb server...");

            yield _this.restartAdb();
            yield (0, _asyncbox.sleep)(200);
            return yield getDevices();
          }

          return devices;
        } catch (e) {
          _logger.default.debug("Could not find devices, restarting adb server...");

          yield _this.restartAdb();
          yield (0, _asyncbox.sleep)(200);
          return yield getDevices();
        }
      });

      return function getDevices() {
        return _ref8.apply(this, arguments);
      };
    }();

    return yield getDevices();
  });

  return function () {
    return _ref7.apply(this, arguments);
  };
}();

systemCallMethods.restartAdb = (0, _asyncToGenerator2.default)(function* () {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    yield this.killServer();
  } catch (e) {
    _logger.default.error("Error killing ADB server, going to see if it's online anyway");
  }
});
systemCallMethods.killServer = (0, _asyncToGenerator2.default)(function* () {
  _logger.default.debug(`Killing adb server on port ${this.adbPort}`);

  yield (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'kill-server']);
});
systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize((0, _asyncToGenerator2.default)(function* () {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    yield _appiumSupport.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
}));

systemCallMethods.adbExecEmu = function () {
  var _ref12 = (0, _asyncToGenerator2.default)(function* (cmd) {
    yield this.verifyEmulatorConnected();
    yield this.resetTelnetAuthToken();
    yield this.adbExec(['emu', ...cmd]);
  });

  return function (_x4) {
    return _ref12.apply(this, arguments);
  };
}();

systemCallMethods.adbExec = function () {
  var _ref13 = (0, _asyncToGenerator2.default)(function* (cmd, opts = {}) {
    var _this2 = this;

    if (!cmd) {
      throw new Error("You need to pass in a command to adbExec()");
    }

    opts.timeout = opts.timeout || this.adbExecTimeout || DEFAULT_ADB_EXEC_TIMEOUT;

    let execFunc = function () {
      var _ref14 = (0, _asyncToGenerator2.default)(function* () {
        try {
          if (!(cmd instanceof Array)) {
            cmd = [cmd];
          }

          let args = _this2.executable.defaultArgs.concat(cmd);

          _logger.default.debug(`Running '${_this2.executable.path} ${(0, _shellQuote.quote)(args)}'`);

          let _ref15 = yield (0, _teen_process.exec)(_this2.executable.path, args, opts),
              stdout = _ref15.stdout;

          stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
          return stdout;
        } catch (e) {
          const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
          const protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
          const deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
          const deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

          if (protocolFaultError || deviceNotFoundError || deviceConnectingError) {
            _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

            yield (0, _asyncbox.sleep)(1000);
            yield _this2.getDevicesWithRetry();
          }

          if (e.code === 0 && e.stdout) {
            let stdout = e.stdout;
            stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
            return stdout;
          }

          throw new Error(`Error executing adbExec. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
        }
      });

      return function execFunc() {
        return _ref14.apply(this, arguments);
      };
    }();

    return yield (0, _asyncbox.retry)(2, execFunc);
  });

  return function (_x5) {
    return _ref13.apply(this, arguments);
  };
}();

systemCallMethods.shell = function () {
  var _ref16 = (0, _asyncToGenerator2.default)(function* (cmd, opts = {}) {
    const privileged = opts.privileged,
          keepPrivileged = opts.keepPrivileged;
    let shouldRestoreUser = false;

    if (privileged) {
      try {
        shouldRestoreUser = !(yield this.adbExec(['root'], opts)).includes('already running as root');
      } catch (err) {
        if (!err.message.includes('adbd cannot run as root')) {
          _logger.default.warn(`Cannot run adbd as root. Original error: ${err.message}`);
        }
      }
    }

    let didCommandFail = false;

    try {
      try {
        return yield this.adbExec(_lodash.default.isArray(cmd) ? ['shell', ...cmd] : ['shell', cmd], opts);
      } catch (err) {
        didCommandFail = true;
        throw err;
      }
    } finally {
      if (privileged && shouldRestoreUser && (!keepPrivileged || didCommandFail)) {
        try {
          yield this.adbExec(['unroot'], opts);
        } catch (err) {
          _logger.default.warn(`Cannot run adbd as non-root. Original error: ${err.message}`);
        }
      }
    }
  });

  return function (_x6) {
    return _ref16.apply(this, arguments);
  };
}();

systemCallMethods.createSubProcess = function (args = []) {
  args = this.executable.defaultArgs.concat(args);

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = (0, _asyncToGenerator2.default)(function* () {
  _logger.default.debug("Getting running emulator port");

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = yield this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
});

systemCallMethods.getPortFromEmulatorString = function (emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = (0, _asyncToGenerator2.default)(function* () {
  _logger.default.debug("Getting connected emulators");

  try {
    let devices = yield this.getConnectedDevices();
    let emulators = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = devices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        let device = _step2.value;
        let port = this.getPortFromEmulatorString(device.udid);

        if (port) {
          device.port = port;
          emulators.push(device);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    _logger.default.debug(`${emulators.length} emulator(s) connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
});

systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function (deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function (deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = function () {
  var _ref19 = (0, _asyncToGenerator2.default)(function* (avdName) {
    _logger.default.debug(`Trying to find ${avdName} emulator`);

    try {
      let emulators = yield this.getConnectedEmulators();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = emulators[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          let emulator = _step3.value;
          this.setEmulatorPort(emulator.port);
          let runningAVDName = yield this.sendTelnetCommand("avd name");

          if (avdName === runningAVDName) {
            _logger.default.debug(`Found emulator ${avdName} in port ${emulator.port}`);

            this.setDeviceId(emulator.udid);
            return emulator;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      _logger.default.debug(`Emulator ${avdName} not running`);

      return null;
    } catch (e) {
      throw new Error(`Error getting AVD. Original error: ${e.message}`);
    }
  });

  return function (_x7) {
    return _ref19.apply(this, arguments);
  };
}();

systemCallMethods.getRunningAVDWithRetry = function () {
  var _ref20 = (0, _asyncToGenerator2.default)(function* (avdName, timeoutMs = 20000) {
    var _this3 = this;

    let runningAvd;

    try {
      yield (0, _asyncbox.waitForCondition)((0, _asyncToGenerator2.default)(function* () {
        try {
          runningAvd = yield _this3.getRunningAVD(avdName.replace('@', ''));
          return runningAvd;
        } catch (e) {
          _logger.default.debug(e.message);

          return false;
        }
      }), {
        waitMs: timeoutMs,
        intervalMs: 1000
      });
    } catch (e) {
      throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
    }

    return runningAvd;
  });

  return function (_x8) {
    return _ref20.apply(this, arguments);
  };
}();

systemCallMethods.killAllEmulators = (0, _asyncToGenerator2.default)(function* () {
  let cmd, args;

  if (_appiumSupport.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    yield (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
});

systemCallMethods.killEmulator = function () {
  var _ref23 = (0, _asyncToGenerator2.default)(function* (avdName = null, timeout = 60000) {
    var _this4 = this;

    if (_appiumSupport.util.hasValue(avdName)) {
      _logger.default.debug(`Killing avd '${avdName}'`);

      const device = yield this.getRunningAVD(avdName);

      if (!device) {
        _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

        return false;
      }
    } else {
      _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

      if (!(yield this.isEmulatorConnected())) {
        _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

        return false;
      }
    }

    yield this.adbExec(['emu', 'kill']);

    _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

    try {
      yield (0, _asyncbox.waitForCondition)((0, _asyncToGenerator2.default)(function* () {
        try {
          return _appiumSupport.util.hasValue(avdName) ? !(yield _this4.getRunningAVD(avdName)) : !(yield _this4.isEmulatorConnected());
        } catch (ign) {}

        return false;
      }), {
        waitMs: timeout,
        intervalMs: 2000
      });
    } catch (e) {
      throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
    }

    _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

    return true;
  });

  return function () {
    return _ref23.apply(this, arguments);
  };
}();

systemCallMethods.launchAVD = function () {
  var _ref25 = (0, _asyncToGenerator2.default)(function* (avdName, avdArgs, language, country, avdLaunchTimeout = 60000, avdReadyTimeout = 60000, retryTimes = 1) {
    var _this5 = this;

    _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${avdLaunchTimeout}ms and readyTimeout ${avdReadyTimeout}ms`);

    let emulatorBinaryPath = yield this.getSdkBinaryPath("emulator");

    if (avdName[0] === "@") {
      avdName = avdName.substr(1);
    }

    yield this.checkAvdExist(avdName);
    let launchArgs = ["-avd", avdName];

    if (_lodash.default.isString(language)) {
      _logger.default.debug(`Setting Android Device Language to ${language}`);

      launchArgs.push("-prop", `persist.sys.language=${language.toLowerCase()}`);
    }

    if (_lodash.default.isString(country)) {
      _logger.default.debug(`Setting Android Device Country to ${country}`);

      launchArgs.push("-prop", `persist.sys.country=${country.toUpperCase()}`);
    }

    let locale;

    if (_lodash.default.isString(language) && _lodash.default.isString(country)) {
      locale = language.toLowerCase() + "-" + country.toUpperCase();
    } else if (_lodash.default.isString(language)) {
      locale = language.toLowerCase();
    } else if (_lodash.default.isString(country)) {
      locale = country;
    }

    if (_lodash.default.isString(locale)) {
      _logger.default.debug(`Setting Android Device Locale to ${locale}`);

      launchArgs.push("-prop", `persist.sys.locale=${locale}`);
    }

    if (!_lodash.default.isEmpty(avdArgs)) {
      launchArgs.push(...(_lodash.default.isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
    }

    _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${JSON.stringify(launchArgs)}`);

    let proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
    yield proc.start(0);
    proc.on('output', (stdout, stderr) => {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (stdout || stderr || '').split('\n').filter(Boolean)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          let line = _step4.value;

          _logger.default.info(`[AVD OUTPUT] ${line}`);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    });
    proc.on('die', (code, signal) => {
      _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
    });
    yield (0, _asyncbox.retry)(retryTimes, (0, _asyncToGenerator2.default)(function* () {
      return yield _this5.getRunningAVDWithRetry(avdName, avdLaunchTimeout);
    }));
    yield this.waitForEmulatorReady(avdReadyTimeout);
    return proc;
  });

  return function (_x9, _x10, _x11, _x12) {
    return _ref25.apply(this, arguments);
  };
}();

systemCallMethods.getAdbVersion = _lodash.default.memoize((0, _asyncToGenerator2.default)(function* () {
  try {
    let adbVersion = (yield this.adbExec('version')).replace(/Android\sDebug\sBridge\sversion\s([\d.]*)[\s\w-]*/, "$1");
    let parts = adbVersion.split('.');
    return {
      versionString: adbVersion,
      versionFloat: parseFloat(adbVersion),
      major: parseInt(parts[0], 10),
      minor: parseInt(parts[1], 10),
      patch: parts[2] ? parseInt(parts[2], 10) : undefined
    };
  } catch (e) {
    throw new Error(`Error getting adb version. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
  }
}));

systemCallMethods.checkAvdExist = function () {
  var _ref28 = (0, _asyncToGenerator2.default)(function* (avdName) {
    let cmd, result;

    try {
      cmd = yield this.getSdkBinaryPath('emulator');
      result = yield (0, _teen_process.exec)(cmd, ['-list-avds']);
    } catch (e) {
      let unknownOptionError = new RegExp("unknown option: -list-avds", "i").test(e.stderr);

      if (!unknownOptionError) {
        throw new Error(`Error executing checkAvdExist. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
      }

      const sdkVersion = yield (0, _helpers.getSdkToolsVersion)();
      let binaryName = 'android';

      if (sdkVersion) {
        if (sdkVersion.major >= 25) {
          binaryName = 'avdmanager';
        }
      } else {
        _logger.default.warn(`Defaulting binary name to '${binaryName}', because SDK version cannot be parsed`);
      }

      cmd = yield this.getSdkBinaryPath(binaryName);
      result = yield (0, _teen_process.exec)(cmd, ['list', 'avd', '-c']);
    }

    if (result.stdout.indexOf(avdName) === -1) {
      let existings = `(${result.stdout.trim().replace(/[\n]/g, '), (')})`;
      throw new Error(`Avd '${avdName}' is not available. please select your avd name from one of these: '${existings}'`);
    }
  });

  return function (_x13) {
    return _ref28.apply(this, arguments);
  };
}();

systemCallMethods.waitForEmulatorReady = function () {
  var _ref29 = (0, _asyncToGenerator2.default)(function* (timeoutMs = 20000) {
    var _this6 = this;

    try {
      yield (0, _asyncbox.waitForCondition)((0, _asyncToGenerator2.default)(function* () {
        try {
          if (!(yield _this6.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
            return false;
          }

          return /\d+\[\w+\]/.test((yield _this6.shell(['pm', 'get-install-location'])));
        } catch (err) {
          _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

          return false;
        }
      }), {
        waitMs: timeoutMs,
        intervalMs: 3000
      });
    } catch (e) {
      throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
    }
  });

  return function () {
    return _ref29.apply(this, arguments);
  };
}();

systemCallMethods.waitForDevice = function () {
  var _ref31 = (0, _asyncToGenerator2.default)(function* (appDeviceReadyTimeout = 30) {
    var _this7 = this;

    this.appDeviceReadyTimeout = appDeviceReadyTimeout;
    const retries = 3;
    const timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
    yield (0, _asyncbox.retry)(retries, (0, _asyncToGenerator2.default)(function* () {
      try {
        yield _this7.adbExec('wait-for-device', {
          timeout
        });
        yield _this7.ping();
      } catch (e) {
        yield _this7.restartAdb();
        yield _this7.getConnectedDevices();
        throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
      }
    }));
  });

  return function () {
    return _ref31.apply(this, arguments);
  };
}();

systemCallMethods.reboot = function () {
  var _ref33 = (0, _asyncToGenerator2.default)(function* (retries = DEFAULT_ADB_REBOOT_RETRIES) {
    var _this8 = this;

    yield this.shell(['stop'], {
      privileged: true
    });
    yield _bluebird.default.delay(2000);
    yield this.setDeviceProperty('sys.boot_completed', 0);
    yield this.shell(['start'], {
      privileged: true
    });
    const started = process.hrtime();
    yield (0, _asyncbox.retryInterval)(retries, 1000, (0, _asyncToGenerator2.default)(function* () {
      if ((yield _this8.getDeviceProperty('sys.boot_completed')) === '1') {
        return;
      }

      const msg = `Reboot is not completed after ${process.hrtime(started)[0]}s`;

      _logger.default.debug(msg);

      throw new Error(msg);
    }));
  });

  return function () {
    return _ref33.apply(this, arguments);
  };
}();

systemCallMethods.root = (0, _asyncToGenerator2.default)(function* () {
  try {
    let _ref36 = yield (0, _teen_process.exec)(this.executable.path, ['root']),
        stdout = _ref36.stdout;

    if (stdout && stdout.indexOf('adbd cannot run as root') !== -1) {
      throw new Error(stdout.trim());
    }

    return true;
  } catch (err) {
    _logger.default.warn(`Unable to root adb daemon: '${err.message}'. Continuing`);

    return false;
  }
});
systemCallMethods.unroot = (0, _asyncToGenerator2.default)(function* () {
  try {
    yield (0, _teen_process.exec)(this.executable.path, ['unroot']);
    return true;
  } catch (err) {
    _logger.default.warn(`Unable to unroot adb daemon: '${err.message}'. Continuing`);

    return false;
  }
});
systemCallMethods.isRoot = (0, _asyncToGenerator2.default)(function* () {
  return (yield this.shell(['whoami'])).trim() === 'root';
});

systemCallMethods.fileExists = function () {
  var _ref39 = (0, _asyncToGenerator2.default)(function* (remotePath) {
    let files = yield this.ls(remotePath);
    return files.length > 0;
  });

  return function (_x14) {
    return _ref39.apply(this, arguments);
  };
}();

systemCallMethods.ls = function () {
  var _ref40 = (0, _asyncToGenerator2.default)(function* (remotePath, opts = []) {
    try {
      let args = ['ls', ...opts, remotePath];
      let stdout = yield this.shell(args);
      let lines = stdout.split("\n");
      return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf("No such file") === -1);
    } catch (err) {
      if (err.message.indexOf('No such file or directory') === -1) {
        throw err;
      }

      return [];
    }
  });

  return function (_x15) {
    return _ref40.apply(this, arguments);
  };
}();

systemCallMethods.fileSize = function () {
  var _ref41 = (0, _asyncToGenerator2.default)(function* (remotePath) {
    try {
      const files = yield this.ls(remotePath, ['-la']);

      if (files.length !== 1) {
        throw new Error(`Remote path is not a file`);
      }

      const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

      if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
        throw new Error(`Unable to parse size from list output: '${files[0]}'`);
      }

      return parseInt(match[1], 10);
    } catch (err) {
      throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
    }
  });

  return function (_x16) {
    return _ref41.apply(this, arguments);
  };
}();

systemCallMethods.installMitmCertificate = function () {
  var _ref42 = (0, _asyncToGenerator2.default)(function* (cert) {
    var _this9 = this;

    const openSsl = yield (0, _helpers.getOpenSslForOs)();

    if (!_lodash.default.isBuffer(cert)) {
      cert = Buffer.from(cert, 'base64');
    }

    const tmpRoot = yield _appiumSupport.tempDir.openDir();

    try {
      const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

      yield _appiumSupport.fs.writeFile(srcCert, cert);

      let _ref43 = yield (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]),
          stdout = _ref43.stdout;

      const certHash = stdout.trim();

      _logger.default.debug(`Got certificate hash: ${certHash}`);

      _logger.default.debug('Preparing certificate content');

      var _ref44 = yield (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
        isBuffer: true
      });

      stdout = _ref44.stdout;
      let dstCertContent = stdout;

      var _ref45 = yield (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
        isBuffer: true
      });

      stdout = _ref45.stdout;
      dstCertContent = Buffer.concat([dstCertContent, stdout]);

      const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

      yield _appiumSupport.fs.writeFile(dstCert, dstCertContent);

      _logger.default.debug('Remounting /system in rw mode');

      yield (0, _asyncbox.retryInterval)(5, 2000, (0, _asyncToGenerator2.default)(function* () {
        return yield _this9.adbExec(['remount']);
      }));

      _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

      yield this.push(dstCert, CERTS_ROOT);

      _logger.default.debug('Remounting /system to confirm changes');

      yield this.adbExec(['remount']);
    } catch (err) {
      throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
    } finally {
      yield _appiumSupport.fs.rimraf(tmpRoot);
    }
  });

  return function (_x17) {
    return _ref42.apply(this, arguments);
  };
}();

systemCallMethods.isMitmCertificateInstalled = function () {
  var _ref47 = (0, _asyncToGenerator2.default)(function* (cert) {
    const openSsl = yield (0, _helpers.getOpenSslForOs)();

    if (!_lodash.default.isBuffer(cert)) {
      cert = Buffer.from(cert, 'base64');
    }

    const tmpRoot = yield _appiumSupport.tempDir.openDir();
    let certHash;

    try {
      const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

      yield _appiumSupport.fs.writeFile(tmpCert, cert);

      const _ref48 = yield (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]),
            stdout = _ref48.stdout;

      certHash = stdout.trim();
    } catch (err) {
      throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
    } finally {
      yield _appiumSupport.fs.rimraf(tmpRoot);
    }

    const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

    _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

    return yield this.fileExists(dstPath);
  });

  return function (_x18) {
    return _ref47.apply(this, arguments);
  };
}();

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIlBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCIsIlJlZ0V4cCIsIkRFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQIiwiREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQIiwiQ0VSVFNfUk9PVCIsImdldFNka0JpbmFyeVBhdGgiLCJfIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJsb2ciLCJpbmZvIiwic2RrUm9vdCIsImdldEJpbmFyeUZyb21TZGtSb290Iiwid2FybiIsImdldEJpbmFyeUZyb21QYXRoIiwiZ2V0Q29tbWFuZEZvck9TIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJiaW5hcnlMb2MiLCJiaW5hcnlMb2NzIiwicGF0aCIsInJlc29sdmUiLCJmb3JFYWNoIiwiZGlyIiwicHVzaCIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJ0cmltIiwiY21kIiwic3Rkb3V0IiwiZSIsImdldENvbm5lY3RlZERldmljZXMiLCJkZWJ1ZyIsImV4ZWN1dGFibGUiLCJkZWZhdWx0QXJncyIsImNvbmNhdCIsInN0YXJ0aW5nSW5kZXgiLCJzbGljZSIsImRldmljZXMiLCJzcGxpdCIsImxpbmUiLCJsaW5lSW5mbyIsInVkaWQiLCJzdGF0ZSIsImxlbmd0aCIsIm1lc3NhZ2UiLCJnZXREZXZpY2VzV2l0aFJldHJ5IiwidGltZW91dE1zIiwic3RhcnQiLCJEYXRlIiwibm93IiwiZ2V0RGV2aWNlcyIsInJlc3RhcnRBZGIiLCJzdXBwcmVzc0tpbGxTZXJ2ZXIiLCJraWxsU2VydmVyIiwiZXJyb3IiLCJhZGJQb3J0IiwicmVzZXRUZWxuZXRBdXRoVG9rZW4iLCJob21lRm9sZGVyUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJwbGF0Zm9ybSIsImRzdFBhdGgiLCJ3cml0ZUZpbGUiLCJhZGJFeGVjRW11IiwidmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQiLCJhZGJFeGVjIiwib3B0cyIsInRpbWVvdXQiLCJhZGJFeGVjVGltZW91dCIsImV4ZWNGdW5jIiwiQXJyYXkiLCJhcmdzIiwicmVwbGFjZSIsImVyclRleHQiLCJzdGRlcnIiLCJwcm90b2NvbEZhdWx0RXJyb3IiLCJ0ZXN0IiwiZGV2aWNlTm90Rm91bmRFcnJvciIsImRldmljZUNvbm5lY3RpbmdFcnJvciIsImNvZGUiLCJzaGVsbCIsInByaXZpbGVnZWQiLCJrZWVwUHJpdmlsZWdlZCIsInNob3VsZFJlc3RvcmVVc2VyIiwiaW5jbHVkZXMiLCJlcnIiLCJkaWRDb21tYW5kRmFpbCIsImlzQXJyYXkiLCJjcmVhdGVTdWJQcm9jZXNzIiwiSlNPTiIsInN0cmluZ2lmeSIsIlN1YlByb2Nlc3MiLCJnZXRBZGJQYXRoIiwiZ2V0QWRiU2VydmVyUG9ydCIsImdldEVtdWxhdG9yUG9ydCIsImVtdWxhdG9yUG9ydCIsInBvcnQiLCJnZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nIiwiZW1TdHIiLCJwb3J0UGF0dGVybiIsInBhcnNlSW50IiwiZXhlYyIsImdldENvbm5lY3RlZEVtdWxhdG9ycyIsImVtdWxhdG9ycyIsImRldmljZSIsInNldEVtdWxhdG9yUG9ydCIsImVtUG9ydCIsInNldERldmljZUlkIiwiZGV2aWNlSWQiLCJjdXJEZXZpY2VJZCIsImFyZ3NIYXNEZXZpY2UiLCJzcGxpY2UiLCJzZXREZXZpY2UiLCJkZXZpY2VPYmoiLCJnZXRSdW5uaW5nQVZEIiwiYXZkTmFtZSIsImVtdWxhdG9yIiwicnVubmluZ0FWRE5hbWUiLCJzZW5kVGVsbmV0Q29tbWFuZCIsImdldFJ1bm5pbmdBVkRXaXRoUmV0cnkiLCJydW5uaW5nQXZkIiwid2FpdE1zIiwiaW50ZXJ2YWxNcyIsImtpbGxBbGxFbXVsYXRvcnMiLCJraWxsRW11bGF0b3IiLCJ1dGlsIiwiaGFzVmFsdWUiLCJpc0VtdWxhdG9yQ29ubmVjdGVkIiwiaWduIiwibGF1bmNoQVZEIiwiYXZkQXJncyIsImxhbmd1YWdlIiwiY291bnRyeSIsImF2ZExhdW5jaFRpbWVvdXQiLCJhdmRSZWFkeVRpbWVvdXQiLCJyZXRyeVRpbWVzIiwiZW11bGF0b3JCaW5hcnlQYXRoIiwic3Vic3RyIiwiY2hlY2tBdmRFeGlzdCIsImxhdW5jaEFyZ3MiLCJpc1N0cmluZyIsInRvVXBwZXJDYXNlIiwibG9jYWxlIiwiaXNFbXB0eSIsInByb2MiLCJvbiIsImZpbHRlciIsIkJvb2xlYW4iLCJzaWduYWwiLCJ3YWl0Rm9yRW11bGF0b3JSZWFkeSIsImdldEFkYlZlcnNpb24iLCJhZGJWZXJzaW9uIiwicGFydHMiLCJ2ZXJzaW9uU3RyaW5nIiwidmVyc2lvbkZsb2F0IiwicGFyc2VGbG9hdCIsIm1ham9yIiwibWlub3IiLCJwYXRjaCIsInVuZGVmaW5lZCIsInJlc3VsdCIsInVua25vd25PcHRpb25FcnJvciIsInNka1ZlcnNpb24iLCJleGlzdGluZ3MiLCJ3YWl0Rm9yRGV2aWNlIiwiYXBwRGV2aWNlUmVhZHlUaW1lb3V0IiwicmV0cmllcyIsInBpbmciLCJyZWJvb3QiLCJCIiwiZGVsYXkiLCJzZXREZXZpY2VQcm9wZXJ0eSIsInN0YXJ0ZWQiLCJocnRpbWUiLCJnZXREZXZpY2VQcm9wZXJ0eSIsIm1zZyIsInJvb3QiLCJ1bnJvb3QiLCJpc1Jvb3QiLCJmaWxlRXhpc3RzIiwicmVtb3RlUGF0aCIsImZpbGVzIiwibHMiLCJsaW5lcyIsIm1hcCIsImwiLCJmaWxlU2l6ZSIsIm1hdGNoIiwiaXNOYU4iLCJpbnN0YWxsTWl0bUNlcnRpZmljYXRlIiwiY2VydCIsIm9wZW5Tc2wiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ0bXBSb290IiwidGVtcERpciIsIm9wZW5EaXIiLCJzcmNDZXJ0IiwiY2VydEhhc2giLCJkc3RDZXJ0Q29udGVudCIsImRzdENlcnQiLCJyaW1yYWYiLCJpc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCIsInRtcENlcnQiLCJwb3NpeCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQSxJQUFJQSxpQkFBaUIsR0FBRyxFQUF4QjtBQUVBLE1BQU1DLHdCQUF3QixHQUFHLEtBQWpDOztBQUNBLE1BQU1DLDBCQUEwQixHQUFHLEVBQW5DO0FBRUEsTUFBTUMscUJBQXFCLEdBQUcsc0JBQTlCO0FBQ0EsTUFBTUMsMkJBQTJCLEdBQUcsSUFBSUMsTUFBSixDQUFXLGdDQUFYLEVBQTZDLEdBQTdDLENBQXBDO0FBQ0EsTUFBTUMsNkJBQTZCLEdBQUcsSUFBSUQsTUFBSixDQUFZLGlDQUFaLEVBQThDLEdBQTlDLENBQXRDO0FBQ0EsTUFBTUUsOEJBQThCLEdBQUcsSUFBSUYsTUFBSixDQUFXLGdDQUFYLEVBQTZDLEdBQTdDLENBQXZDO0FBRUEsTUFBTUcsVUFBVSxHQUFHLDhCQUFuQjtBQVFBUixpQkFBaUIsQ0FBQ1MsZ0JBQWxCLEdBQXFDQyxnQkFBRUMsT0FBRjtBQUFBLDZDQUFVLFdBQWdCQyxVQUFoQixFQUE0QjtBQUN6RUMsb0JBQUlDLElBQUosQ0FBVSxvQkFBbUJGLFVBQVcsYUFBeEM7O0FBQ0EsUUFBSSxLQUFLRyxPQUFULEVBQWtCO0FBQ2hCLG1CQUFhLEtBQUtDLG9CQUFMLENBQTBCSixVQUExQixDQUFiO0FBQ0Q7O0FBQ0RDLG9CQUFJSSxJQUFKLENBQVUsc0VBQUQsR0FDQyxrRUFERCxHQUVDLHlDQUF3Q0wsVUFBVyxHQUY3RDs7QUFHQSxpQkFBYSxLQUFLTSxpQkFBTCxDQUF1Qk4sVUFBdkIsQ0FBYjtBQUNELEdBVG9DOztBQUFBO0FBQUE7QUFBQTtBQUFBLElBQXJDO0FBa0JBWixpQkFBaUIsQ0FBQ21CLGVBQWxCLEdBQW9DVCxnQkFBRUMsT0FBRixDQUFVLFlBQVk7QUFDeEQsU0FBT1Msc0JBQU9D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cG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIHV0aWwsIHRlbXBEaXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBnZXRTZGtUb29sc1ZlcnNpb24sIGdldEJ1aWxkVG9vbHNEaXJzLCBnZXRPcGVuU3NsRm9yT3MgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHF1b3RlIH0gZnJvbSAnc2hlbGwtcXVvdGUnO1xuXG5cbmxldCBzeXN0ZW1DYWxsTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgPSAyMDAwMDsgLy8gaW4gbWlsbGlzZWNvbmRzXG5jb25zdCBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyA9IDkwO1xuXG5jb25zdCBMSU5LRVJfV0FSTklOR19SRUdFWFAgPSAvXldBUk5JTkc6IGxpbmtlci4rJC9tO1xuY29uc3QgUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgncHJvdG9jb2wgZmF1bHQgXFxcXChubyBzdGF0dXNcXFxcKScsICdpJyk7XG5jb25zdCBERVZJQ0VfTk9UX0ZPVU5EX0VSUk9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoYGVycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmRgLCAnaScpO1xuY29uc3QgREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgnZXJyb3I6IGRldmljZSBzdGlsbCBjb25uZWN0aW5nJywgJ2knKTtcblxuY29uc3QgQ0VSVFNfUk9PVCA9ICcvc3lzdGVtL2V0Yy9zZWN1cml0eS9jYWNlcnRzJztcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGluY2x1ZGluZyBjdXJyZW50IFNESyByb290LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGxvZy5pbmZvKGBDaGVja2luZyB3aGV0aGVyICR7YmluYXJ5TmFtZX0gaXMgcHJlc2VudGApO1xuICBpZiAodGhpcy5zZGtSb290KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QoYmluYXJ5TmFtZSk7XG4gIH1cbiAgbG9nLndhcm4oYFRoZSBBTkRST0lEX0hPTUUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCB0byB0aGUgQW5kcm9pZCBTREsgYCArXG4gICAgICAgICAgIGByb290IGRpcmVjdG9yeSBwYXRoLiBBTkRST0lEX0hPTUUgaXMgcmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgYCArXG4gICAgICAgICAgIGB3aXRoIFNESyAyMysuIENoZWNraW5nIGFsb25nIFBBVEggZm9yICR7YmluYXJ5TmFtZX0uYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldEJpbmFyeUZyb21QYXRoKGJpbmFyeU5hbWUpO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIG5hbWUgb2YgdGhlIHRvb2wsXG4gKiB3aGljaCBwcmludHMgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBjb21tYW5kIHNob3J0Y3V0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgc3VwcG9zZWQgdG8gYmUgZWl0aGVyICd3aGljaCcgb3IgJ3doZXJlJy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29tbWFuZEZvck9TID0gXy5tZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHN5c3RlbS5pc1dpbmRvd3MoKSA/ICd3aGVyZScgOiAnd2hpY2gnO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBiaW5hcnkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIHNpbXBsZSBiaW5hcnkgbmFtZSwgZm9yIGV4YW1wbGUgJ2FuZHJvaWQnLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgYmluYXJ5IG5hbWUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLFxuICogICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgJ2FuZHJvaWQuYmF0JyBvbiBXaW5kb3dzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgaWYgKCFzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICByZXR1cm4gYmluYXJ5TmFtZTtcbiAgfVxuXG4gIGlmIChbJ2FuZHJvaWQnLCAnYXBrc2lnbmVyJywgJ2Fwa2FuYWx5emVyJ10uaW5kZXhPZihiaW5hcnlOYW1lKSA+PSAwICYmXG4gICAgICAhYmluYXJ5TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuYmF0JykpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uYmF0YDtcbiAgfVxuICBpZiAoIWJpbmFyeU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmV4ZScpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmV4ZWA7XG4gIH1cbiAgcmV0dXJuIGJpbmFyeU5hbWU7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFNpbXBsZSBuYW1lIG9mIGEgYmluYXJ5IGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LiBUaGUgbWV0aG9kIHRyaWVzXG4gKiAgICAgICAgICAgICAgICAgIHRvIGVudW1lcmF0ZSBhbGwgdGhlIGtub3duIGxvY2F0aW9ucyB3aGVyZSB0aGUgYmluYXJ5XG4gKiAgICAgICAgICAgICAgICAgIG1pZ2h0IGJlIGxvY2F0ZWQgYW5kIHN0b3BzIHRoZSBzZWFyY2ggYXMgc29vbiBhcyB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgbWF0Y2ggaXMgZm91bmQgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBiaW5hcnkgd2l0aCBnaXZlbiBuYW1lIGlzIG5vdCBwcmVzZW50IGF0IGFueVxuICogICAgICAgICAgICAgICAgIG9mIGtub3duIGxvY2F0aW9ucyBvciBBbmRyb2lkIFNESyBpcyBub3QgaW5zdGFsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tU2RrUm9vdCA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgYmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICBsZXQgYmluYXJ5TG9jcyA9IFtcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInBsYXRmb3JtLXRvb2xzXCIsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwiZW11bGF0b3JcIiwgYmluYXJ5TmFtZSksXG4gICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJ0b29sc1wiLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInRvb2xzXCIsIFwiYmluXCIsIGJpbmFyeU5hbWUpXG4gIF07XG4gIC8vIGdldCBzdWJwYXRocyBmb3IgY3VycmVudGx5IGluc3RhbGxlZCBidWlsZCB0b29sIGRpcmVjdG9yaWVzXG4gIF8uZm9yRWFjaChhd2FpdCBnZXRCdWlsZFRvb2xzRGlycyh0aGlzLnNka1Jvb3QpLFxuICAgICAgICAgICAgKGRpcikgPT4gYmluYXJ5TG9jcy5wdXNoKHBhdGgucmVzb2x2ZShkaXIsIGJpbmFyeU5hbWUpKSk7XG4gIGZvciAobGV0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICBiaW5hcnlMb2MgPSBsb2M7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKF8uaXNOdWxsKGJpbmFyeUxvYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7YmluYXJ5TmFtZX0gaW4gJHtiaW5hcnlMb2NzfS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEbyB5b3UgaGF2ZSB0aGUgQW5kcm9pZCBTREsgaW5zdGFsbGVkIGF0ICcke3RoaXMuc2RrUm9vdH0nP2ApO1xuICB9XG4gIGJpbmFyeUxvYyA9IGJpbmFyeUxvYy50cmltKCk7XG4gIGxvZy5pbmZvKGBVc2luZyAke2JpbmFyeU5hbWV9IGZyb20gJHtiaW5hcnlMb2N9YCk7XG4gIHJldHVybiBiaW5hcnlMb2M7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gYSBiaW5hcnkgZmlsZSB1c2luZyB0aGUgc3RhbmRhcmQgc3lzdGVtIGxvb2t1cCB0b29sLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpbmFyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBiaW5hcnkgcmVjZWl2ZWQgZnJvbSAnd2hpY2gnLyd3aGVyZSdcbiAqICAgICAgICAgICAgICAgICAgb3V0cHV0LlxuICogQHRocm93cyB7RXJyb3J9IElmIGxvb2t1cCB0b29sIHJldHVybnMgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21QYXRoID0gYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbGV0IGJpbmFyeUxvYyA9IG51bGw7XG4gIGxldCBjbWQgPSB0aGlzLmdldENvbW1hbmRGb3JPUygpO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoY21kLCBbYmluYXJ5TmFtZV0pO1xuICAgIGxvZy5pbmZvKGBVc2luZyAke2JpbmFyeU5hbWV9IGZyb20gJHtzdGRvdXR9YCk7XG4gICAgLy8gVE9ETyB3cml0ZSBhIHRlc3QgZm9yIGJpbmFyaWVzIHdpdGggc3BhY2VzLlxuICAgIGJpbmFyeUxvYyA9IHN0ZG91dC50cmltKCk7XG4gICAgcmV0dXJuIGJpbmFyeUxvYztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtiaW5hcnlOYW1lfSBQbGVhc2Ugc2V0IHRoZSBBTkRST0lEX0hPTUUgYCArXG4gICAgICAgICAgICAgIGBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIHRoZSBBbmRyb2lkIFNESyByb290IGRpcmVjdG9yeSBwYXRoLmApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIHVkaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBDdXJyZW50IGRldmljZSBzdGF0ZSwgYXMgaXQgaXMgdmlzaWJsZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkYiBkZXZpY2VzIC1sXyBvdXRwdXQuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBkZXZpY2VzIG9yIGFuIGVtcHR5IGxpc3QgaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBubyBkZXZpY2VzIGFyZSBjb25uZWN0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxpc3RpbmcgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRGV2aWNlcyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4uLlwiKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KFsnZGV2aWNlcyddKSk7XG4gICAgLy8gZXhwZWN0aW5nIGFkYiBkZXZpY2VzIHRvIHJldHVybiBvdXRwdXQgYXNcbiAgICAvLyBMaXN0IG9mIGRldmljZXMgYXR0YWNoZWRcbiAgICAvLyBlbXVsYXRvci01NTU0XHRkZXZpY2VcbiAgICBsZXQgc3RhcnRpbmdJbmRleCA9IHN0ZG91dC5pbmRleE9mKFwiTGlzdCBvZiBkZXZpY2VzXCIpO1xuICAgIGlmIChzdGFydGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dHB1dCB3aGlsZSB0cnlpbmcgdG8gZ2V0IGRldmljZXMuIG91dHB1dCB3YXM6ICR7c3Rkb3V0fWApO1xuICAgIH1cbiAgICAvLyBzbGljaW5nIG91cHV0IHdlIGNhcmUgYWJvdXQuXG4gICAgc3Rkb3V0ID0gc3Rkb3V0LnNsaWNlKHN0YXJ0aW5nSW5kZXgpO1xuICAgIGxldCBkZXZpY2VzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGlmIChsaW5lLnRyaW0oKSAhPT0gXCJcIiAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIkxpc3Qgb2YgZGV2aWNlc1wiKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoXCJhZGIgc2VydmVyXCIpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIiogZGFlbW9uXCIpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcIm9mZmxpbmVcIikgPT09IC0xKSB7XG4gICAgICAgIGxldCBsaW5lSW5mbyA9IGxpbmUuc3BsaXQoXCJcXHRcIik7XG4gICAgICAgIC8vIHN0YXRlIGlzIGVpdGhlciBcImRldmljZVwiIG9yIFwib2ZmbGluZVwiLCBhZmFpY3RcbiAgICAgICAgZGV2aWNlcy5wdXNoKHt1ZGlkOiBsaW5lSW5mb1swXSwgc3RhdGU6IGxpbmVJbmZvWzFdfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtkZXZpY2VzLmxlbmd0aH0gZGV2aWNlKHMpIGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBkZXZpY2VzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBnZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYiB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZ2V0IGF0IGxlYXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGxpc3QgaXRlbS5cbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBjb25uZWN0ZWQgZGV2aWNlcyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXREZXZpY2VzV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxvZy5kZWJ1ZyhcIlRyeWluZyB0byBmaW5kIGEgY29ubmVjdGVkIGFuZHJvaWQgZGV2aWNlXCIpO1xuICBsZXQgZ2V0RGV2aWNlcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoKERhdGUubm93KCkgLSBzdGFydCkgPiB0aW1lb3V0TXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGVkIEFuZHJvaWQgZGV2aWNlLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIGRldmljZXMsIHJlc3RhcnRpbmcgYWRiIHNlcnZlci4uLlwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIC8vIGNvb2wgZG93blxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKFwiQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAvLyBjb29sIGRvd25cbiAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbn07XG5cbi8qKlxuICogUmVzdGFydCBhZGIgc2VydmVyLCB1bmxlc3MgX3RoaXMuc3VwcHJlc3NLaWxsU2VydmVyXyBwcm9wZXJ0eSBpcyB0cnVlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXN0YXJ0QWRiID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXIpIHtcbiAgICBsb2cuZGVidWcoYE5vdCByZXN0YXJ0aW5nIGFiZCBzaW5jZSAnc3VwcHJlc3NLaWxsU2VydmVyJyBpcyBvbmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZygnUmVzdGFydGluZyBhZGInKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmtpbGxTZXJ2ZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihcIkVycm9yIGtpbGxpbmcgQURCIHNlcnZlciwgZ29pbmcgdG8gc2VlIGlmIGl0J3Mgb25saW5lIGFueXdheVwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsIGFkYiBzZXJ2ZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxTZXJ2ZXIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhgS2lsbGluZyBhZGIgc2VydmVyIG9uIHBvcnQgJHt0aGlzLmFkYlBvcnR9YCk7XG4gIGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MsICdraWxsLXNlcnZlciddKTtcbn07XG5cbi8qKlxuICogUmVzZXQgVGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmFuZHJvaWQuY29tL3JlY2VudC9lbXVsYXRvcjI1MTZyZWxlYXNlbm90ZXN9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IElmIHRva2VuIHJlc2V0IHdhcyBzdWNjZXNzZnVsLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXNldFRlbG5ldEF1dGhUb2tlbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoZSBtZXRob2RzIGlzIHVzZWQgdG8gcmVtb3ZlIHRlbG5ldCBhdXRoIHRva2VuXG4gIC8vXG4gIGNvbnN0IGhvbWVGb2xkZXJQYXRoID0gcHJvY2Vzcy5lbnZbKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpID8gJ1VTRVJQUk9GSUxFJyA6ICdIT01FJ107XG4gIGlmICghaG9tZUZvbGRlclBhdGgpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IGZpbmQgdGhlIHBhdGggdG8gdXNlciBob21lIGZvbGRlci4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoaG9tZUZvbGRlclBhdGgsICcuZW11bGF0b3JfY29uc29sZV9hdXRoX3Rva2VuJyk7XG4gIGxvZy5kZWJ1ZyhgT3ZlcnJpZGluZyAke2RzdFBhdGh9IHdpdGggYW4gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHRlbG5ldCBhdXRoZW50aWNhdGlvbiBmb3IgZW11bGF0b3IgY29tbWFuZHNgKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLndhcm4oYEVycm9yICR7ZS5tZXNzYWdlfSB3aGlsZSByZXNldHRpbmcgdGhlIGNvbnRlbnQgb2YgJHtkc3RQYXRofS4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gZW11bGF0b3IgY29tbWFuZCB1c2luZyBfYWRiIGVtdV8gdG9vbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlY0VtdSA9IGFzeW5jIGZ1bmN0aW9uIChjbWQpIHtcbiAgYXdhaXQgdGhpcy52ZXJpZnlFbXVsYXRvckNvbm5lY3RlZCgpO1xuICBhd2FpdCB0aGlzLnJlc2V0VGVsbmV0QXV0aFRva2VuKCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2VtdScsIC4uLmNtZF0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBhZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWNtZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHBhc3MgaW4gYSBjb21tYW5kIHRvIGFkYkV4ZWMoKVwiKTtcbiAgfVxuICAvLyBzZXR0aW5nIGRlZmF1bHQgdGltZW91dCBmb3IgZWFjaCBjb21tYW5kIHRvIHByZXZlbnQgaW5maW5pdGUgd2FpdC5cbiAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IHRoaXMuYWRiRXhlY1RpbWVvdXQgfHwgREVGQVVMVF9BREJfRVhFQ19USU1FT1VUO1xuXG4gIGxldCBleGVjRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCEoY21kIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGNtZCA9IFtjbWRdO1xuICAgICAgfVxuICAgICAgbGV0IGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KGNtZCk7XG4gICAgICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7dGhpcy5leGVjdXRhYmxlLnBhdGh9ICR7cXVvdGUoYXJncyl9J2ApO1xuICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncywgb3B0cyk7XG4gICAgICAvLyBzb21ldGltZXMgQURCIHByaW50cyBvdXQgd2VpcmQgc3Rkb3V0IHdhcm5pbmdzIHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpbiBhbnkgb2YgdGhlIHJlc3BvbnNlIGRhdGEsIHNvIGxldCdzIHN0cmlwIGl0IG91dFxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnJlcGxhY2UoTElOS0VSX1dBUk5JTkdfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJUZXh0ID0gYCR7ZS5tZXNzYWdlfSwgJHtlLnN0ZG91dH0sICR7ZS5zdGRlcnJ9YDtcbiAgICAgIGNvbnN0IHByb3RvY29sRmF1bHRFcnJvciA9IFBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgY29uc3QgZGV2aWNlTm90Rm91bmRFcnJvciA9IERFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBjb25zdCBkZXZpY2VDb25uZWN0aW5nRXJyb3IgPSBERVZJQ0VfQ09OTkVDVElOR19FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGlmIChwcm90b2NvbEZhdWx0RXJyb3IgfHwgZGV2aWNlTm90Rm91bmRFcnJvciB8fCBkZXZpY2VDb25uZWN0aW5nRXJyb3IpIHtcbiAgICAgICAgbG9nLmluZm8oYEVycm9yIHNlbmRpbmcgY29tbWFuZCwgcmVjb25uZWN0aW5nIGRldmljZSBhbmQgcmV0cnlpbmc6ICR7Y21kfWApO1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXREZXZpY2VzV2l0aFJldHJ5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNvZGUgPT09IDAgJiYgZS5zdGRvdXQpIHtcbiAgICAgICAgbGV0IHN0ZG91dCA9IGUuc3Rkb3V0O1xuICAgICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgIHJldHVybiBzdGRvdXQ7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXhlY3V0aW5nIGFkYkV4ZWMuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGF3YWl0IHJldHJ5KDIsIGV4ZWNGdW5jKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2hlbGxFeGVjT3B0aW9uc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gcHJpdmlsZWdlZCBbZmFsc3ldIC0gV2hldGhlciB0byBydW4gdGhlIGdpdmVuIGNvbW1hbmQgYXMgcm9vdC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGtlZXBQcml2aWxlZ2VkIFtmYWxzeV0gLSBXaGV0aGVyIHRvIGtlZXAgcm9vdCBtb2RlIGFmdGVyIGNvbW1hbmQgZXhlY3V0aW9uIGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBBbGwgb3RoZXIgcHJvcGVydGllcyBhcmUgdGhlIHNhbWUgYXMgZm9yIGBleGVjYCBjYWxsIGZyb20ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGNvbW1hbmQgdXNpbmcgX2FkYiBzaGVsbF8gcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fHN0cmluZ30gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnMgb3IgYSBzaW5nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHs/U2hlbGxFeGVjT3B0aW9uc30gb3B0cyBbe31dIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNoZWxsID0gYXN5bmMgZnVuY3Rpb24gKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwcml2aWxlZ2VkLFxuICAgIGtlZXBQcml2aWxlZ2VkLFxuICB9ID0gb3B0cztcbiAgbGV0IHNob3VsZFJlc3RvcmVVc2VyID0gZmFsc2U7XG4gIGlmIChwcml2aWxlZ2VkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNob3VsZFJlc3RvcmVVc2VyID0gIShhd2FpdCB0aGlzLmFkYkV4ZWMoWydyb290J10sIG9wdHMpKS5pbmNsdWRlcygnYWxyZWFkeSBydW5uaW5nIGFzIHJvb3QnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ2FkYmQgY2Fubm90IHJ1biBhcyByb290JykpIHtcbiAgICAgICAgLy8gRG8gbm90IHNob3cgdGhlIHdhcm5pbmcgZm9yIHJlYWwgZGV2aWNlcywgd2hlcmUgcm9vdCBpcyBsb2NrZWRcbiAgICAgICAgbG9nLndhcm4oYENhbm5vdCBydW4gYWRiZCBhcyByb290LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGRpZENvbW1hbmRGYWlsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYkV4ZWMoXy5pc0FycmF5KGNtZCkgPyBbJ3NoZWxsJywgLi4uY21kXSA6IFsnc2hlbGwnLCBjbWRdLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRpZENvbW1hbmRGYWlsID0gdHJ1ZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHByaXZpbGVnZWQgJiYgc2hvdWxkUmVzdG9yZVVzZXIgJiYgKCFrZWVwUHJpdmlsZWdlZCB8fCBkaWRDb21tYW5kRmFpbCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3Vucm9vdCddLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cud2FybihgQ2Fubm90IHJ1biBhZGJkIGFzIG5vbi1yb290LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiAoYXJncyA9IFtdKSB7XG4gIC8vIGFkZCB0aGUgZGVmYXVsdCBhcmd1bWVudHNcbiAgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoYXJncyk7XG4gIGxvZy5kZWJ1ZyhgQ3JlYXRpbmcgQURCIHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICByZXR1cm4gbmV3IFN1YlByb2Nlc3ModGhpcy5nZXRBZGJQYXRoKCksIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBhZGIgcG9ydC5cbiAqIEB0b2RvIGNhbiBwcm9iYWJseSBkZXByZWNhdGUgdGhpcyBub3cgdGhhdCB0aGUgbG9naWMgaXMganVzdCB0byByZWFkIHRoaXMuYWRiUG9ydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBhZGIgcG9ydCBudW1iZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlNlcnZlclBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFkYlBvcnQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgZnJvbSBfYWRiIGRldml2ZXNfIG91dHB1dC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRFbXVsYXRvclBvcnQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIkdldHRpbmcgcnVubmluZyBlbXVsYXRvciBwb3J0XCIpO1xuICBpZiAodGhpcy5lbXVsYXRvclBvcnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbXVsYXRvclBvcnQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZXNbMF0udWRpZCk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIHBvcnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXZpY2VzIGNvbm5lY3RlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgYnkgcGFyc2luZyBlbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1TdHIgLSBFbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSBFaXRoZXIgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIF9mYWxzZV8gaWYgcG9ydCBudW1iZXIgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyA9IGZ1bmN0aW9uIChlbVN0cikge1xuICBsZXQgcG9ydFBhdHRlcm4gPSAvZW11bGF0b3ItKFxcZCspLztcbiAgaWYgKHBvcnRQYXR0ZXJuLnRlc3QoZW1TdHIpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBvcnRQYXR0ZXJuLmV4ZWMoZW1TdHIpWzFdLCAxMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBjdXJyZW50bHkgY29ubmVjdGVkIGVtdWxhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZW11bGF0b3JzXCIpO1xuICB0cnkge1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2UudWRpZCk7XG4gICAgICBpZiAocG9ydCkge1xuICAgICAgICBkZXZpY2UucG9ydCA9IHBvcnQ7XG4gICAgICAgIGVtdWxhdG9ycy5wdXNoKGRldmljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtlbXVsYXRvcnMubGVuZ3RofSBlbXVsYXRvcihzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZW11bGF0b3JzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBfZW11bGF0b3JQb3J0XyBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW1Qb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXRFbXVsYXRvclBvcnQgPSBmdW5jdGlvbiAoZW1Qb3J0KSB7XG4gIHRoaXMuZW11bGF0b3JQb3J0ID0gZW1Qb3J0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGN1cnJlbnQgZGV2aWNlIChfdGhpcy5jdXJEZXZpY2VJZF8pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIFRoZSBkZXZpY2UgaWRlbnRpZmllci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBpZCB0byAke2RldmljZUlkfWApO1xuICB0aGlzLmN1ckRldmljZUlkID0gZGV2aWNlSWQ7XG4gIGxldCBhcmdzSGFzRGV2aWNlID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmluZGV4T2YoJy1zJyk7XG4gIGlmIChhcmdzSGFzRGV2aWNlICE9PSAtMSkge1xuICAgIC8vIHJlbW92ZSB0aGUgb2xkIGRldmljZSBpZCBmcm9tIHRoZSBhcmd1bWVudHNcbiAgICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muc3BsaWNlKGFyZ3NIYXNEZXZpY2UsIDIpO1xuICB9XG4gIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5wdXNoKCctcycsIGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgY3VycmVudCBkZXZpY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VPYmogLSBUaGUgZGV2aWNlIG9iamVjdCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VPYmopIHtcbiAgbGV0IGRldmljZUlkID0gZGV2aWNlT2JqLnVkaWQ7XG4gIGxldCBlbVBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlSWQpO1xuICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbVBvcnQpO1xuICB0aGlzLnNldERldmljZUlkKGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkQgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICBsb2cuZGVidWcoYFRyeWluZyB0byBmaW5kICR7YXZkTmFtZX0gZW11bGF0b3JgKTtcbiAgdHJ5IHtcbiAgICBsZXQgZW11bGF0b3JzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMoKTtcbiAgICBmb3IgKGxldCBlbXVsYXRvciBvZiBlbXVsYXRvcnMpIHtcbiAgICAgIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtdWxhdG9yLnBvcnQpO1xuICAgICAgbGV0IHJ1bm5pbmdBVkROYW1lID0gYXdhaXQgdGhpcy5zZW5kVGVsbmV0Q29tbWFuZChcImF2ZCBuYW1lXCIpO1xuICAgICAgaWYgKGF2ZE5hbWUgPT09IHJ1bm5pbmdBVkROYW1lKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgRm91bmQgZW11bGF0b3IgJHthdmROYW1lfSBpbiBwb3J0ICR7ZW11bGF0b3IucG9ydH1gKTtcbiAgICAgICAgdGhpcy5zZXREZXZpY2VJZChlbXVsYXRvci51ZGlkKTtcbiAgICAgICAgcmV0dXJuIGVtdWxhdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYEVtdWxhdG9yICR7YXZkTmFtZX0gbm90IHJ1bm5pbmdgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBBVkQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gRW11bGF0b3IgbmFtZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzIwMDAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHdhaXQgdW50aWwgYXQgbGVhc3Qgb25lIHJ1bm5pbmcgQVZEIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZGV0ZWN0ZWQuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gZGV2aWNlIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiB0aGUgdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lLCB0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBsZXQgcnVubmluZ0F2ZDtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bm5pbmdBdmQgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZS5yZXBsYWNlKCdAJywgJycpKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5pbmdBdmQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhlLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAxMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRCB3aXRoIHJldHJ5LiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgcmV0dXJuIHJ1bm5pbmdBdmQ7XG59O1xuXG4vKipcbiAqIFNodXRkb3duIGFsbCBydW5uaW5nIGVtdWxhdG9ycyBieSBraWxsaW5nIHRoZWlyIHByb2Nlc3Nlcy5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYga2lsbGluZyB0b29sIHJldHVybmVkIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsQWxsRW11bGF0b3JzID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsZXQgY21kLCBhcmdzO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gJ1RBU0tLSUxMJztcbiAgICBhcmdzID0gWydUQVNLS0lMTCcsICcvSU0nLCAnZW11bGF0b3IuZXhlJ107XG4gIH0gZWxzZSB7XG4gICAgY21kID0gJy91c3IvYmluL2tpbGxhbGwnO1xuICAgIGFyZ3MgPSBbJy1tJywgJ2VtdWxhdG9yKiddO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyhjbWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBraWxsaW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgZW11bGF0b3Igd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gTm8gZXJyb3JcbiAqIGlzIHRocm93biBpcyBnaXZlbiBhdmQgZG9lcyBub3QgZXhpc3QvaXMgbm90IHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVtdWxhdG9yIHRvIGJlIGtpbGxlZC4gSWYgZW1wdHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY3VycmVudCBlbXVsYXRvciB3aWxsIGJlIGtpbGxlZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRocm93aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4Y2VwdGlvbiBhYm91dCB1bnN1Y2Nlc3NmdWwga2lsbGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBlbXVsYXRvciB3YXMga2lsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGEgZmFpbHVyZSBieSBraWxsaW5nIHRoZSBlbXVsYXRvclxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsRW11bGF0b3IgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSA9IG51bGwsIHRpbWVvdXQgPSA2MDAwMCkge1xuICBpZiAodXRpbC5oYXNWYWx1ZShhdmROYW1lKSkge1xuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgJyR7YXZkTmFtZX0nYCk7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUpO1xuICAgIGlmICghZGV2aWNlKSB7XG4gICAgICBsb2cuaW5mbyhgTm8gYXZkIHdpdGggbmFtZSAnJHthdmROYW1lfScgcnVubmluZy4gU2tpcHBpbmcga2lsbCBzdGVwLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBraWxsaW5nIHRoZSBjdXJyZW50IGF2ZFxuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgd2l0aCBpZCAnJHt0aGlzLmN1ckRldmljZUlkfSdgKTtcbiAgICBpZiAoIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpKSB7XG4gICAgICBsb2cuZGVidWcoYEVtdWxhdG9yIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nIG5vdCBjb25uZWN0ZWQuIFNraXBwaW5nIGtpbGwgc3RlcGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAna2lsbCddKTtcbiAgbG9nLmRlYnVnKGBXYWl0aW5nIHVwIHRvICR7dGltZW91dH1tcyB1bnRpbCB0aGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMga2lsbGVkYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXRpbC5oYXNWYWx1ZShhdmROYW1lKVxuICAgICAgICAgID8gIWF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKVxuICAgICAgICAgIDogIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpO1xuICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dCxcbiAgICAgIGludGVydmFsTXM6IDIwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBlbXVsYXRvciAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBpcyBzdGlsbCBydW5uaW5nIGFmdGVyIGJlaW5nIGtpbGxlZCAke3RpbWVvdXR9bXMgYWdvYCk7XG4gIH1cbiAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBraWxsZWQgdGhlICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGVtdWxhdG9yYCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTdGFydCBhbiBlbXVsYXRvciB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgYW5kIHdhaXQgdW50aWwgaXQgaXMgZnVsbCBzdGFydGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgYW4gZXhpc3RpbmcgZW11bGF0b3IuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gYXZkQXJncyAtIEFkZGl0aW9uYWwgZW11bGF0b3IgY29tbWFuZCBsaW5lIGFyZ3VtZW50LlxuICogQHBhcmFtIHs/c3RyaW5nfSBsYW5ndWFnZSAtIEVtdWxhdG9yIHN5c3RlbSBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7P2NvdW50cnl9IGNvdW50cnkgLSBFbXVsYXRvciBzeXN0ZW0gY291bnRyeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhdmRMYXVuY2hUaW1lb3V0IFs2MDAwMF0gLSBFbXVsYXRvciBzdGFydHVwIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5VGltZXMgWzFdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YXJ0dXAgcmV0cmllcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3IgZmFpbHMgdG8gc3RhcnQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5sYXVuY2hBVkQgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSwgYXZkQXJncywgbGFuZ3VhZ2UsIGNvdW50cnksXG4gIGF2ZExhdW5jaFRpbWVvdXQgPSA2MDAwMCwgYXZkUmVhZHlUaW1lb3V0ID0gNjAwMDAsIHJldHJ5VGltZXMgPSAxKSB7XG4gIGxvZy5kZWJ1ZyhgTGF1bmNoaW5nIEVtdWxhdG9yIHdpdGggQVZEICR7YXZkTmFtZX0sIGxhdW5jaFRpbWVvdXQgYCArXG4gICAgICAgICAgICBgJHthdmRMYXVuY2hUaW1lb3V0fW1zIGFuZCByZWFkeVRpbWVvdXQgJHthdmRSZWFkeVRpbWVvdXR9bXNgKTtcbiAgbGV0IGVtdWxhdG9yQmluYXJ5UGF0aCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChcImVtdWxhdG9yXCIpO1xuICBpZiAoYXZkTmFtZVswXSA9PT0gXCJAXCIpIHtcbiAgICBhdmROYW1lID0gYXZkTmFtZS5zdWJzdHIoMSk7XG4gIH1cbiAgYXdhaXQgdGhpcy5jaGVja0F2ZEV4aXN0KGF2ZE5hbWUpO1xuICBsZXQgbGF1bmNoQXJncyA9IFtcIi1hdmRcIiwgYXZkTmFtZV07XG4gIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMYW5ndWFnZSB0byAke2xhbmd1YWdlfWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5sYW5ndWFnZT0ke2xhbmd1YWdlLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgQ291bnRyeSB0byAke2NvdW50cnl9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKFwiLXByb3BcIiwgYHBlcnNpc3Quc3lzLmNvdW50cnk9JHtjb3VudHJ5LnRvVXBwZXJDYXNlKCl9YCk7XG4gIH1cbiAgbGV0IGxvY2FsZTtcbiAgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpICYmIF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpICsgXCItXCIgKyBjb3VudHJ5LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhsYW5ndWFnZSkpIHtcbiAgICBsb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2NhbGUgPSBjb3VudHJ5O1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGxvY2FsZSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgTG9jYWxlIHRvICR7bG9jYWxlfWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5sb2NhbGU9JHtsb2NhbGV9YCk7XG4gIH1cbiAgaWYgKCFfLmlzRW1wdHkoYXZkQXJncykpIHtcbiAgICBsYXVuY2hBcmdzLnB1c2goLi4uKF8uaXNBcnJheShhdmRBcmdzKSA/IGF2ZEFyZ3MgOiBhdmRBcmdzLnNwbGl0KCcgJykpKTtcbiAgfVxuICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7ZW11bGF0b3JCaW5hcnlQYXRofScgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGxhdW5jaEFyZ3MpfWApO1xuICBsZXQgcHJvYyA9IG5ldyBTdWJQcm9jZXNzKGVtdWxhdG9yQmluYXJ5UGF0aCwgbGF1bmNoQXJncyk7XG4gIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gIHByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCBzdGRlcnIgfHwgJycpLnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbikpIHtcbiAgICAgIGxvZy5pbmZvKGBbQVZEIE9VVFBVVF0gJHtsaW5lfWApO1xuICAgIH1cbiAgfSk7XG4gIHByb2Mub24oJ2RpZScsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICBsb2cud2FybihgRW11bGF0b3IgYXZkICR7YXZkTmFtZX0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9JHtzaWduYWwgPyBgLCBzaWduYWwgJHtzaWduYWx9YCA6ICcnfWApO1xuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5KGF2ZE5hbWUsIGF2ZExhdW5jaFRpbWVvdXQpKTtcbiAgYXdhaXQgdGhpcy53YWl0Rm9yRW11bGF0b3JSZWFkeShhdmRSZWFkeVRpbWVvdXQpO1xuICByZXR1cm4gcHJvYztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQURCVmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb25TdHJpbmcgLSBBREIgdmVyc2lvbiBhcyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHZlcnNpb25GbG9hdCAtIFZlcnNpb24gbnVtYmVyIGFzIGZsb2F0IHZhbHVlICh1c2VmdWwgZm9yIGNvbXBhcmlzb24pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ham9yIC0gTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWlub3IgLSBNaW5vciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXRjaCAtIFBhdGNoIHZlcnNpb24gbnVtYmVyLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBhZGIgdmVyc2lvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybiB7QURCVmVyc2lvbn0gVGhlIGN1cnJlbnQgYWRiIHZlcnNpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIGFkYiB2ZXJzaW9uLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJWZXJzaW9uID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgYWRiVmVyc2lvbiA9IChhd2FpdCB0aGlzLmFkYkV4ZWMoJ3ZlcnNpb24nKSlcbiAgICAgIC5yZXBsYWNlKC9BbmRyb2lkXFxzRGVidWdcXHNCcmlkZ2VcXHN2ZXJzaW9uXFxzKFtcXGQuXSopW1xcc1xcdy1dKi8sIFwiJDFcIik7XG4gICAgbGV0IHBhcnRzID0gYWRiVmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uU3RyaW5nOiBhZGJWZXJzaW9uLFxuICAgICAgdmVyc2lvbkZsb2F0OiBwYXJzZUZsb2F0KGFkYlZlcnNpb24pLFxuICAgICAgbWFqb3I6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBtaW5vcjogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIHBhdGNoOiBwYXJ0c1syXSA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBhZGIgdmVyc2lvbi4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIGVtdWxhdG9yIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgYXZkcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGVtdWxhdG9yIHRvIHZlcmlmeSBmb3IgZXhpc3RlbmNlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciB3aXRoIGdpdmVuIG5hbWUgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNoZWNrQXZkRXhpc3QgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICBsZXQgY21kLCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJy1saXN0LWF2ZHMnXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsZXQgdW5rbm93bk9wdGlvbkVycm9yID0gbmV3IFJlZ0V4cChcInVua25vd24gb3B0aW9uOiAtbGlzdC1hdmRzXCIsIFwiaVwiKS50ZXN0KGUuc3RkZXJyKTtcbiAgICBpZiAoIXVua25vd25PcHRpb25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleGVjdXRpbmcgY2hlY2tBdmRFeGlzdC4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuXG4gICAgfVxuICAgIGNvbnN0IHNka1ZlcnNpb24gPSBhd2FpdCBnZXRTZGtUb29sc1ZlcnNpb24oKTtcbiAgICBsZXQgYmluYXJ5TmFtZSA9ICdhbmRyb2lkJztcbiAgICBpZiAoc2RrVmVyc2lvbikge1xuICAgICAgaWYgKHNka1ZlcnNpb24ubWFqb3IgPj0gMjUpIHtcbiAgICAgICAgYmluYXJ5TmFtZSA9ICdhdmRtYW5hZ2VyJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oYERlZmF1bHRpbmcgYmluYXJ5IG5hbWUgdG8gJyR7YmluYXJ5TmFtZX0nLCBiZWNhdXNlIFNESyB2ZXJzaW9uIGNhbm5vdCBiZSBwYXJzZWRgKTtcbiAgICB9XG4gICAgLy8gSWYgLWxpc3QtYXZkcyBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSwgdXNlIGFuZHJvaWQgY29tbWFuZCBhcyBhbiBhbHRlcm5hdGl2ZVxuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChiaW5hcnlOYW1lKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWydsaXN0JywgJ2F2ZCcsICctYyddKTtcbiAgfVxuICBpZiAocmVzdWx0LnN0ZG91dC5pbmRleE9mKGF2ZE5hbWUpID09PSAtMSkge1xuICAgIGxldCBleGlzdGluZ3MgPSBgKCR7cmVzdWx0LnN0ZG91dC50cmltKCkucmVwbGFjZSgvW1xcbl0vZywgJyksICgnKX0pYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEF2ZCAnJHthdmROYW1lfScgaXMgbm90IGF2YWlsYWJsZS4gcGxlYXNlIHNlbGVjdCB5b3VyIGF2ZCBuYW1lIGZyb20gb25lIG9mIHRoZXNlOiAnJHtleGlzdGluZ3N9J2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGVtdWxhdG9yIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRW11bGF0b3JSZWFkeSA9IGFzeW5jIGZ1bmN0aW9uICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5zaGVsbChbJ2dldHByb3AnLCAnaW5pdC5zdmMuYm9vdGFuaW0nXSkpLmluY2x1ZGVzKCdzdG9wcGVkJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBwYWNrYWdlIG1hbmFnZXIgc2VydmljZSBtaWdodCBzdGlsbCBiZWluZyBpbml0aWFsaXplZFxuICAgICAgICAvLyBvbiBzbG93IHN5c3RlbXMgZXZlbiBhZnRlciBlbXVsYXRvciBib290aW5nIGlzIGNvbXBsZXRlZC5cbiAgICAgICAgLy8gVGhlIHVzdWFsIG91dHB1dCBvZiBgcG0gZ2V0LWluc3RhbGwtbG9jYXRpb25gIGNvbW1hbmQgbG9va3MgbGlrZSBgMFthdXRvXWBcbiAgICAgICAgcmV0dXJuIC9cXGQrXFxbXFx3K1xcXS8udGVzdChhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAnZ2V0LWluc3RhbGwtbG9jYXRpb24nXSkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgV2FpdGluZyBmb3IgZW11bGF0b3Igc3RhcnR1cC4gSW50ZXJtZWRpYXRlIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAzMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluICR7dGltZW91dE1zfW1zYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFwcERldmljZVJlYWR5VGltZW91dCBbMzBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGV2aWNlIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdhaXRpbmcgZm9yIHRoZSBkZXZpY2UgdG8gYmUgYXZhaWxhYmxlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBhd2FpdCBCLmRlbGF5KDIwMDApOyAvLyBsZXQgdGhlIGVtdSBmaW5pc2ggc3RvcHBpbmc7XG4gIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDApO1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RhcnQnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBjb25zdCBzdGFydGVkID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKSkgPT09ICcxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICBjb25zdCBtc2cgPSBgUmVib290IGlzIG5vdCBjb21wbGV0ZWQgYWZ0ZXIgJHtwcm9jZXNzLmhydGltZShzdGFydGVkKVswXX1zYDtcbiAgICBsb2cuZGVidWcobXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIHJvb3QgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9mIHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWwgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgIGlmIHRoZSBzd2l0Y2ggZmFpbGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsncm9vdCddKTtcblxuICAgIC8vIG9uIHJlYWwgZGV2aWNlcyBpbiBzb21lIHNpdHVhdGlvbnMgd2UgZ2V0IGFuIGVycm9yIGluIHRoZSBzdGRvdXRcbiAgICBpZiAoc3Rkb3V0ICYmIHN0ZG91dC5pbmRleE9mKCdhZGJkIGNhbm5vdCBydW4gYXMgcm9vdCcpICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0ZG91dC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIHJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bCBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgaWYgdGhlIHN3aXRjaCBmYWlsZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Vucm9vdCddKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYFVuYWJsZSB0byB1bnJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCB1c2VyIGlzIHJvb3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHJvb3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaWRlbnRpZnlpbmdcbiAqIHRoZSB1c2VyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc1Jvb3QgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoYXdhaXQgdGhpcy5zaGVsbChbJ3dob2FtaSddKSkudHJpbSgpID09PSAncm9vdCc7XG59O1xuXG4vKipcbiAqIFZlcmlmeSB3aGV0aGVyIGEgcmVtb3RlIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB2ZXJpZnkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBwYXRoIGV4aXN0cyBvbiB0aGUgZGV2aWNlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlRXhpc3RzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoKTtcbiAgcmV0dXJuIGZpbGVzLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3V0cHV0IG9mIF9sc18gY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggKHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgX2xzXyBjb21tYW5kKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IG9wdHMgW1tdXSAtIEFkZGl0aW9uYWwgX2xzXyBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBfbHNfIG91dHB1dCBhcyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBvZiB0aGUgZ2l2ZW4gX3JlbW90ZVBhdGhfXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgsIG9wdHMgPSBbXSkge1xuICB0cnkge1xuICAgIGxldCBhcmdzID0gWydscycsIC4uLm9wdHMsIHJlbW90ZVBhdGhdO1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdChcIlxcblwiKTtcbiAgICByZXR1cm4gbGluZXMubWFwKChsKSA9PiBsLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5maWx0ZXIoKGwpID0+IGwuaW5kZXhPZihcIk5vIHN1Y2ggZmlsZVwiKSA9PT0gLTEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScpID09PSAtMSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSBwYXJ0aWN1bGFyIGZpbGUgbG9jYXRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdGhlIGZpbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEZpbGUgc2l6ZSBpbiBieXRlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gZmlsZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZVNpemUgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoLCBbJy1sYSddKTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbW90ZSBwYXRoIGlzIG5vdCBhIGZpbGVgKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9mT3M0UDQvOFxuICAgIGNvbnN0IG1hdGNoID0gL1tyd3hzU3RUXFwtK117MTB9W1xcc1xcZF0qXFxzW15cXHNdK1xccytbXlxcc10rXFxzKyhcXGQrKS8uZXhlYyhmaWxlc1swXSk7XG4gICAgaWYgKCFtYXRjaCB8fCBfLmlzTmFOKHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBzaXplIGZyb20gbGlzdCBvdXRwdXQ6ICcke2ZpbGVzWzBdfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBmaWxlIHNpemUgZm9yICcke3JlbW90ZVBhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnN0YWxscyB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgb24gYSByb290ZWQgcmVhbCBkZXZpY2Ugb3JcbiAqIGFuIGVtdWxhdG9yLiBUaGUgZW11bGF0b3IgbXVzdCBiZSBleGVjdXRlZCB3aXRoIGAtd3JpdGFibGUtc3lzdGVtYFxuICogY29tbWFuZCBsaW5lIG9wdGlvbiBhbmQgYWRiIGRhZW1vbiBzaG91bGQgYmUgcnVubmluZyBpbiByb290XG4gKiBtb2RlIGZvciB0aGlzIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LiBUaGUgbWV0aG9kIGFsc28gcmVxdWlyZXNcbiAqIG9wZW5zc2wgdG9vbCB0byBiZSBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbS5cbiAqIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzEwOTY0XG4gKiBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgdG9waWNcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGluc3RhbGxpbmcgdGhlIGNlcnRpZmljYXRlXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmluc3RhbGxNaXRtQ2VydGlmaWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoY2VydCkge1xuICBjb25zdCBvcGVuU3NsID0gYXdhaXQgZ2V0T3BlblNzbEZvck9zKCk7XG5cbiAgaWYgKCFfLmlzQnVmZmVyKGNlcnQpKSB7XG4gICAgY2VydCA9IEJ1ZmZlci5mcm9tKGNlcnQsICdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzcmNDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsICdzb3VyY2UuY2VyJyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHNyY0NlcnQsIGNlcnQpO1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCBzcmNDZXJ0XSk7XG4gICAgY29uc3QgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICAgIGxvZy5kZWJ1ZyhgR290IGNlcnRpZmljYXRlIGhhc2g6ICR7Y2VydEhhc2h9YCk7XG4gICAgbG9nLmRlYnVnKCdQcmVwYXJpbmcgY2VydGlmaWNhdGUgY29udGVudCcpO1xuICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1pbicsIHNyY0NlcnRdLCB7aXNCdWZmZXI6IHRydWV9KSk7XG4gICAgbGV0IGRzdENlcnRDb250ZW50ID0gc3Rkb3V0O1xuICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JyxcbiAgICAgICctaW4nLCBzcmNDZXJ0LFxuICAgICAgJy10ZXh0JyxcbiAgICAgICctZmluZ2VycHJpbnQnLFxuICAgICAgJy1ub291dCddLCB7aXNCdWZmZXI6IHRydWV9KSk7XG4gICAgZHN0Q2VydENvbnRlbnQgPSBCdWZmZXIuY29uY2F0KFtkc3RDZXJ0Q29udGVudCwgc3Rkb3V0XSk7XG4gICAgY29uc3QgZHN0Q2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCBgJHtjZXJ0SGFzaH0uMGApO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RDZXJ0LCBkc3RDZXJ0Q29udGVudCk7XG4gICAgbG9nLmRlYnVnKCdSZW1vdW50aW5nIC9zeXN0ZW0gaW4gcncgbW9kZScpO1xuICAgIC8vIFNvbWV0aW1lcyBlbXVsYXRvciByZWJvb3QgaXMgc3RpbGwgbm90IGZ1bGx5IGZpbmlzaGVkIG9uIHRoaXMgc3RhZ2UsIHNvIHJldHJ5XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCg1LCAyMDAwLCBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmFkYkV4ZWMoWydyZW1vdW50J10pKTtcbiAgICBsb2cuZGVidWcoYFVwbG9hZGluZyB0aGUgZ2VuZXJhdGVkIGNlcnRpZmljYXRlIGZyb20gJyR7ZHN0Q2VydH0nIHRvICcke0NFUlRTX1JPT1R9J2ApO1xuICAgIGF3YWl0IHRoaXMucHVzaChkc3RDZXJ0LCBDRVJUU19ST09UKTtcbiAgICBsb2cuZGVidWcoJ1JlbW91bnRpbmcgL3N5c3RlbSB0byBjb25maXJtIGNoYW5nZXMnKTtcbiAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydyZW1vdW50J10pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbmplY3QgdGhlIGN1c3RvbSBjZXJ0aWZpY2F0ZS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgRG8geW91IGhhdmUgcm9vdCBwZXJtaXNzaW9ucyBvbiB0aGUgZGV2aWNlPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgfVxufTtcblxuLyoqXG4gKiBWZXJpZmllcyBpZiB0aGUgZ2l2ZW4gcm9vdCBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZCBvbiB0aGUgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2VydCAtIGJhc2U2NC1kZWNvZGVkIGNvbnRlbnQgb2YgdGhlIGFjdHVhbCBjZXJ0aWZpY2F0ZVxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYSBidWZmZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuc3NsIHRvb2wgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtXG4gKiBvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hlY2tpbmcgdGhlIGNlcnRpZmljYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWRcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQgPSBhc3luYyBmdW5jdGlvbiAoY2VydCkge1xuICBjb25zdCBvcGVuU3NsID0gYXdhaXQgZ2V0T3BlblNzbEZvck9zKCk7XG5cbiAgaWYgKCFfLmlzQnVmZmVyKGNlcnQpKSB7XG4gICAgY2VydCA9IEJ1ZmZlci5mcm9tKGNlcnQsICdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgbGV0IGNlcnRIYXNoO1xuICB0cnkge1xuICAgIGNvbnN0IHRtcENlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgJ3NvdXJjZS5jZXInKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodG1wQ2VydCwgY2VydCk7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctbm9vdXQnLCAnLWhhc2gnLCAnLWluJywgdG1wQ2VydF0pO1xuICAgIGNlcnRIYXNoID0gc3Rkb3V0LnRyaW0oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmV0cmlldmUgdGhlIGNlcnRpZmljYXRlIGhhc2guIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXMgdGhlIGNlcnRpZmljYXRlIHByb3Blcmx5IGVuY29kZWQgaW50byBiYXNlNjQtc3RyaW5nPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgfVxuICBjb25zdCBkc3RQYXRoID0gcGF0aC5wb3NpeC5yZXNvbHZlKENFUlRTX1JPT1QsIGAke2NlcnRIYXNofS4wYCk7XG4gIGxvZy5kZWJ1ZyhgQ2hlY2tpbmcgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIGF0ICcke2RzdFBhdGh9J2ApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5maWxlRXhpc3RzKGRzdFBhdGgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3lzdGVtQ2FsbE1ldGhvZHM7XG5leHBvcnQgeyBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgfTtcbiJdLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jYWxscy5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
