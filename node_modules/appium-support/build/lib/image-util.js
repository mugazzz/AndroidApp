"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cropBase64Image = cropBase64Image;
exports.base64ToImage = base64ToImage;
exports.imageToBase64 = imageToBase64;
exports.cropImage = cropImage;
exports.getImagesMatches = getImagesMatches;
exports.getImagesSimilarity = getImagesSimilarity;
exports.getImageOccurrence = getImageOccurrence;
exports.getJimpImage = getJimpImage;
exports.MIME_BMP = exports.MIME_PNG = exports.MIME_JPEG = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _jimp = _interopRequireDefault(require("jimp"));

var _buffer = require("buffer");

var _pngjs = require("pngjs");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _util = require("./util");

const MIME_JPEG = _jimp.default.MIME_JPEG,
      MIME_PNG = _jimp.default.MIME_PNG,
      MIME_BMP = _jimp.default.MIME_BMP;
exports.MIME_BMP = MIME_BMP;
exports.MIME_PNG = MIME_PNG;
exports.MIME_JPEG = MIME_JPEG;
let cv = null;
const BYTES_IN_PIXEL_BLOCK = 4;
const SCANLINE_FILTER_METHOD = 4;
const DEFAULT_MATCH_THRESHOLD = 0.5;
const AVAILABLE_DETECTORS = ['AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB'];
const AVAILABLE_MATCHING_FUNCTIONS = ['FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2'];

function getJimpImage(_x) {
  return _getJimpImage.apply(this, arguments);
}

function _getJimpImage() {
  _getJimpImage = (0, _asyncToGenerator2.default)(function* (data) {
    return yield new _bluebird.default((resolve, reject) => {
      if (!_lodash.default.isString(data) && !_lodash.default.isBuffer(data)) {
        return reject(new Error("Must initialize jimp object with string or buffer"));
      }

      if (_lodash.default.isString(data)) {
        data = _buffer.Buffer.from(data, 'base64');
      }

      new _jimp.default(data, (err, imgObj) => {
        if (err) {
          return reject(err);
        }

        if (!imgObj) {
          return reject(new Error("Could not create jimp image from that data"));
        }

        imgObj._getBuffer = imgObj.getBuffer.bind(imgObj);
        imgObj.getBuffer = _bluebird.default.promisify(imgObj._getBuffer, {
          context: imgObj
        });
        resolve(imgObj);
      });
    });
  });
  return _getJimpImage.apply(this, arguments);
}

function initOpenCV() {
  if (!cv) {
    try {
      cv = require('opencv4nodejs');
    } catch (ign) {}
  }

  if (!cv) {
    throw new Error('opencv4nodejs module is required to use OpenCV features. ' + 'Please install it first (npm i -g opencv4nodejs) and restart Appium. ' + 'Read https://github.com/justadudewhohacks/opencv4nodejs#how-to-install for more details on this topic.');
  }
}

function detectAndCompute(_x2, _x3) {
  return _detectAndCompute.apply(this, arguments);
}

function _detectAndCompute() {
  _detectAndCompute = (0, _asyncToGenerator2.default)(function* (img, detector) {
    const keyPoints = yield detector.detectAsync(img);
    const descriptor = yield detector.computeAsync(img, keyPoints);
    return {
      keyPoints,
      descriptor
    };
  });
  return _detectAndCompute.apply(this, arguments);
}

function calculateMatchedRect(matchedPoints) {
  if (matchedPoints.length < 2) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  const pointsSortedByDistance = matchedPoints.map(point => [Math.sqrt(point.x * point.x + point.y * point.y), point]).sort((pair1, pair2) => pair1[0] >= pair2[0]).map(pair => pair[1]);

  const firstPoint = _lodash.default.head(pointsSortedByDistance);

  const lastPoint = _lodash.default.last(pointsSortedByDistance);

  const topLeftPoint = {
    x: firstPoint.x <= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y <= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  const bottomRightPoint = {
    x: firstPoint.x >= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y >= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  return {
    x: topLeftPoint.x,
    y: topLeftPoint.y,
    width: bottomRightPoint.x - topLeftPoint.x,
    height: bottomRightPoint.y - topLeftPoint.y
  };
}

function highlightRegion(mat, region) {
  if (region.width <= 0 || region.height <= 0) {
    return;
  }

  const color = new cv.Vec(0, 0, 255);
  const thickness = 2;
  mat.drawRectangle(new cv.Rect(region.x, region.y, region.width, region.height), color, thickness, cv.LINE_8);
  return mat;
}

function getImagesMatches(_x4, _x5) {
  return _getImagesMatches.apply(this, arguments);
}

function _getImagesMatches() {
  _getImagesMatches = (0, _asyncToGenerator2.default)(function* (img1Data, img2Data, options = {}) {
    initOpenCV();
    const _options$detectorName = options.detectorName,
          detectorName = _options$detectorName === void 0 ? 'ORB' : _options$detectorName,
          _options$visualize = options.visualize,
          visualize = _options$visualize === void 0 ? false : _options$visualize,
          goodMatchesFactor = options.goodMatchesFactor,
          _options$matchFunc = options.matchFunc,
          matchFunc = _options$matchFunc === void 0 ? 'BruteForce' : _options$matchFunc;

    if (!_lodash.default.includes(AVAILABLE_DETECTORS, detectorName)) {
      throw new Error(`'${detectorName}' detector is unknown. ` + `Only ${JSON.stringify(AVAILABLE_DETECTORS)} detectors are supported.`);
    }

    if (!_lodash.default.includes(AVAILABLE_MATCHING_FUNCTIONS, matchFunc)) {
      throw new Error(`'${matchFunc}' matching function is unknown. ` + `Only ${JSON.stringify(AVAILABLE_MATCHING_FUNCTIONS)} matching functions are supported.`);
    }

    const detector = new cv[`${detectorName}Detector`]();

    const _ref = yield _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]),
          _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          img1 = _ref2[0],
          img2 = _ref2[1];

    const _ref3 = yield _bluebird.default.all([detectAndCompute(img1, detector), detectAndCompute(img2, detector)]),
          _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
          result1 = _ref4[0],
          result2 = _ref4[1];

    let matches = [];

    try {
      matches = yield cv[`match${matchFunc}Async`](result1.descriptor, result2.descriptor);
    } catch (e) {
      throw new Error(`Cannot find any matches between the given images. Try another detection algorithm. ` + ` Original error: ${e}`);
    }

    const totalCount = matches.length;

    if ((0, _util.hasValue)(goodMatchesFactor)) {
      if (_lodash.default.isFunction(goodMatchesFactor)) {
        const distances = matches.map(match => match.distance);

        const minDistance = _lodash.default.min(distances);

        const maxDistance = _lodash.default.max(distances);

        matches = matches.filter(match => goodMatchesFactor(match.distance, minDistance, maxDistance));
      } else {
        if (matches.length > goodMatchesFactor) {
          matches = matches.sort((match1, match2) => match1.distance - match2.distance).slice(0, goodMatchesFactor);
        }
      }
    }

    const points1 = matches.map(match => result1.keyPoints[match.queryIdx].point);
    const rect1 = calculateMatchedRect(points1);
    const points2 = matches.map(match => result2.keyPoints[match.trainIdx].point);
    const rect2 = calculateMatchedRect(points2);
    const result = {
      points1,
      rect1,
      points2,
      rect2,
      totalCount,
      count: matches.length
    };

    if (visualize) {
      const visualization = cv.drawMatches(img1, img2, result1.keyPoints, result2.keyPoints, matches);
      highlightRegion(visualization, rect1);
      highlightRegion(visualization, {
        x: img1.cols + rect2.x,
        y: rect2.y,
        width: rect2.width,
        height: rect2.height
      });
      result.visualization = yield cv.imencodeAsync('.png', visualization);
    }

    return result;
  });
  return _getImagesMatches.apply(this, arguments);
}

function getImagesSimilarity(_x6, _x7) {
  return _getImagesSimilarity.apply(this, arguments);
}

function _getImagesSimilarity() {
  _getImagesSimilarity = (0, _asyncToGenerator2.default)(function* (img1Data, img2Data, options = {}) {
    initOpenCV();
    const _options$visualize2 = options.visualize,
          visualize = _options$visualize2 === void 0 ? false : _options$visualize2;

    let _ref5 = yield _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]),
        _ref6 = (0, _slicedToArray2.default)(_ref5, 2),
        template = _ref6[0],
        reference = _ref6[1];

    if (template.rows !== reference.rows || template.cols !== reference.cols) {
      throw new Error('Both images are expected to have the same size in order to ' + 'calculate the similarity score.');
    }

    var _ref7 = yield _bluebird.default.all([template.convertToAsync(cv.CV_8UC3), reference.convertToAsync(cv.CV_8UC3)]);

    var _ref8 = (0, _slicedToArray2.default)(_ref7, 2);

    template = _ref8[0];
    reference = _ref8[1];
    const matched = yield reference.matchTemplateAsync(template, cv.TM_CCOEFF_NORMED);
    const minMax = yield matched.minMaxLocAsync();
    const result = {
      score: minMax.maxVal
    };

    if (visualize) {
      const resultMat = new cv.Mat(template.rows, template.cols * 2, cv.CV_8UC3);
      yield _bluebird.default.all([reference.copyToAsync(resultMat.getRegion(new cv.Rect(0, 0, reference.cols, reference.rows))), template.copyToAsync(resultMat.getRegion(new cv.Rect(reference.cols, 0, template.cols, template.rows)))]);
      let mask = reference.absdiff(template);
      mask = yield mask.cvtColorAsync(cv.COLOR_BGR2GRAY);
      let contours = [];

      try {
        mask = yield mask.thresholdAsync(128, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
        contours = yield mask.findContoursAsync(cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      } catch (ign) {}

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = contours[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const contour = _step.value;
          const boundingRect = contour.boundingRect();
          highlightRegion(resultMat, boundingRect);
          highlightRegion(resultMat, {
            x: reference.cols + boundingRect.x,
            y: boundingRect.y,
            width: boundingRect.width,
            height: boundingRect.height
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      result.visualization = yield cv.imencodeAsync('.png', resultMat);
    }

    return result;
  });
  return _getImagesSimilarity.apply(this, arguments);
}

function getImageOccurrence(_x8, _x9) {
  return _getImageOccurrence.apply(this, arguments);
}

function _getImageOccurrence() {
  _getImageOccurrence = (0, _asyncToGenerator2.default)(function* (fullImgData, partialImgData, options = {}) {
    initOpenCV();
    const _options$visualize3 = options.visualize,
          visualize = _options$visualize3 === void 0 ? false : _options$visualize3,
          _options$threshold = options.threshold,
          threshold = _options$threshold === void 0 ? DEFAULT_MATCH_THRESHOLD : _options$threshold;

    const _ref9 = yield _bluebird.default.all([cv.imdecodeAsync(fullImgData), cv.imdecodeAsync(partialImgData)]),
          _ref10 = (0, _slicedToArray2.default)(_ref9, 2),
          fullImg = _ref10[0],
          partialImg = _ref10[1];

    const result = {};

    try {
      const matched = yield fullImg.matchTemplateAsync(partialImg, cv.TM_CCOEFF_NORMED);
      const minMax = yield matched.minMaxLocAsync();

      if (minMax.maxVal < threshold) {
        throw new Error(`Cannot find any occurrences of the partial image in the full ` + `image above the threshold of ${threshold}. Highest match value ` + `found was ${minMax.maxVal}`);
      }

      result.rect = {
        x: minMax.maxLoc.x,
        y: minMax.maxLoc.y,
        width: partialImg.cols,
        height: partialImg.rows
      };
    } catch (e) {
      throw new Error(`Cannot find any occurences of the partial image in the full image. ` + `Original error: ${e}`);
    }

    if (visualize) {
      highlightRegion(fullImg, result.rect);
      result.visualization = yield cv.imencodeAsync('.png', fullImg);
    }

    return result;
  });
  return _getImageOccurrence.apply(this, arguments);
}

function cropBase64Image(_x10, _x11) {
  return _cropBase64Image.apply(this, arguments);
}

function _cropBase64Image() {
  _cropBase64Image = (0, _asyncToGenerator2.default)(function* (base64Image, rect) {
    const image = yield base64ToImage(base64Image);
    cropImage(image, rect);
    return yield imageToBase64(image);
  });
  return _cropBase64Image.apply(this, arguments);
}

function base64ToImage(_x12) {
  return _base64ToImage.apply(this, arguments);
}

function _base64ToImage() {
  _base64ToImage = (0, _asyncToGenerator2.default)(function* (base64Image) {
    const imageBuffer = _buffer.Buffer.from(base64Image, 'base64');

    return yield new _bluebird.default((resolve, reject) => {
      const image = new _pngjs.PNG({
        filterType: SCANLINE_FILTER_METHOD
      });
      image.parse(imageBuffer, (err, image) => {
        if (err) {
          return reject(err);
        }

        resolve(image);
      });
    });
  });
  return _base64ToImage.apply(this, arguments);
}

function imageToBase64(_x13) {
  return _imageToBase.apply(this, arguments);
}

function _imageToBase() {
  _imageToBase = (0, _asyncToGenerator2.default)(function* (image) {
    return yield new _bluebird.default((resolve, reject) => {
      const chunks = [];
      image.pack().on('data', chunk => chunks.push(chunk)).on('end', () => {
        resolve(_buffer.Buffer.concat(chunks).toString('base64'));
      }).on('error', err => {
        reject(err);
      });
    });
  });
  return _imageToBase.apply(this, arguments);
}

function cropImage(image, rect) {
  const imageRect = {
    width: image.width,
    height: image.height
  };
  const interRect = getRectIntersection(rect, imageRect);

  if (interRect.width < rect.width || interRect.height < rect.height) {
    throw new Error(`Cannot crop ${JSON.stringify(rect)} from ${JSON.stringify(imageRect)} because the intersection between them was not the size of the rect`);
  }

  const firstVerticalPixel = interRect.top;
  const lastVerticalPixel = interRect.top + interRect.height;
  const firstHorizontalPixel = interRect.left;
  const lastHorizontalPixel = interRect.left + interRect.width;
  const croppedArray = [];

  for (let y = firstVerticalPixel; y < lastVerticalPixel; y++) {
    for (let x = firstHorizontalPixel; x < lastHorizontalPixel; x++) {
      const firstByteIdxInPixelBlock = imageRect.width * y + x << 2;

      for (let byteIdx = 0; byteIdx < BYTES_IN_PIXEL_BLOCK; byteIdx++) {
        croppedArray.push(image.data[firstByteIdxInPixelBlock + byteIdx]);
      }
    }
  }

  image.data = _buffer.Buffer.from(croppedArray);
  image.width = interRect.width;
  image.height = interRect.height;
  return image;
}

function getRectIntersection(rect, imageSize) {
  const left = rect.left >= imageSize.width ? imageSize.width : rect.left;
  const top = rect.top >= imageSize.height ? imageSize.height : rect.top;
  const width = imageSize.width >= left + rect.width ? rect.width : imageSize.width - left;
  const height = imageSize.height >= top + rect.height ? rect.height : imageSize.height - top;
  return {
    left,
    top,
    width,
    height
  };
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9pbWFnZS11dGlsLmpzIl0sIm5hbWVzIjpbIk1JTUVfSlBFRyIsIkppbXAiLCJNSU1FX1BORyIsIk1JTUVfQk1QIiwiY3YiLCJCWVRFU19JTl9QSVhFTF9CTE9DSyIsIlNDQU5MSU5FX0ZJTFRFUl9NRVRIT0QiLCJERUZBVUxUX01BVENIX1RIUkVTSE9MRCIsIkFWQUlMQUJMRV9ERVRFQ1RPUlMiLCJBVkFJTEFCTEVfTUFUQ0hJTkdfRlVOQ1RJT05TIiwiZ2V0SmltcEltYWdlIiwiZGF0YSIsIkIiLCJyZXNvbHZlIiwicmVqZWN0IiwiXyIsImlzU3RyaW5nIiwiaXNCdWZmZXIiLCJFcnJvciIsIkJ1ZmZlciIsImZyb20iLCJlcnIiLCJpbWdPYmoiLCJfZ2V0QnVmZmVyIiwiZ2V0QnVmZmVyIiwiYmluZCIsInByb21pc2lmeSIsImNvbnRleHQiLCJpbml0T3BlbkNWIiwicmVxdWlyZSIsImlnbiIsImRldGVjdEFuZENvbXB1dGUiLCJpbWciLCJkZXRlY3RvciIsImtleVBvaW50cyIsImRldGVjdEFzeW5jIiwiZGVzY3JpcHRvciIsImNvbXB1dGVBc3luYyIsImNhbGN1bGF0ZU1hdGNoZWRSZWN0IiwibWF0Y2hlZFBvaW50cyIsImxlbmd0aCIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJwb2ludHNTb3J0ZWRCeURpc3RhbmNlIiwibWFwIiwicG9pbnQiLCJNYXRoIiwic3FydCIsInNvcnQiLCJwYWlyMSIsInBhaXIyIiwicGFpciIsImZpcnN0UG9pbnQiLCJoZWFkIiwibGFzdFBvaW50IiwibGFzdCIsInRvcExlZnRQb2ludCIsImJvdHRvbVJpZ2h0UG9pbnQiLCJoaWdobGlnaHRSZWdpb24iLCJtYXQiLCJyZWdpb24iLCJjb2xvciIsIlZlYyIsInRoaWNrbmVzcyIsImRyYXdSZWN0YW5nbGUiLCJSZWN0IiwiTElORV84IiwiZ2V0SW1hZ2VzTWF0Y2hlcyIsImltZzFEYXRhIiwiaW1nMkRhdGEiLCJvcHRpb25zIiwiZGV0ZWN0b3JOYW1lIiwidmlzdWFsaXplIiwiZ29vZE1hdGNoZXNGYWN0b3IiLCJtYXRjaEZ1bmMiLCJpbmNsdWRlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhbGwiLCJpbWRlY29kZUFzeW5jIiwiaW1nMSIsImltZzIiLCJyZXN1bHQxIiwicmVzdWx0MiIsIm1hdGNoZXMiLCJlIiwidG90YWxDb3VudCIsImlzRnVuY3Rpb24iLCJkaXN0YW5jZXMiLCJtYXRjaCIsImRpc3RhbmNlIiwibWluRGlzdGFuY2UiLCJtaW4iLCJtYXhEaXN0YW5jZSIsIm1heCIsImZpbHRlciIsIm1hdGNoMSIsIm1hdGNoMiIsInNsaWNlIiwicG9pbnRzMSIsInF1ZXJ5SWR4IiwicmVjdDEiLCJwb2ludHMyIiwidHJhaW5JZHgiLCJyZWN0MiIsInJlc3VsdCIsImNvdW50IiwidmlzdWFsaXphdGlvbiIsImRyYXdNYXRjaGVzIiwiY29scyIsImltZW5jb2RlQXN5bmMiLCJnZXRJbWFnZXNTaW1pbGFyaXR5IiwidGVtcGxhdGUiLCJyZWZlcmVuY2UiLCJyb3dzIiwiY29udmVydFRvQXN5bmMiLCJDVl84VUMzIiwibWF0Y2hlZCIsIm1hdGNoVGVtcGxhdGVBc3luYyIsIlRNX0NDT0VGRl9OT1JNRUQiLCJtaW5NYXgiLCJtaW5NYXhMb2NBc3luYyIsInNjb3JlIiwibWF4VmFsIiwicmVzdWx0TWF0IiwiTWF0IiwiY29weVRvQXN5bmMiLCJnZXRSZWdpb24iLCJtYXNrIiwiYWJzZGlmZiIsImN2dENvbG9yQXN5bmMiLCJDT0xPUl9CR1IyR1JBWSIsImNvbnRvdXJzIiwidGhyZXNob2xkQXN5bmMiLCJUSFJFU0hfQklOQVJZIiwiVEhSRVNIX09UU1UiLCJmaW5kQ29udG91cnNBc3luYyIsIlJFVFJfRVhURVJOQUwiLCJDSEFJTl9BUFBST1hfU0lNUExFIiwiY29udG91ciIsImJvdW5kaW5nUmVjdCIsImdldEltYWdlT2NjdXJyZW5jZSIsImZ1bGxJbWdEYXRhIiwicGFydGlhbEltZ0RhdGEiLCJ0aHJlc2hvbGQiLCJmdWxsSW1nIiwicGFydGlhbEltZyIsInJlY3QiLCJtYXhMb2MiLCJjcm9wQmFzZTY0SW1hZ2UiLCJiYXNlNjRJbWFnZSIsImltYWdlIiwiYmFzZTY0VG9JbWFnZSIsImNyb3BJbWFnZSIsImltYWdlVG9CYXNlNjQiLCJpbWFnZUJ1ZmZlciIsIlBORyIsImZpbHRlclR5cGUiLCJwYXJzZSIsImNodW5rcyIsInBhY2siLCJvbiIsImNodW5rIiwicHVzaCIsImNvbmNhdCIsInRvU3RyaW5nIiwiaW1hZ2VSZWN0IiwiaW50ZXJSZWN0IiwiZ2V0UmVjdEludGVyc2VjdGlvbiIsImZpcnN0VmVydGljYWxQaXhlbCIsInRvcCIsImxhc3RWZXJ0aWNhbFBpeGVsIiwiZmlyc3RIb3Jpem9udGFsUGl4ZWwiLCJsZWZ0IiwibGFzdEhvcml6b250YWxQaXhlbCIsImNyb3BwZWRBcnJheSIsImZpcnN0Qnl0ZUlkeEluUGl4ZWxCbG9jayIsImJ5dGVJZHgiLCJpbWFnZVNpemUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztNQUVRQSxTLEdBQWtDQyxhLENBQWxDRCxTO01BQVdFLFEsR0FBdUJELGEsQ0FBdkJDLFE7TUFBVUMsUSxHQUFhRixhLENBQWJFLFE7Ozs7QUFDN0IsSUFBSUMsRUFBRSxHQUFHLElBQVQ7QUF3QkEsTUFBTUMsb0JBQW9CLEdBQUcsQ0FBN0I7QUFDQSxNQUFNQyxzQkFBc0IsR0FBRyxDQUEvQjtBQUNBLE1BQU1DLHVCQUF1QixHQUFHLEdBQWhDO0FBRUEsTUFBTUMsbUJBQW1CLEdBQUcsQ0FDMUIsT0FEMEIsRUFFMUIsT0FGMEIsRUFHMUIsT0FIMEIsRUFJMUIsTUFKMEIsRUFLMUIsTUFMMEIsRUFNMUIsTUFOMEIsRUFPMUIsTUFQMEIsRUFRMUIsTUFSMEIsRUFTMUIsS0FUMEIsQ0FBNUI7QUFZQSxNQUFNQyw0QkFBNEIsR0FBRyxDQUNuQyxZQURtQyxFQUVuQyxZQUZtQyxFQUduQyxjQUhtQyxFQUluQyxtQkFKbUMsRUFLbkMsc0JBTG1DLEVBTW5DLGVBTm1DLENB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QUksQ0FBQzBCLElBQW5FO0FBQ0EsUUFBTUgsR0FBRyxHQUFHdkIsSUFBSSxDQUFDdUIsR0FBTCxJQUFZUSxTQUFTLENBQUN4SSxNQUF0QixHQUErQndJLFNBQVMsQ0FBQ3hJLE1BQXpDLEdBQWtEeUcsSUFBSSxDQUFDdUIsR0FBbkU7QUFDQSxRQUFNakksS0FBSyxHQUFHeUksU0FBUyxDQUFDekksS0FBVixJQUFvQm9JLElBQUksR0FBRzFCLElBQUksQ0FBQzFHLEtBQWhDLEdBQXlDMEcsSUFBSSxDQUFDMUcsS0FBOUMsR0FBdUR5SSxTQUFTLENBQUN6SSxLQUFWLEdBQWtCb0ksSUFBdkY7QUFDQSxRQUFNbkksTUFBTSxHQUFHd0ksU0FBUyxDQUFDeEksTUFBVixJQUFxQmdJLEdBQUcsR0FBR3ZCLElBQUksQ0FBQ3pHLE1BQWhDLEdBQTBDeUcsSUFBSSxDQUFDekcsTUFBL0MsR0FBeUR3SSxTQUFTLENBQUN4SSxNQUFWLEdBQW1CZ0ksR0FBM0Y7QUFDQSxTQUFPO0FBQUNHLElBQUFBLElBQUQ7QUFBT0gsSUFBQUEsR0FBUDtBQUFZakksSUFBQUEsS0FBWjtBQUFtQkMsSUFBQUE7QUFBbkIsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBKaW1wIGZyb20gJ2ppbXAnO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IFBORyB9IGZyb20gJ3BuZ2pzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IGhhc1ZhbHVlIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgeyBNSU1FX0pQRUcsIE1JTUVfUE5HLCBNSU1FX0JNUCB9ID0gSmltcDtcbmxldCBjdiA9IG51bGw7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVnaW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVmdCAtIFRoZSBvZmZzZXQgZnJvbSB0aGUgbGVmdCBzaWRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wIC0gVGhlIG9mZnNldCBmcm9tIHRoZSB0b3BcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBvaW50XG4gKiBAcHJvcGVydHkge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVjdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgdG9wIGxlZnQgY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSBUaGUgYm90dG9tIHJpZ2h0IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHRcbiAqL1xuXG5jb25zdCBCWVRFU19JTl9QSVhFTF9CTE9DSyA9IDQ7XG5jb25zdCBTQ0FOTElORV9GSUxURVJfTUVUSE9EID0gNDtcbmNvbnN0IERFRkFVTFRfTUFUQ0hfVEhSRVNIT0xEID0gMC41O1xuXG5jb25zdCBBVkFJTEFCTEVfREVURUNUT1JTID0gW1xuICAnQUtBWkUnLFxuICAnQUdBU1QnLFxuICAnQlJJU0snLFxuICAnRkFTVCcsXG4gICdHRlRUJyxcbiAgJ0tBWkUnLFxuICAnTVNFUicsXG4gICdTSUZUJyxcbiAgJ09SQicsXG5dO1xuXG5jb25zdCBBVkFJTEFCTEVfTUFUQ0hJTkdfRlVOQ1RJT05TID0gW1xuICAnRmxhbm5CYXNlZCcsXG4gICdCcnV0ZUZvcmNlJyxcbiAgJ0JydXRlRm9yY2VMMScsXG4gICdCcnV0ZUZvcmNlSGFtbWluZycsXG4gICdCcnV0ZUZvcmNlSGFtbWluZ0x1dCcsXG4gICdCcnV0ZUZvcmNlU0wyJyxcbl07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgYSBKaW1wIGltYWdlIG9iamVjdCBmcm9tIGJ1ZmZlciBvciBiYXNlNjQgZGF0YS4gSmltcFxuICogaXMgYSBncmVhdCBsaWJyYXJ5IGhvd2V2ZXIgaXQgZG9lcyBJTyBpbiB0aGUgY29uc3RydWN0b3Igc28gaXQncyBub3RcbiAqIGNvbnZlbmllbnQgZm9yIG91ciBhc3luYy9hd2FpdCBtb2RlbC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGRhdGEgLSBiaW5hcnkgaW1hZ2UgYnVmZmVyIG9yIGJhc2U2NC1lbmNvZGVkIGltYWdlXG4gKiBzdHJpbmdcbiAqIEByZXR1cm5zIHtKaW1wfSAtIHRoZSBqaW1wIGltYWdlIG9iamVjdFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRKaW1wSW1hZ2UgKGRhdGEpIHtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoZGF0YSkgJiYgIV8uaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTXVzdCBpbml0aWFsaXplIGppbXAgb2JqZWN0IHdpdGggc3RyaW5nIG9yIGJ1ZmZlclwiKSk7XG4gICAgfVxuICAgIC8vIGlmIGRhdGEgaXMgYSBzdHJpbmcsIGFzc3VtZSBpdCBpcyBhIGJhc2U2NC1lbmNvZGVkIGltYWdlXG4gICAgaWYgKF8uaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG5ldyBKaW1wKGRhdGEsIChlcnIsIGltZ09iaikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBpZiAoIWltZ09iaikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgamltcCBpbWFnZSBmcm9tIHRoYXQgZGF0YVwiKSk7XG4gICAgICB9XG4gICAgICBpbWdPYmouX2dldEJ1ZmZlciA9IGltZ09iai5nZXRCdWZmZXIuYmluZChpbWdPYmopO1xuICAgICAgaW1nT2JqLmdldEJ1ZmZlciA9IEIucHJvbWlzaWZ5KGltZ09iai5fZ2V0QnVmZmVyLCB7Y29udGV4dDogaW1nT2JqfSk7XG4gICAgICByZXNvbHZlKGltZ09iaik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuY3Y0bm9kZWpzIG1vZHVsZSBpcyBub3QgaW5zdGFsbGVkIG9yIGNhbm5vdCBiZSBsb2FkZWRcbiAqL1xuZnVuY3Rpb24gaW5pdE9wZW5DViAoKSB7XG4gIGlmICghY3YpIHtcbiAgICB0cnkge1xuICAgICAgY3YgPSByZXF1aXJlKCdvcGVuY3Y0bm9kZWpzJyk7XG4gICAgfSBjYXRjaCAoaWduKSB7fVxuICB9XG4gIGlmICghY3YpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wZW5jdjRub2RlanMgbW9kdWxlIGlzIHJlcXVpcmVkIHRvIHVzZSBPcGVuQ1YgZmVhdHVyZXMuICcgK1xuICAgICAgICAgICAgICAgICAgICAnUGxlYXNlIGluc3RhbGwgaXQgZmlyc3QgKG5wbSBpIC1nIG9wZW5jdjRub2RlanMpIGFuZCByZXN0YXJ0IEFwcGl1bS4gJyArXG4gICAgICAgICAgICAgICAgICAgICdSZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9qdXN0YWR1ZGV3aG9oYWNrcy9vcGVuY3Y0bm9kZWpzI2hvdy10by1pbnN0YWxsIGZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0b3BpYy4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hdGNoQ29tcHV0YXRpb25SZXN1bHRcbiAqIEBwcm9wZXJ0eSB7Y3YuRGVzY3JpcHRvck1hdGNofSBkZXNjaXB0b3IgLSBPcGVuQ1YgbWF0Y2ggZGVzY3JpcHRvclxuICogQHByb3BlcnR5IHtBcnJheTxjdi5LZXlQb2ludD59IGtleVBvaW50cyAtIFRoZSBhcnJheSBvZiBrZXkgcG9pbnRzXG4gKi9cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGFuIE9wZW5DViBtYXRjaCBkZXNjcmlwdG9yIG9mIGFuIGltYWdlLCB3aGljaCBjYW4gYmUgdXNlZFxuICogZm9yIGJydXRlLWZvcmNlIG1hdGNoaW5nLlxuICogUmVhZCBodHRwczovL2RvY3Mub3BlbmN2Lm9yZy8zLjAtYmV0YS9kb2MvcHlfdHV0b3JpYWxzL3B5X2ZlYXR1cmUyZC9weV9tYXRjaGVyL3B5X21hdGNoZXIuaHRtbFxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0ge2N2Lk1hdH0gaW1nIEltYWdlIGRhdGFcbiAqIEBwYXJhbSB7Y3YuRmVhdHVyZURldGVjdG9yfSBkZXRlY3RvciBPcGVuQ1YgZmVhdHVyZSBkZXRlY3RvciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm5zIHtNYXRjaENvbXB1dGF0aW9uUmVzdWx0fVxuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RBbmRDb21wdXRlIChpbWcsIGRldGVjdG9yKSB7XG4gIGNvbnN0IGtleVBvaW50cyA9IGF3YWl0IGRldGVjdG9yLmRldGVjdEFzeW5jKGltZyk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBhd2FpdCBkZXRlY3Rvci5jb21wdXRlQXN5bmMoaW1nLCBrZXlQb2ludHMpO1xuICByZXR1cm4ge1xuICAgIGtleVBvaW50cyxcbiAgICBkZXNjcmlwdG9yXG4gIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlZCB0aGUgYm91bmRpbmcgcmVjdCBjb29yZGluYXRlcyBmb3IgdGhlIGFycmF5IG9mIG1hdGNoaW5nIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBtYXRjaGVkUG9pbnRzIEFycmF5IG9mIG1hdGNoaW5nIHBvaW50c1xuICogQHJldHVybnMge1JlY3R9IFRoZSBtYXRjaGluZyBib3VuZGluZyByZWN0IG9yIGEgemVybyByZWN0IGlmIG5vIG1hdGNoXG4gKiBjYW4gYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1hdGNoZWRSZWN0IChtYXRjaGVkUG9pbnRzKSB7XG4gIGlmIChtYXRjaGVkUG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gIH1cblxuICBjb25zdCBwb2ludHNTb3J0ZWRCeURpc3RhbmNlID0gbWF0Y2hlZFBvaW50c1xuICAgIC5tYXAocG9pbnQgPT4gW01hdGguc3FydChwb2ludC54ICogcG9pbnQueCArIHBvaW50LnkgKiBwb2ludC55KSwgcG9pbnRdKVxuICAgIC5zb3J0KChwYWlyMSwgcGFpcjIpID0+IHBhaXIxWzBdID49IHBhaXIyWzBdKVxuICAgIC5tYXAocGFpciA9PiBwYWlyWzFdKTtcbiAgY29uc3QgZmlyc3RQb2ludCA9IF8uaGVhZChwb2ludHNTb3J0ZWRCeURpc3RhbmNlKTtcbiAgY29uc3QgbGFzdFBvaW50ID0gXy5sYXN0KHBvaW50c1NvcnRlZEJ5RGlzdGFuY2UpO1xuICBjb25zdCB0b3BMZWZ0UG9pbnQgPSB7XG4gICAgeDogZmlyc3RQb2ludC54IDw9IGxhc3RQb2ludC54ID8gZmlyc3RQb2ludC54IDogbGFzdFBvaW50LngsXG4gICAgeTogZmlyc3RQb2ludC55IDw9IGxhc3RQb2ludC55ID8gZmlyc3RQb2ludC55IDogbGFzdFBvaW50LnksXG4gIH07XG4gIGNvbnN0IGJvdHRvbVJpZ2h0UG9pbnQgPSB7XG4gICAgeDogZmlyc3RQb2ludC54ID49IGxhc3RQb2ludC54ID8gZmlyc3RQb2ludC54IDogbGFzdFBvaW50LngsXG4gICAgeTogZmlyc3RQb2ludC55ID49IGxhc3RQb2ludC55ID8gZmlyc3RQb2ludC55IDogbGFzdFBvaW50LnksXG4gIH07XG4gIHJldHVybiB7XG4gICAgeDogdG9wTGVmdFBvaW50LngsXG4gICAgeTogdG9wTGVmdFBvaW50LnksXG4gICAgd2lkdGg6IGJvdHRvbVJpZ2h0UG9pbnQueCAtIHRvcExlZnRQb2ludC54LFxuICAgIGhlaWdodDogYm90dG9tUmlnaHRQb2ludC55IC0gdG9wTGVmdFBvaW50LnlcbiAgfTtcbn1cblxuLyoqXG4gKiBEcmF3cyBhIHJlY3Rhbm5nbGUgb24gdGhlIGdpdmVuIGltYWdlIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7Y3YuTWF0fSBtYXQgVGhlIHNvdXJjZSBpbWFnZVxuICogQHBhcmFtIHtSZWN0fSByZWdpb24gVGhlIHJlZ2lvbiB0byBoaWdobGlnaHRcbiAqXG4gKiBAcmV0dXJucyB7Y3YuTWF0fSBUaGUgc2FtZSBpbWFnZSB3aXRoIHRoZSByZWN0YW5nZSBvbiBpdFxuICovXG5mdW5jdGlvbiBoaWdobGlnaHRSZWdpb24gKG1hdCwgcmVnaW9uKSB7XG4gIGlmIChyZWdpb24ud2lkdGggPD0gMCB8fCByZWdpb24uaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoaWdobGlnaHQgaW4gcmVkXG4gIGNvbnN0IGNvbG9yID0gbmV3IGN2LlZlYygwLCAwLCAyNTUpO1xuICBjb25zdCB0aGlja25lc3MgPSAyO1xuICBtYXQuZHJhd1JlY3RhbmdsZShuZXcgY3YuUmVjdChyZWdpb24ueCwgcmVnaW9uLnksIHJlZ2lvbi53aWR0aCwgcmVnaW9uLmhlaWdodCksIGNvbG9yLCB0aGlja25lc3MsIGN2LkxJTkVfOCk7XG4gIHJldHVybiBtYXQ7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWF0Y2hpbmdPcHRpb25zXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGRldGVjdG9yTmFtZSBbJ09SQiddIE9uZSBvZiBwb3NzaWJsZSBPcGVuQ1YgZmVhdHVyZSBkZXRlY3RvciBuYW1lc1xuICogZnJvbSBgQVZBSUxBQkxFX0RFVEVDVE9SU2AgYXJyYXkuXG4gKiBTb21lIG9mIHRoZXNlIG1ldGhvZHMgKEZBU1QsIEFHQVNULCBHRlRULCBGQVNULCBTSUZUIGFuZCBNU0VSKSBhcmUgbm90IGF2YWlsYWJsZVxuICogaW4gdGhlIGRlZmF1bHQgT3BlbkNWIGluc3RhbGxhdGlvbiBhbmQgaGF2ZSB0byBiZSBlbmFibGVkIG1hbnVhbGx5IGJlZm9yZVxuICogbGlicmFyeSBjb21waWxhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbWF0Y2hGdW5jIFsnQnJ1dGVGb3JjZSddIFRoZSBuYW1lIG9mIHRoZSBtYXRjaGluZyBmdW5jdGlvbi5cbiAqIFNob3VsZCBiZSBvbmUgb2YgYEFWQUlMQUJMRV9NQVRDSElOR19GVU5DVElPTlNgIGFycmF5LlxuICogQHByb3BlcnR5IHs/bnVtYmVyfEZ1bmN0aW9ufSBnb29kTWF0Y2hlc0ZhY3RvciBUaGUgbWF4aW11bSBjb3VudCBvZiBcImdvb2RcIiBtYXRjaGVzXG4gKiAoZS4gZy4gd2l0aCBtaW5pbWFsIGRpc3RhbmNlcykgb3IgYSBmdW5jdGlvbiwgd2hpY2ggYWNjZXB0cyAzIGFyZ3VtZW50czogdGhlIGN1cnJlbnQgZGlzdGFuY2UsXG4gKiBtaW5pbWFsIGRpc3RhbmNlLCBtYXhpbXVtIGRpc3RhbmNlIGFuZCByZXR1cm5zIHRydWUgb3IgZmFsc2UgdG8gaW5jbHVkZSBvciBleGNsdWRlIHRoZSBtYXRjaC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHZpc3VhbGl6ZSBbZmFsc2VdIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSByZXN1bHRpbmcgdmlzYWxpemF0aW9uXG4gKiBhcyBhbiBpbWFnZSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXRjaGluZ1Jlc3VsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvdW50IFRoZSBjb3VudCBvZiBtYXRjaGVkIGVkZ2VzIG9uIGJvdGggaW1hZ2VzLlxuICogVGhlIG1vcmUgbWF0Y2hpbmcgZWRnZXMgdGhlcmUgYXJlIG5vIGJvdGggaW1hZ2VzIHRoZSBtb3JlIHNpbWlsYXIgdGhleSBhcmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG90YWxDb3VudCBUaGUgdG90YWwgY291bnQgb2YgbWF0Y2hlZCBlZGdlcyBvbiBib3RoIGltYWdlcy5cbiAqIEl0IGlzIGVxdWFsIHRvIGBjb3VudGAgaWYgYGdvb2RNYXRjaGVzRmFjdG9yYCBkb2VzIG5vdCBsaW1pdCB0aGUgbWF0Y2hlcyxcbiAqIG90aGVyd2lzZSBpdCBjb250YWlucyB0aGUgdG90YWwgY291bnQgb2YgbWF0Y2hlcyBiZWZvcmUgYGdvb2RNYXRjaGVzRmFjdG9yYCBpc1xuICogYXBwbGllZC5cbiAqIEBwcm9wZXJ0eSB7P0J1ZmZlcn0gdmlzdWFsaXphdGlvbiBUaGUgdmlzdWFsaXphdGlvbiBvZiB0aGUgbWF0Y2hpbmcgcmVzdWx0XG4gKiByZXByZXNlbnRlZCBhcyBQTkcgaW1hZ2UgYnVmZmVyLiBUaGlzIHZpc3VhbGl6YXRpb24gbG9va3MgbGlrZVxuICogaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMzExMjU1MjEvMjk3MDI3MzEtYzc5ZTMxNDItODk3Mi0xMWU3LTk0N2UtZGIxMDlkNDE1NDY5LmpwZ1xuICogQHByb3BlcnR5IHtBcnJheTxQb2ludD59IHBvaW50czEgVGhlIGFycmF5IG9mIG1hdGNoaW5nIHBvaW50cyBvbiB0aGUgZmlyc3QgaW1hZ2VcbiAqIEBwcm9wZXJ0eSB7UmVjdH0gcmVjdDEgVGhlIGJvdW5kaW5nIHJlY3QgZm9yIHRoZSBgbWF0Y2hlZFBvaW50czFgIHNldCBvciBhIHplcm8gcmVjdFxuICogaWYgbm90IGVub3VnaCBtYXRjaGluZyBwb2ludHMgYXJlIGZvdW5kXG4gKiBAcHJvcGVydHkge0FycmF5PFBvaW50Pn0gcG9pbnRzMiBUaGUgYXJyYXkgb2YgbWF0Y2hpbmcgcG9pbnRzIG9uIHRoZSBzZWNvbmQgaW1hZ2VcbiAqIEBwcm9wZXJ0eSB7UmVjdH0gcmVjdDIgVGhlIGJvdW5kaW5nIHJlY3QgZm9yIHRoZSBgbWF0Y2hlZFBvaW50czJgIHNldCBvciBhIHplcm8gcmVjdFxuICogaWYgbm90IGVub3VnaCBtYXRjaGluZyBwb2ludHMgYXJlIGZvdW5kXG4gKi9cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb3VudCBvZiBjb21tb24gZWRnZXMgYmV0d2VlbiB0d28gaW1hZ2VzLlxuICogVGhlIGltYWdlcyBtaWdodCBiZSByb3RhdGVkIG9yIHJlc2l6ZWQgcmVsYXRpdmVseSB0byBlYWNoIG90aGVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbWcxRGF0YSBUaGUgZGF0YSBvZiB0aGUgZmlyc3QgaW1hZ2UgcGFja2VkIGludG8gYSBOb2RlSlMgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW1nMkRhdGEgVGhlIGRhdGEgb2YgdGhlIHNlY29uZCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7P01hdGNoaW5nT3B0aW9uc30gb3B0aW9ucyBbe31dIFNldCBvZiBtYXRjaGluZyBvcHRpb25zXG4gKlxuICogQHJldHVybnMge01hdGNoaW5nUmVzdWx0fSBNYWNoaW5nIHJlc3VsdFxuICogQHRocm93cyB7RXJyb3J9IElmIGBkZXRlY3Rvck5hbWVgIHZhbHVlIGlzIHVua25vd24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEltYWdlc01hdGNoZXMgKGltZzFEYXRhLCBpbWcyRGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGluaXRPcGVuQ1YoKTtcblxuICBjb25zdCB7ZGV0ZWN0b3JOYW1lID0gJ09SQicsIHZpc3VhbGl6ZSA9IGZhbHNlLFxuICAgICAgICAgZ29vZE1hdGNoZXNGYWN0b3IsIG1hdGNoRnVuYyA9ICdCcnV0ZUZvcmNlJ30gPSBvcHRpb25zO1xuICBpZiAoIV8uaW5jbHVkZXMoQVZBSUxBQkxFX0RFVEVDVE9SUywgZGV0ZWN0b3JOYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7ZGV0ZWN0b3JOYW1lfScgZGV0ZWN0b3IgaXMgdW5rbm93bi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPbmx5ICR7SlNPTi5zdHJpbmdpZnkoQVZBSUxBQkxFX0RFVEVDVE9SUyl9IGRldGVjdG9ycyBhcmUgc3VwcG9ydGVkLmApO1xuICB9XG4gIGlmICghXy5pbmNsdWRlcyhBVkFJTEFCTEVfTUFUQ0hJTkdfRlVOQ1RJT05TLCBtYXRjaEZ1bmMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHttYXRjaEZ1bmN9JyBtYXRjaGluZyBmdW5jdGlvbiBpcyB1bmtub3duLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9ubHkgJHtKU09OLnN0cmluZ2lmeShBVkFJTEFCTEVfTUFUQ0hJTkdfRlVOQ1RJT05TKX0gbWF0Y2hpbmcgZnVuY3Rpb25zIGFyZSBzdXBwb3J0ZWQuYCk7XG4gIH1cblxuICBjb25zdCBkZXRlY3RvciA9IG5ldyBjdltgJHtkZXRlY3Rvck5hbWV9RGV0ZWN0b3JgXSgpO1xuICBjb25zdCBbaW1nMSwgaW1nMl0gPSBhd2FpdCBCLmFsbChbXG4gICAgY3YuaW1kZWNvZGVBc3luYyhpbWcxRGF0YSksXG4gICAgY3YuaW1kZWNvZGVBc3luYyhpbWcyRGF0YSlcbiAgXSk7XG4gIGNvbnN0IFtyZXN1bHQxLCByZXN1bHQyXSA9IGF3YWl0IEIuYWxsKFtcbiAgICBkZXRlY3RBbmRDb21wdXRlKGltZzEsIGRldGVjdG9yKSxcbiAgICBkZXRlY3RBbmRDb21wdXRlKGltZzIsIGRldGVjdG9yKVxuICBdKTtcbiAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgdHJ5IHtcbiAgICBtYXRjaGVzID0gYXdhaXQgY3ZbYG1hdGNoJHttYXRjaEZ1bmN9QXN5bmNgXShyZXN1bHQxLmRlc2NyaXB0b3IsIHJlc3VsdDIuZGVzY3JpcHRvcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGFueSBtYXRjaGVzIGJldHdlZW4gdGhlIGdpdmVuIGltYWdlcy4gVHJ5IGFub3RoZXIgZGV0ZWN0aW9uIGFsZ29yaXRobS4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAgT3JpZ2luYWwgZXJyb3I6ICR7ZX1gKTtcbiAgfVxuICBjb25zdCB0b3RhbENvdW50ID0gbWF0Y2hlcy5sZW5ndGg7XG4gIGlmIChoYXNWYWx1ZShnb29kTWF0Y2hlc0ZhY3RvcikpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGdvb2RNYXRjaGVzRmFjdG9yKSkge1xuICAgICAgY29uc3QgZGlzdGFuY2VzID0gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2guZGlzdGFuY2UpO1xuICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSBfLm1pbihkaXN0YW5jZXMpO1xuICAgICAgY29uc3QgbWF4RGlzdGFuY2UgPSBfLm1heChkaXN0YW5jZXMpO1xuICAgICAgbWF0Y2hlcyA9IG1hdGNoZXNcbiAgICAgICAgLmZpbHRlcihtYXRjaCA9PiBnb29kTWF0Y2hlc0ZhY3RvcihtYXRjaC5kaXN0YW5jZSwgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IGdvb2RNYXRjaGVzRmFjdG9yKSB7XG4gICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzXG4gICAgICAgICAgLnNvcnQoKG1hdGNoMSwgbWF0Y2gyKSA9PiBtYXRjaDEuZGlzdGFuY2UgLSBtYXRjaDIuZGlzdGFuY2UpXG4gICAgICAgICAgLnNsaWNlKDAsIGdvb2RNYXRjaGVzRmFjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBwb2ludHMxID0gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gcmVzdWx0MS5rZXlQb2ludHNbbWF0Y2gucXVlcnlJZHhdLnBvaW50KTtcbiAgY29uc3QgcmVjdDEgPSBjYWxjdWxhdGVNYXRjaGVkUmVjdChwb2ludHMxKTtcbiAgY29uc3QgcG9pbnRzMiA9IG1hdGNoZXMubWFwKG1hdGNoID0+IHJlc3VsdDIua2V5UG9pbnRzW21hdGNoLnRyYWluSWR4XS5wb2ludCk7XG4gIGNvbnN0IHJlY3QyID0gY2FsY3VsYXRlTWF0Y2hlZFJlY3QocG9pbnRzMik7XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHBvaW50czEsXG4gICAgcmVjdDEsXG4gICAgcG9pbnRzMixcbiAgICByZWN0MixcbiAgICB0b3RhbENvdW50LFxuICAgIGNvdW50OiBtYXRjaGVzLmxlbmd0aCxcbiAgfTtcbiAgaWYgKHZpc3VhbGl6ZSkge1xuICAgIGNvbnN0IHZpc3VhbGl6YXRpb24gPSBjdi5kcmF3TWF0Y2hlcyhpbWcxLCBpbWcyLCByZXN1bHQxLmtleVBvaW50cywgcmVzdWx0Mi5rZXlQb2ludHMsIG1hdGNoZXMpO1xuICAgIGhpZ2hsaWdodFJlZ2lvbih2aXN1YWxpemF0aW9uLCByZWN0MSk7XG4gICAgaGlnaGxpZ2h0UmVnaW9uKHZpc3VhbGl6YXRpb24sIHtcbiAgICAgIHg6IGltZzEuY29scyArIHJlY3QyLngsXG4gICAgICB5OiByZWN0Mi55LFxuICAgICAgd2lkdGg6IHJlY3QyLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0Mi5oZWlnaHRcbiAgICB9KTtcbiAgICByZXN1bHQudmlzdWFsaXphdGlvbiA9IGF3YWl0IGN2LmltZW5jb2RlQXN5bmMoJy5wbmcnLCB2aXN1YWxpemF0aW9uKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbWlsYXJpdHlPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB2aXN1YWxpemUgW2ZhbHNlXSBXaGV0aGVyIHRvIHJldHVybiB0aGUgcmVzdWx0aW5nIHZpc2FsaXphdGlvblxuICogYXMgYW4gaW1hZ2UgKHVzZWZ1bCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2ltaWxhcml0eVJlc3VsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjb3JlIFRoZSBzaW1pbGFyaXR5IHNjb3JlIGFzIGEgZmxvYXQgbnVtYmVyIGluIHJhbmdlIFswLjAsIDEuMF0uXG4gKiAxLjAgaXMgdGhlIGhpZ2hlc3Qgc2NvcmUgKG1lYW5zIGJvdGggaW1hZ2VzIGFyZSB0b3RhbGx5IGVxdWFsKS5cbiAqIEBwcm9wZXJ0eSB7P0J1ZmZlcn0gdmlzdWFsaXphdGlvbiBUaGUgdmlzdWFsaXphdGlvbiBvZiB0aGUgbWF0Y2hpbmcgcmVzdWx0XG4gKiByZXByZXNlbnRlZCBhcyBQTkcgaW1hZ2UgYnVmZmVyLiBUaGlzIGltYWdlIGluY2x1ZGVzIGJvdGggaW5wdXQgcGljdHVyZXMgd2hlcmVcbiAqIGRpZmZlcmVuY2UgcmVnaW9ucyBhcmUgaGlnaGxpZ2h0ZWQgd2l0aCByZWN0YW5nbGVzLlxuICovXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc2ltaWxhcml0eSBzY29yZSBiZXR3ZWVuIHR3byBpbWFnZXMuXG4gKiBJdCBpcyBleHBlY3RlZCwgdGhhdCBib3RoIGltYWdlcyBoYXZlIHRoZSBzYW1lIHJlc29sdXRpb24uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGltZzFEYXRhIFRoZSBkYXRhIG9mIHRoZSBmaXJzdCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbWcyRGF0YSBUaGUgZGF0YSBvZiB0aGUgc2Vjb25kIGltYWdlIHBhY2tlZCBpbnRvIGEgTm9kZUpTIGJ1ZmZlclxuICogQHBhcmFtIHs/U2ltaWxhcml0eU9wdGlvbnN9IG9wdGlvbnMgW3t9XSBTZXQgb2Ygc2ltaWxhcml0eSBjYWxjdWxhdGlvbiBvcHRpb25zXG4gKlxuICogQHJldHVybnMge1NpbWlsYXJpdHlSZXN1bHR9IFRoZSBjYWxjdWxhdGlvbiByZXN1bHRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZ2l2ZW4gaW1hZ2VzIGhhdmUgZGlmZmVyZW50IHJlc29sdXRpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEltYWdlc1NpbWlsYXJpdHkgKGltZzFEYXRhLCBpbWcyRGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGluaXRPcGVuQ1YoKTtcblxuICBjb25zdCB7dmlzdWFsaXplID0gZmFsc2V9ID0gb3B0aW9ucztcbiAgbGV0IFt0ZW1wbGF0ZSwgcmVmZXJlbmNlXSA9IGF3YWl0IEIuYWxsKFtcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzFEYXRhKSxcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzJEYXRhKVxuICBdKTtcbiAgaWYgKHRlbXBsYXRlLnJvd3MgIT09IHJlZmVyZW5jZS5yb3dzIHx8IHRlbXBsYXRlLmNvbHMgIT09IHJlZmVyZW5jZS5jb2xzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGltYWdlcyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaXplIGluIG9yZGVyIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAnY2FsY3VsYXRlIHRoZSBzaW1pbGFyaXR5IHNjb3JlLicpO1xuICB9XG4gIFt0ZW1wbGF0ZSwgcmVmZXJlbmNlXSA9IGF3YWl0IEIuYWxsKFtcbiAgICB0ZW1wbGF0ZS5jb252ZXJ0VG9Bc3luYyhjdi5DVl84VUMzKSxcbiAgICByZWZlcmVuY2UuY29udmVydFRvQXN5bmMoY3YuQ1ZfOFVDMylcbiAgXSk7XG5cbiAgY29uc3QgbWF0Y2hlZCA9IGF3YWl0IHJlZmVyZW5jZS5tYXRjaFRlbXBsYXRlQXN5bmModGVtcGxhdGUsIGN2LlRNX0NDT0VGRl9OT1JNRUQpO1xuICBjb25zdCBtaW5NYXggPSBhd2FpdCBtYXRjaGVkLm1pbk1heExvY0FzeW5jKCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBzY29yZTogbWluTWF4Lm1heFZhbFxuICB9O1xuICBpZiAodmlzdWFsaXplKSB7XG4gICAgY29uc3QgcmVzdWx0TWF0ID0gbmV3IGN2Lk1hdCh0ZW1wbGF0ZS5yb3dzLCB0ZW1wbGF0ZS5jb2xzICogMiwgY3YuQ1ZfOFVDMyk7XG4gICAgYXdhaXQgQi5hbGwoW1xuICAgICAgcmVmZXJlbmNlLmNvcHlUb0FzeW5jKFxuICAgICAgICByZXN1bHRNYXQuZ2V0UmVnaW9uKG5ldyBjdi5SZWN0KDAsIDAsIHJlZmVyZW5jZS5jb2xzLCByZWZlcmVuY2Uucm93cykpKSxcbiAgICAgIHRlbXBsYXRlLmNvcHlUb0FzeW5jKFxuICAgICAgICByZXN1bHRNYXQuZ2V0UmVnaW9uKG5ldyBjdi5SZWN0KHJlZmVyZW5jZS5jb2xzLCAwLCB0ZW1wbGF0ZS5jb2xzLCB0ZW1wbGF0ZS5yb3dzKSkpXG4gICAgXSk7XG4gICAgbGV0IG1hc2sgPSByZWZlcmVuY2UuYWJzZGlmZih0ZW1wbGF0ZSk7XG4gICAgbWFzayA9IGF3YWl0IG1hc2suY3Z0Q29sb3JBc3luYyhjdi5DT0xPUl9CR1IyR1JBWSk7XG4gICAgbGV0IGNvbnRvdXJzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIG1hc2sgPSBhd2FpdCBtYXNrLnRocmVzaG9sZEFzeW5jKDEyOCwgMjU1LCBjdi5USFJFU0hfQklOQVJZIHwgY3YuVEhSRVNIX09UU1UpO1xuICAgICAgY29udG91cnMgPSBhd2FpdCBtYXNrLmZpbmRDb250b3Vyc0FzeW5jKGN2LlJFVFJfRVhURVJOQUwsIGN2LkNIQUlOX0FQUFJPWF9TSU1QTEUpO1xuICAgIH0gY2F0Y2ggKGlnbikge1xuICAgICAgLy8gTm8gY29udG91cnMgY2FuIGJlIGZvdW5kLCB3aGljaCBtZWFucywgbW9zdCBsaWtlbHksIHRoYXQgaW1hZ2VzIGFyZSBlcXVhbFxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRvdXIgb2YgY29udG91cnMpIHtcbiAgICAgIGNvbnN0IGJvdW5kaW5nUmVjdCA9IGNvbnRvdXIuYm91bmRpbmdSZWN0KCk7XG4gICAgICBoaWdobGlnaHRSZWdpb24ocmVzdWx0TWF0LCBib3VuZGluZ1JlY3QpO1xuICAgICAgaGlnaGxpZ2h0UmVnaW9uKHJlc3VsdE1hdCwge1xuICAgICAgICB4OiByZWZlcmVuY2UuY29scyArIGJvdW5kaW5nUmVjdC54LFxuICAgICAgICB5OiBib3VuZGluZ1JlY3QueSxcbiAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVzdWx0LnZpc3VhbGl6YXRpb24gPSBhd2FpdCBjdi5pbWVuY29kZUFzeW5jKCcucG5nJywgcmVzdWx0TWF0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9jY3VycmVuY2VPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB2aXN1YWxpemUgW2ZhbHNlXSBXaGV0aGVyIHRvIHJldHVybiB0aGUgcmVzdWx0aW5nIHZpc2FsaXphdGlvblxuICogYXMgYW4gaW1hZ2UgKHVzZWZ1bCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICogQHByb3BlcnR5IHs/ZmxvYXR9IHRocmVzaG9sZCBbMC41XSBBdCB3aGF0IG5vcm1hbGl6ZWQgdGhyZXNob2xkIHRvIHJlamVjdFxuICogYSBtYXRjaFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT2NjdXJyZW5jZVJlc3VsdFxuICogQHByb3BlcnR5IHtSZWN0fSByZWN0IFRoZSByZWdpb24gb2YgdGhlIHBhcnRpYWwgaW1hZ2Ugb2NjdXJlbmNlXG4gKiBvbiB0aGUgZnVsbCBpbWFnZVxuICogQHByb3BlcnR5IHs/QnVmZmVyfSB2aXN1YWxpemF0aW9uIFRoZSB2aXN1YWxpemF0aW9uIG9mIHRoZSBtYXRjaGluZyByZXN1bHRcbiAqIHJlcHJlc2VudGVkIGFzIFBORyBpbWFnZSBidWZmZXIuIE9uIHRoaXMgaW1hZ2UgdGhlIG1hdGNoaW5nXG4gKiByZWdpb24gaXMgaGlnaGxpZ2h0ZWQgd2l0aCBhIHJlY3RhbmdsZS5cbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG9jY3VyZW5jZSBwb3NpdGlvbiBvZiBhIHBhcnRpYWwgaW1hZ2UgaW4gdGhlIGZ1bGxcbiAqIGltYWdlLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBmdWxsSW1nRGF0YSBUaGUgZGF0YSBvZiB0aGUgZnVsbCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBwYXJ0aWFsSW1nRGF0YSBUaGUgZGF0YSBvZiB0aGUgcGFydGlhbCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7P09jY3VycmVuY2VPcHRpb25zfSBvcHRpb25zIFt7fV0gU2V0IG9mIG9jY3VycmVuY2UgY2FsY3VsYXRpb24gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtPY2N1cnJlbmNlUmVzdWx0fVxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIG9jY3VyZW5jZXMgb2YgdGhlIHBhcnRpYWwgaW1hZ2UgY2FuIGJlIGZvdW5kIGluIHRoZSBmdWxsIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEltYWdlT2NjdXJyZW5jZSAoZnVsbEltZ0RhdGEsIHBhcnRpYWxJbWdEYXRhLCBvcHRpb25zID0ge30pIHtcbiAgaW5pdE9wZW5DVigpO1xuXG4gIGNvbnN0IHt2aXN1YWxpemUgPSBmYWxzZSwgdGhyZXNob2xkID0gREVGQVVMVF9NQVRDSF9USFJFU0hPTER9ID0gb3B0aW9ucztcbiAgY29uc3QgW2Z1bGxJbWcsIHBhcnRpYWxJbWddID0gYXdhaXQgQi5hbGwoW1xuICAgIGN2LmltZGVjb2RlQXN5bmMoZnVsbEltZ0RhdGEpLFxuICAgIGN2LmltZGVjb2RlQXN5bmMocGFydGlhbEltZ0RhdGEpXG4gIF0pO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgdHJ5IHtcbiAgICBjb25zdCBtYXRjaGVkID0gYXdhaXQgZnVsbEltZy5tYXRjaFRlbXBsYXRlQXN5bmMocGFydGlhbEltZywgY3YuVE1fQ0NPRUZGX05PUk1FRCk7XG4gICAgY29uc3QgbWluTWF4ID0gYXdhaXQgbWF0Y2hlZC5taW5NYXhMb2NBc3luYygpO1xuICAgIGlmIChtaW5NYXgubWF4VmFsIDwgdGhyZXNob2xkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGFueSBvY2N1cnJlbmNlcyBvZiB0aGUgcGFydGlhbCBpbWFnZSBpbiB0aGUgZnVsbCBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgaW1hZ2UgYWJvdmUgdGhlIHRocmVzaG9sZCBvZiAke3RocmVzaG9sZH0uIEhpZ2hlc3QgbWF0Y2ggdmFsdWUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYGZvdW5kIHdhcyAke21pbk1heC5tYXhWYWx9YCk7XG4gICAgfVxuICAgIHJlc3VsdC5yZWN0ID0ge1xuICAgICAgeDogbWluTWF4Lm1heExvYy54LFxuICAgICAgeTogbWluTWF4Lm1heExvYy55LFxuICAgICAgd2lkdGg6IHBhcnRpYWxJbWcuY29scyxcbiAgICAgIGhlaWdodDogcGFydGlhbEltZy5yb3dzXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYW55IG9jY3VyZW5jZXMgb2YgdGhlIHBhcnRpYWwgaW1hZ2UgaW4gdGhlIGZ1bGwgaW1hZ2UuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZX1gKTtcbiAgfVxuICBpZiAodmlzdWFsaXplKSB7XG4gICAgaGlnaGxpZ2h0UmVnaW9uKGZ1bGxJbWcsIHJlc3VsdC5yZWN0KTtcbiAgICByZXN1bHQudmlzdWFsaXphdGlvbiA9IGF3YWl0IGN2LmltZW5jb2RlQXN5bmMoJy5wbmcnLCBmdWxsSW1nKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyb3AgdGhlIGltYWdlIGJ5IGdpdmVuIHJlY3RhbmdsZSAodXNlIGJhc2U2NCBzdHJpbmcgYXMgaW5wdXQgYW5kIG91dHB1dClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0SW1hZ2UgVGhlIHN0cmluZyB3aXRoIGJhc2U2NCBlbmNvZGVkIGltYWdlXG4gKiBAcGFyYW0ge1JlZ2lvbn0gcmVjdCBUaGUgc2VsZWN0ZWQgcmVnaW9uIG9mIGltYWdlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiBjcm9wcGVkIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyb3BCYXNlNjRJbWFnZSAoYmFzZTY0SW1hZ2UsIHJlY3QpIHtcbiAgY29uc3QgaW1hZ2UgPSBhd2FpdCBiYXNlNjRUb0ltYWdlKGJhc2U2NEltYWdlKTtcbiAgY3JvcEltYWdlKGltYWdlLCByZWN0KTtcbiAgcmV0dXJuIGF3YWl0IGltYWdlVG9CYXNlNjQoaW1hZ2UpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBuZ2pzIGltYWdlIGZyb20gZ2l2ZW4gYmFzZTY0IGltYWdlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NEltYWdlIFRoZSBzdHJpbmcgd2l0aCBiYXNlNjQgZW5jb2RlZCBpbWFnZVxuICogQHJldHVybiB7UE5HfSBUaGUgaW1hZ2Ugb2JqZWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJhc2U2NFRvSW1hZ2UgKGJhc2U2NEltYWdlKSB7XG4gIGNvbnN0IGltYWdlQnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0SW1hZ2UsICdiYXNlNjQnKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBQTkcoe2ZpbHRlclR5cGU6IFNDQU5MSU5FX0ZJTFRFUl9NRVRIT0R9KTtcbiAgICBpbWFnZS5wYXJzZShpbWFnZUJ1ZmZlciwgKGVyciwgaW1hZ2UpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by1jYWxsYmFja3NcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGJhc2U2NCBzdHJpbmcgZm9yIGdpdmVuIGltYWdlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7UE5HfSBpbWFnZSBUaGUgaW1hZ2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgd2l0aCBiYXNlNjQgZW5jb2RlZCBpbWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBpbWFnZVRvQmFzZTY0IChpbWFnZSkge1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGltYWdlLnBhY2soKVxuICAgIC5vbignZGF0YScsIChjaHVuaykgPT4gY2h1bmtzLnB1c2goY2h1bmspKS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KGNodW5rcykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCAoZXJyKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JvcCB0aGUgaW1hZ2UgYnkgZ2l2ZW4gcmVjdGFuZ2xlXG4gKlxuICogQHBhcmFtIHtQTkd9IGltYWdlIFRoZSBpbWFnZSB0byBtdXRhdGUgYnkgY3JvcHBpbmdcbiAqIEBwYXJhbSB7UmVnaW9ufSByZWN0IFRoZSBzZWxlY3RlZCByZWdpb24gb2YgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gY3JvcEltYWdlIChpbWFnZSwgcmVjdCkge1xuICBjb25zdCBpbWFnZVJlY3QgPSB7d2lkdGg6IGltYWdlLndpZHRoLCBoZWlnaHQ6IGltYWdlLmhlaWdodH07XG4gIGNvbnN0IGludGVyUmVjdCA9IGdldFJlY3RJbnRlcnNlY3Rpb24ocmVjdCwgaW1hZ2VSZWN0KTtcbiAgaWYgKGludGVyUmVjdC53aWR0aCA8IHJlY3Qud2lkdGggfHwgaW50ZXJSZWN0LmhlaWdodCA8IHJlY3QuaGVpZ2h0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JvcCAke0pTT04uc3RyaW5naWZ5KHJlY3QpfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkoaW1hZ2VSZWN0KX0gYmVjYXVzZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlbSB3YXMgbm90IHRoZSBzaXplIG9mIHRoZSByZWN0YCk7XG4gIH1cblxuICBjb25zdCBmaXJzdFZlcnRpY2FsUGl4ZWwgPSBpbnRlclJlY3QudG9wO1xuICBjb25zdCBsYXN0VmVydGljYWxQaXhlbCA9IGludGVyUmVjdC50b3AgKyBpbnRlclJlY3QuaGVpZ2h0O1xuXG4gIGNvbnN0IGZpcnN0SG9yaXpvbnRhbFBpeGVsID0gaW50ZXJSZWN0LmxlZnQ7XG4gIGNvbnN0IGxhc3RIb3Jpem9udGFsUGl4ZWwgPSBpbnRlclJlY3QubGVmdCArIGludGVyUmVjdC53aWR0aDtcblxuICBjb25zdCBjcm9wcGVkQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgeSA9IGZpcnN0VmVydGljYWxQaXhlbDsgeSA8IGxhc3RWZXJ0aWNhbFBpeGVsOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gZmlyc3RIb3Jpem9udGFsUGl4ZWw7IHggPCBsYXN0SG9yaXpvbnRhbFBpeGVsOyB4KyspIHtcbiAgICAgIGNvbnN0IGZpcnN0Qnl0ZUlkeEluUGl4ZWxCbG9jayA9IChpbWFnZVJlY3Qud2lkdGggKiB5ICsgeCkgPDwgMjtcbiAgICAgIGZvciAobGV0IGJ5dGVJZHggPSAwOyBieXRlSWR4IDwgQllURVNfSU5fUElYRUxfQkxPQ0s7IGJ5dGVJZHgrKykge1xuICAgICAgICBjcm9wcGVkQXJyYXkucHVzaChpbWFnZS5kYXRhW2ZpcnN0Qnl0ZUlkeEluUGl4ZWxCbG9jayArIGJ5dGVJZHhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbWFnZS5kYXRhID0gQnVmZmVyLmZyb20oY3JvcHBlZEFycmF5KTtcbiAgaW1hZ2Uud2lkdGggPSBpbnRlclJlY3Qud2lkdGg7XG4gIGltYWdlLmhlaWdodCA9IGludGVyUmVjdC5oZWlnaHQ7XG4gIHJldHVybiBpbWFnZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdEludGVyc2VjdGlvbiAocmVjdCwgaW1hZ2VTaXplKSB7XG4gIGNvbnN0IGxlZnQgPSByZWN0LmxlZnQgPj0gaW1hZ2VTaXplLndpZHRoID8gaW1hZ2VTaXplLndpZHRoIDogcmVjdC5sZWZ0O1xuICBjb25zdCB0b3AgPSByZWN0LnRvcCA+PSBpbWFnZVNpemUuaGVpZ2h0ID8gaW1hZ2VTaXplLmhlaWdodCA6IHJlY3QudG9wO1xuICBjb25zdCB3aWR0aCA9IGltYWdlU2l6ZS53aWR0aCA+PSAobGVmdCArIHJlY3Qud2lkdGgpID8gcmVjdC53aWR0aCA6IChpbWFnZVNpemUud2lkdGggLSBsZWZ0KTtcbiAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VTaXplLmhlaWdodCA+PSAodG9wICsgcmVjdC5oZWlnaHQpID8gcmVjdC5oZWlnaHQgOiAoaW1hZ2VTaXplLmhlaWdodCAtIHRvcCk7XG4gIHJldHVybiB7bGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fTtcbn1cblxuZXhwb3J0IHtcbiAgY3JvcEJhc2U2NEltYWdlLCBiYXNlNjRUb0ltYWdlLCBpbWFnZVRvQmFzZTY0LCBjcm9wSW1hZ2UsIGdldEltYWdlc01hdGNoZXMsXG4gIGdldEltYWdlc1NpbWlsYXJpdHksIGdldEltYWdlT2NjdXJyZW5jZSwgZ2V0SmltcEltYWdlLCBNSU1FX0pQRUcsIE1JTUVfUE5HLFxuICBNSU1FX0JNUCxcbn07XG4iXSwiZmlsZSI6ImxpYi9pbWFnZS11dGlsLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
